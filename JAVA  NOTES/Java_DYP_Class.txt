
	---------------- Java Programming -----------------------

	Computer ---> 
	Language --->
	Programming Languages --> 



		     SIMULA
		     COBOL								   |-- Sun Microsystem --> Java
	Assembly --> Fortran ----> ALGOL60 --> CPL --> BCPL-----> B -----> C ----> C++ ====|-- Microsoft corpo.--> .Net
		     RPG	    (1960)   (1963)    (1967)    (1970)   (1972) (1983-84) |-- CWI -------------> Python
		     BASIC								   |
		     Pascal
		     ....


	// History of Java: 


		- JAMES GOSLING Introduced the Java Programming language.

		- Initially he started with the platform independancy, and developed GreenTalk with ext. (*.gt)

		- After some days he joined the Sun Microsystem, as head of green project team, formed to develop

		- The platform independent language as a internal tools of the company to develop application
		  for different consumer electronic product.

		 - 1990 --> Touch sencetive application

		 - 1991 -> language named Oak is introduced.

		 - 1995 --> OAK renamed as Java

// Different versions of Java: 

		1995 - jdk alpha and beta
		1996 - jdk 1.0
		1997 - jdk 1.1

		1998 - J2SE 1.2
		2000 - J2SE 1.3 
		2002 - J2SE 1.4 
		
		2004 - J2SE 5.0 

		2006 - Java SE 6
		2011 - Java SE 7 
		2014 - Java SE 8 
		
		2017 - Java SE 9                   Onwards ---> JSE 9 ...
		2018 - Java SE 10 (March)
		     - Java SE 11 (September)

		2019 - Java SE 12 (March)
		     - Java SE 13 (September)

		2020 - Java SE 14 (March)
		     - Java SE 15 (September)

		2021 - Java SE 16 (March)
		     - Java SE 17 (September)

		Java SE 18 (to be released by March 2022)



// ---------------------------------------------------------------------------------------------

	Different Java Editions:


			     |-> J2SE(Standard Edition)
			     |
 		Java --------|-> J2EE(Enterprise Edition)
			     |
			     |-> J2ME( Micro Edition)


// ----------------------------------------------------------------------------------------------

	// Java Environment: 

	Platform = OS + Processor Arct.

	It is basically divided into 2 parts

		jre --> java runtime environment: Needed to run the java program
		jdk ---> java developement Needed to develop and run the java program

//----------------------------------------------------------------------------------------------------------


	// Java Buzzwords (Features of Java)	

		-  Simple 
		-  Object Oriented
		-  Portable
		-  Platform Independent
		-  secure
		-  Robust
		-  Architecture neutral
		-  half compiled and half Interpreted
		-  Multithreaded
		-  Distributed
		-  Dynamic
		-  High Performance
//------------------------------------------------------------------------------------------------------------

	// Differences Between C and Java

		https://www.interviewbit.com/blog/difference-between-c-and-java/


	// Differences Between C++ and Java

		https://www.interviewbit.com/blog/difference-between-cpp-and-java/



//----------------------------------------------------------------------------------------------------------

// Execution flow of C/C++ and Java	


		C/C++									Java

	Instructions		Progr_nm					     *.java
		|_________________|							|
			 |								|	
			 |         Debug					     Compile(javac)	
	source code	*.c/*.cpp <---|							|
			 |            |							|
			 |            |						    *.class
		      Compile ------->| Compile-time 				    (byte code)	              		 ^
			 |            | error						|                	 Compile |
			 |            |							|			===================
	backup file    *.bak          |					-------------------------------------   Interpreter |
			 |            |					|		|		| ..                V
			 |            |				       JVM             JVM             JVM --> (Platform dependent JVM)	
	 Linker -------->| ---------> |  Linker error			|		|		|
			 |            |                               Windows         Linux            MAC  
			 |            |                                 | 		|		|                          
	object code    *.obj	      |				     Native code    Native code     Native code	
			 |            |					|		|		|
			 |	      ^				      Run              RUN             Run	
     Executable file   *.exe	      |                                 |               |               |
			 |	      |	                             Output           Output          Output  
		   	Run --------->| Runtime Error
			 |
		       Output							WRITE ONCE RUN EVERYWHERE	



//---------------------------------------------------------------------------------------------------------


	Java Editors and IDE's
	======================

		Editor: Notepad, Editplus, Notepad++ ...
		
		IDE: Best Java IDEs
			Eclipse. Platform – Linux/macOS/Solaris/Windows. ...
			NetBeans. Platform – Linux/macOS/Solaris/Windows. ...
			IntelliJ IDEA. Platform – Linux/macOS/Windows. ...
			BlueJ. Platform – Linux/macOS/Windows. ...
			(Oracle) JDeveloper. Platform – Linux/macOS/Windows. 


	Now we have see, how to write a code where:

		1. Use any editor/ide

		2. Install jdk/jre (https://www.oracle.com/in/java/technologies/javase/javase8-archive-downloads.html)

		3. Use notepad as a editor and write a code as

			class <cls_nm>
			{
				public static void main(String []args)
				{
					------------------;
					------------------;
					program_body ;
					------------------;
					------------------;
				}
			}

			class Demo
			{
				public static void main(String []args)
				{
					System.out.print("Welcome to Java Programming");
				}
			}

		4. Save the code in C:\Program Files\Java\jdk-17.0.1\bin As <class_nm>.java

		5. win+r --> cmd --> enter (attend the folder where the source file, compiler and interpreter is present) as

			C:\Users\hp>cd\
			C:\>cd "Program Files\Java\jdk-17.0.1\bin"
			C:\Program Files\Java\jdk-17.0.1\bin>javac Demo.java     (compilation where you get the bytecode (*.class) )
			C:\Program Files\Java\jdk-17.0.1\bin>java Demo  	 (Byte code interpretation)
				Welcome to Java Programming
			C:\Program Files\Java\jdk-17.0.1\bin>

	//------------------------------------------------------------------------------------------------------------------

	How to run, same code when source file (*.java) is in different folder
				
			C:\Users\hp>e:
			E:\>cd myjavafiles
			E:\myjavafiles>javac First.java

				'javac' is not recognized as an internal or external command,
				operable program or batch file.

			E:\myjavafiles>set path=C:\Program Files\Java\jdk-17.0.1\bin
			E:\myjavafiles>javac First.java
			E:\myjavafiles>java First
				Welcome to Java Programming-First
			E:\myjavafiles>

		Note that the path is applicable till the current session of the command prompt.
		to set the path in the permanent manner set the path in Environmeent variable


		Setting the environment variable: this pc --> rh+ click ---> properties --> adv. system settings
						--> Advanced tab --> environment variable --> user variable path


				-if already path is there -> edit --> new-> paste path (C:\Program Files\Java\jdk-17.0.1\bin)

				otherwise  user variable path--> new and write

				variable name --> path
				variable value --> C:\Program Files\Java\jdk-17.0.1\bin) --> ok....

//-------------------------------------------------------------------------------------------------------------
	Youtube Link: https://youtu.be/RBxum7M3B94?si=jepmNZAtetZfJKFp
//-------------------------------------------------------------------------------------------------------------


	Details of welcome program:
	============================

	class WelcomeProg
	{
		public static void main(String []args)
		{
			System.out.print("Welcome to Java by Archer InfoTech");
		}
	}
	
	Line 1: class WelcomeProg:

			class: It is keyword which allows you to create your own type.
			WelcomeProg: this is name of UDT, it must be valide identifier. Internally in java lib, the have
					  choosen, First letter of class name in uppercase and all other in lowercase if it is
					  made from from one word, if multiple words then first character of each word in ucase
					  and all other in lcase.

						e.g.	First, Demo, FirstProgram, ExampleDemoWelcome
					It is recommended, not compalsory

	Line 3: public static void main(String []args) 

			public: it is used to define the visiblity of method main(), coz the javac and java are not members of class
				as a outsiders they must have access to class members therefore visibility is public.

			static: The static members gains the memory space when class is loaded into memory, no need of object
				creation. therefore the method main() decl. as static

			void: It is returning type of method main(), it is void coz java program does not return any value to OS

			main(): It is method name, and as it is main(), it is considered as a starting point of of your program

			String []args: String is Built-in class from java.lang package, it is language support package, which is 
					imported bydefault. []args it is array of arguments, which is passed automatically at the
					time of execution from commandline, in absence null is collected.
					simply it is array of objects.

	Line 5:  System.out.print("Welcome to Java");

			"Welcome to Java" : It is data, to be displayed
			print() is a method from PrintStream class used to display the data on screen.
			out is predefined object of PrintStream class, declare ed as a static in System class
			System is a class from java.lang package.


	>>javac WelcomeProg.java (WelcomeProg - is a file name)
	>>java WelcomeProg (WelcomeProg - class name containing main() method)

 //-----------------------------------------------------------------------------------------------------------------------

	// When we write a file generaly we keep file name and main class name same, but it may be different
	   In such case, compile using file name and run using main class name.
	
	   if a java file having two or more class defined within it, then there are those number of class
	   files, from which we have to use class name containing main() to run the program.

	lets see ...

class Sample
{
}
class Test
{
}
class WelcomeProgram
{
	public static void main(String []args)
	{
		System.out.print("Welcome to Java by Archer InfoTech");
	}
}

 --------- output ----------

C:\Users\archerinfotech>d:

D:\>cd jdyp

D:\jdyp>javac Welcome.java

D:\jdyp>java WelcomeProgram
Welcome to Java by Archer InfoTech
D:\jdyp>

//------------------------------------------------------------------------------------------

	// Knowing the String []args

	 - args : It refers to arguments, you can choose any name for it rather than args
	 - [] args: It represents array name
	 - String []args: Array of String objects, where String is class from java.lang package,
			  which is imported bydefault  

class MainArgu
{
	public static void main(String []args)
	{
		System.out.println(args);
		System.out.println("0 - "+args[0]);
		System.out.println("1 - "+args[1]);
		System.out.println("2 - "+args[2]);
	}
}

/*
  ------- How to run --------

	case 1:
		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu
		[Ljava.lang.String;@4517d9a3
		Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
       		 at MainArgu.main(MainArgu.java:6)

	case 2:

		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu hello all
		[Ljava.lang.String;@4517d9a3
		0 - hello
		1 - all
		Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2
        		at MainArgu.main(MainArgu.java:8)

	case 3:
		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu good morning all
		[Ljava.lang.String;@4517d9a3
		0 - good
		1 - morning
		2 - all

		D:\jdyp>java MainArgu good morning all of you
		[Ljava.lang.String;@4517d9a3
		0 - good
		1 - morning
		2 - all

		D:\jdyp>java MainArgu try 123 or 456
		[Ljava.lang.String;@4517d9a3
		0 - try
		1 - 123
		2 - or

 * Note that when there is no any argument at location, the interpreter will generate an error message at
   runtime class Exception which will terminate the program.

*/

//----------------------------------------------------------------------------------------------------

	Now we need to proceed using the path fillowed in the C and C++

	i.e.
				constant
	charcter set -----> 	keyword ------> Instructions ----> program ----> module ---> software
				variable


	Java Character set:

		- ASCII(American Standard Code for Information Interchange):  Provides the binary string to all symbols present
		  in the US English, which are used in different electronic devices.

		- ASCII used to code in english, but java supports different human understable languages for coding. means java
		  having rich character set as cmp to c/c++. The Standard Code system names unicode system used in the 
		  java which provides the 16 bit binary string to each symbol for different languages.     

		What is difference between ASCII and UNICODE.
		 - ASCII is suitable for basic, English-only text.
		 - Unicode is a comprehensive encoding system that supports global languages and symbols, making it the standard 
		   for modern computing.



	// Constants: These are the elements in the program having fix value.

							      Java Constants
								    |
							---------------------------
							|			  |
						    Numeric 		     Non-Numeric
							|			  |
						-----------------	-----------------
						|		|	|		|	
					   Integer     floating-point  character     String
					-6,4,56    -5.3,7.0,78.6755    'a', '$'     "A", "Hello"		
									'H' '4'	     "a123"

	// Keyword: These are reserved words, whose meaning is already known to compiler. 


		abstract	continue	for		new		switch

		assert***	default		goto*		package		synchronized
	
		boolean		do		if		private		this

		break		double		implements	protected	throw

		byte		else		import		public		throws

		case		enum****	instanceof	return		transient

		catch		extends		int		short		try

		char		final		interface	static		void

		class		finally		long		strictfp**	volatile

		const*		float		native		super		while 

		*	 	not used
		**	 	added in 1.2
		***	 	added in 1.4
		****	 	added in 5.0

	(https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)


 	Java Data Types: Tool used for the memory allocation.

		- Primitive data types: These are provided by the language itself. e.g. int, char, byte..
		- Non-Primitive data types: The are defined by the programmers according to the need. e.g. class, interface


						Java Data Types
							|
					---------------------------------
					|				|
				Primitive Data Types		Non-Primitive Data Types
					|				|
			   --------------------------              - String
			   |			    |   	   - Array
		      Numeric		 	boolean	   	   - Vector
			  |	                (1 bit)
			------------------
			|		 |
		   Integrals	      character	
			|                |
	-------------------------      char(2)		
	|			|				
      integer		     floating point    		
      |				|					 
      |- byte (1)		|- float(4)    
      |- short (2)		|- double(8)
      |- int(4)
      |- long(8)


	- The defalt integer value is considered as a int and default fractional value considered as double.
	- When you decl the variable, java demands for the init. of variables, otherwise it will generate the
	  error message, 
				"variable xxx might not have been initialized"

	- When the value of variable having higher type is assigned to variable of lower type, then it will
	  generate the error message

		e.g.
			a=c;	gives the following error, when a is byte variable and c is int variable

			"possible lossy conversion from int to byte" 
		 
		In such case, where you want to convert the value from higther type to lower type, go for
		the type casting;

			i.e.	a=(byte)c;

		Note carefully that, lower type to higher type promoted automatically.

	- The long costant is represented using 'l' or 'L' as a prefix and for the float 'f' or 'F' is used.

	- Java allows you to decl. the variables anywhere in the program, just decl before using it.


	* What is difference between C,C++ data types and java data types?
	* Why java character needs 2 bytes?
	* Which are different higher level anguages used to code in java.

class Values
{
	public static void main(String []args)
	{
		int x=10;
		byte b=(byte)x;
		short s=(short)x;
		long l=25;
		System.out.println("\n x="+x+"\t b="+b+"\t s="+s+"\t l="+l);

		float f1=45.23F;
		double d1=f1;
		System.out.println("\n f1="+f1+"\t d1="+d1);

		float f2=(float)d1;
		System.out.println("\n f2="+f2);
	}

}

	----------- Execution Attempts ----------

D:\jdyp>javac Values.java
Values.java:6: error: incompatible types: possible lossy conversion from int to byte
                byte b=x;
                       ^
Values.java:7: error: incompatible types: possible lossy conversion from int to short
                short s=x;
                        ^
Values.java:11: error: incompatible types: possible lossy conversion from double to float
                float f1=45.23;
                         ^
Values.java:15: error: incompatible types: possible lossy conversion from double to float
                float f2=d1;
                         ^
4 errors

// after changing 

D:\jdyp>javac Values.java

D:\jdyp>java Values

 x=10    b=10    s=10    l=25

 f1=45.23        d1=45.22999954223633

 f2=45.23


	* What is widening conversion and narrowing conversion?

	In Java, widening conversion and narrowing conversion are two types of type conversions that occur when a value of one 
	data type is converted to another. These conversions happen in the context of primitive data types and determine whether 
	data is safely transformed or if precision might be lost.

	- Widening Conversion (Implicit Conversion): Converting a smaller (or less precise) data type to a larger (or more precise) 
	  data type. This is done automatically by the Java compiler because there’s no risk of data loss.

	- Narrowing Conversion (Explicit Conversion): Converting a larger (or more precise) data type to a smaller (or less precise) 
	  data type. This is not done automatically because there’s a risk of data loss or truncation.


//----------------------------------------------------------------------------------------------------------------------

	// Different ways of Data Input in Java

 1. Data Input by direct init

class InputUsinginit
{
	public static void main(String []args)
	{
		int x=134;	
		byte b=10;	
		char ch='$';	
		double db=56.2323;
		float ft=3.4F;
		boolean b=true;

		System.out.println("x="+x);		
		System.out.println("b="+b);
		System.out.println("value of ch is "+ch);
		System.out.println("db is"+db);
		System.out.println("float value "+ft);
		System.out.println("boolean value "+b);
	}
}

//----------------------------------------------------------------------------------------

 2. Data Input as a commandline argument

class DataInputCmdln
{
	public static void main(String []args)
	{
		String s1="-",s2="-";

		s1=args[0];
		s2=args[1];

		System.out.printn("String s1 is: "+s1);
		System.out.printn("String s2 is: "+s2);
	}
}
output:

E:\javapfsdn23>javac DataInputCmdln.java

E:\javapfsdn23>java DataInputCmdln hello all
String s1 is: hello
String s2 is: all

E:\javapfsdn23>java DataInputCmdln hello
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1
        at DataInputCmdln.main(DataInputCmdln.java:8)

E:\javapfsdn23>java DataInputCmdln
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
        at DataInputCmdln.main(DataInputCmdln.java:7)


How to deal with such runtime errors called exception, which are generated when we will try to 
access the location which is not present.


class DataInputCmdln
{
	public static void main(String []args)
	{
		String s1="-",s2="-";

		try
		{
			s1=args[0];
			s2=args[1];
		}
		catch(Exception e){}

		System.out.println("String s1 is: "+s1);
		System.out.println("String s2 is: "+s2);
	}
}

output:

E:\javapfsdn23>javac DataInputCmdln.java

E:\javapfsdn23>java DataInputCmdln hello all
String s1 is: hello
String s2 is: all

E:\javapfsdn23>java DataInputCmdln hello
String s1 is: hello
String s2 is: -

E:\javapfsdn23>java DataInputCmdln
String s1 is: -
String s2 is: -


//----------------------------------------------------------------------------------------------------

We know the input is in form of strings and is is true even when we try to pass numeric 
values coz they are automatically converted into strings, then how to input the numeric values

class DataInputCmdln
{
	public static void main(String []args)
	{
		int x=args[0];
		double y=args[1];

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
	}
}

on compile 


E:\javapfsdn23>javac DataInputCmdlnNumeric.java
DataInputCmdlnNumeric.java:6: error: incompatible types: String cannot be converted to int
                int x=args[0];
                          ^
DataInputCmdlnNumeric.java:7: error: incompatible types: String cannot be converted to double
                double y=args[1];
                             ^
2 errors

can be eliminated using ...
class DataInputCmdlnNumeric
{
	public static void main(String []args)
	{
		String x=args[0]; // "12"--> 12
		String y=args[1];

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
		System.out.println("Sum is: "+(x+y));
	}
}

will gives....!! 
D:\jdyp>javac DataInputCmdlnNumeric.java

D:\jdyp>java DataInputCmdlnNumeric 12 34
x is: 12
y is: 34
Sum is: 1234

To get correct output...
we have to convert the arguments in args(which are always Strings). into the required primitive
data type. And for that we have use pre-defined functionality,

 i.e. there are group of classes defined to represent the primitive type into equivalent 
 object type, known as "Wrapper Classes". All such class having method

	static <return_type> parse<xxxx>(String arg);

 which will convert the string into curresponding primitive numeric value.	

	byte --> Byte
	short --> Short
	int --> Integer
	long --> Long
	float --> Float
	double --> Double


class DataInputCmdlnNumeric
{
	public static void main(String []args)
	{
		int x=Integer.parseInt(args[0]); // "12"--> 12
		double y=Double.parseDouble(args[1]);

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
		System.out.println("Sum is: "+(x+y));
	}
}
E:\javapfsdn23>javac DataInputCmdlnNumeric.java

E:\javapfsdn23>java DataInputCmdlnNumeric
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
        at DataInputCmdlnNumeric.main(DataInputCmdlnNumeric.java:6)

E:\javapfsdn23>java DataInputCmdlnNumeric 12 67.45
x is: 12
y is: 67.45
Sum is: 79.45

//-------------------------------------------------------------------------------------------

	// 3. Input using java.io.InputStreamReader and java.io.BufferedReader

	In this communication InputStreamReader and BufferedReader are predefined classes from java.io Package.
	from which InputStreamReader communicates with default sterams System.in and provides the data to 
	BufferedReader and then after processing that data converted into string by the BufferedReader using
	methods like readLine().

	* How may default stream are present in java.
	- In Java, three default streams are provided for handling input and output. These streams are part of 
	  the java.lang.System class and are available by default for every Java application

		- System.in:  Used to read input from the standard input stream, typically the keyboard.
		- System.out: Used to write output to the standard output stream, typically the console.
		- System.err: Used to write output to the standard error stream, typically for logging 
			      or error messages.

 // Input different values from keyboard and just display them.

import java.io.BufferedReader;
import java.io.InputStreamReader;
class IOUsingBI
{
	public static void main(String []args)
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);

		System.out.println("\n Enter the string: ");
		String str = br.readLine();
		
		System.out.println("\n Enter the int value: ");
		int x=Integer.parseInt(br.readLine());
		
		System.out.println("\n Enter the fractional value: ");
		double y=Double.parseDouble(br.readLine());

		System.out.println("\n Enter the short value: ");
		Short z=Short.parseShort(br.readLine());

		System.out.printn("\n str: "+str+"\n x="+x+"\n y="+y+"\n z="+z);
	}
}

D:\jdyp>javac IOUsingBI.java
IOUsingBI.java:12: error: unreported exception IOException; must be caught or declared to be thrown
                String str = br.readLine();
                                        ^
IOUsingBI.java:15: error: unreported exception IOException; must be caught or declared to be thrown
                int x=Integer.parseInt(br.readLine());
                                                  ^
IOUsingBI.java:18: error: unreported exception IOException; must be caught or declared to be thrown
                double y=Double.parseDouble(br.readLine());
                                                       ^
IOUsingBI.java:21: error: unreported exception IOException; must be caught or declared to be thrown
                Short z=Short.parseShort(br.readLine());
                                                    ^
4 errors

	// Now we have two options to solve the problem.
		
	- Use try-catch block
	- use throws clause


 - using try-catch

import java.io.BufferedReader;
import java.io.InputStreamReader;
class IOUsingBI
{
	public static void main(String []args)
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);

		try
		{
			System.out.println("\n Enter the string: ");
			String str = br.readLine();
		
			System.out.println("\n Enter the int value: ");
			int x=Integer.parseInt(br.readLine());
		
			System.out.println("\n Enter the fractional value: ");
			double y=Double.parseDouble(br.readLine());

			System.out.println("\n Enter the short value: ");
			Short z=Short.parseShort(br.readLine());

			System.out.println("\n str: "+str+"\n x="+x+"\n y="+y+"\n z="+z);
		}
		catch(Exception e){ }
	}
}

 ------ Output -----------------

D:\jdyp>javac IOUsingBI.java

D:\jdyp>java IOUsingBI

 Enter the string:
hello

 Enter the int value:
12

 Enter the fractional value:
6.7

 Enter the short value:
34

 str: hello
 x=12
 y=6.7
 z=34

	// Character input using java.io.InputStreamReader and java.io.BufferedReader
	
- use throws clause

import java.io.BufferedReader;
import java.io.InputStreamReader;
class CharIOUsingBI
{
	public static void main(String []args) throws Exception
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);
		char ch=' ';
		
		System.out.println("\n Enter the character: ");
		ch = br.readLine().charAt(0);
		
		System.out.println("\n character is="+ch);
	}
}


//-------------------------------------------------------------------------------------------

	4. Using java.util.Scanner to take the input from keyboard

import java.util.Scanner;
class InputUsingScannerObject
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		String str="";
		int x=0;
		double db=0.0;
		char ch='$';

		System.out.println("Enter any String: ");
		str=sc.nextLine();

		System.out.println("Enter any int value: ");
		x=sc.nextInt();

		System.out.println("Enter any double value: ");
		db=sc.nextDouble();

		System.out.println("Enter any character: ");
		ch=sc.next().charAt(0);

		System.out.println("String str: "+str);
		System.out.println("int value: "+x);
		System.out.println("double value: "+db);
		System.out.println("char value: "+ch);		
	}
}

output:

E:\javapfsdn23>javac InputUsingScannerObject.java

E:\javapfsdn23>java InputUsingScannerObject
Enter any String:
aaaa
Enter any int value:
12
Enter any double value:
3.3
Enter any character:
r
String str: aaaa
int value: 12
double value: 3.3
char value: r

 //-------------------------------------------------------------------------------------------------------

	5. Using javax.swing.JOptionPane.showInputDialog()

import javax.swing.JOptionPane;
class InputUsingShowIpDialog
{
	public static void main(String []args)
	{
		int x=0;
		double y=0.0;

		x=Integer.parseInt(JOptionPane.showInputDialog("Enter any int value: "));	
		y=Double.parseDouble(JOptionPane.showInputDialog("Enter any double value: "));	

		System.out.println("int value: "+x);
		System.out.println("double value: "+y);		
	}
}	

///=========================================================================================================================

// Operators in Java: Operators are used to process the data. There are following operators
			      present in the java.

			- Assignment Operators (= and short-hand operators)
			- Unary Operators ( - ++ -- (type) )
			- Arithmetic Operators ( + - * / % )
			- Relational Operators ( < <= > >= == != )
			- Logical Operators (&& || !)
			- conditional Operator ( ? : )
			- Bitwise Operators (& | ^ >> << >>>)
			- special Operators (. and instanceof )




- Assignment Operators (= and short-hand operators): will assigns constant value at its rh+, value of variable at its rh+ or
			answer of exper at its rh+ to variable at left.

		e.g.
			int x=10;	int y=x;	int z=x+y;

			shorthand expr: 	suppose,	x=x+10	can be written as x+=10;
								x=x/10  --> x/=10
								....

class DemoAssignment
{
	public static void main(String []args)
	{
		int x=10;
		int y=x;
		int z=x+y;
	
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		x+=100;
		y*=2;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

	}
}

//-------------------------------------------------------------------------------------------------------------------

- Unary Operators ( - ++ -- (type) )

	- will gives oppisite value
	++ incr by 1
	-- decr by 1

		inc/dec
		  |
	--------------------------
	|			|
     pre 		      post
  (++x, --x)		  (x++, x--)		


	++x  <-----> x=x+1	<------> x++
	--x  <-----> x=x-1      <------> x--

	when these operators are used in the expression, 

		pre --> expr --> post

	suppose x=5, and y=9

		z = ++x + y-- ;

	- find the basic expr
	- operate all pre operators
	- calc. the basic expr. with current values
	- operator all post operators

	- x becomes 6
	- assigned 15 to z
	-y becomes 8

import java.util.Scanner;
class DemoUnary
{
	public static void main(String []args)
	{
		int x=0;
		int y=0;
		int z=0;
	
		Scanner sc= new Scanner(System.in);
		System.out.println("\n Enter the values of x and y: ");
		x=sc.nextInt();
		y=sc.nextInt();

		z=-x;
		x++;
		--y;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=++x+y--;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);
	}
}

//------------------------------------------------------------------------


	(type): It refers to type casting, means changing the data type of variable obly at the of calc.


import java.util.Scanner;
class DemoCasting
{
	public static void main(String []args)
	{
		int x=0,y=0;
		double z=0;
	
		Scanner sc= new Scanner(System.in);
		System.out.println("\n Enter the values of x and y: ");
		x=sc.nextInt();
		y=sc.nextInt();  // 13, 5

		z=x/y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=(double)x/y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=x/(double)y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=(double)x/(double)y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

	}
}

output: 
E:\jprodyp>javac DemoCasting.java

E:\jprodyp>java DemoCasting

 Enter the values of x and y:
13
5

 x=13    y=5     z=2.0

 x=13    y=5     z=2.6

 x=13    y=5     z=2.6

 x=13    y=5     z=2.6

//----------------------------------------------------------------------------------------
- Arithmetic Operators ( + - * / % )

	// program to calc the simple interst.

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoArith
{
	public static void main(String []args) throws Exception
	{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int p=0,n=0;
		double r=0.0,si=0.0;

		System.out.println("Enter the value of p: ");
		p=Integer.parseInt(br.readLine());

		System.out.println("Enter the value of r: ");
		r=Double.parseDouble(br.readLine());

		System.out.println("Enter the value of n: ");
		n=Integer.parseInt(br.readLine());
	
		si=(p*r*n)/100;

		System.out.println("Simple Interst is: "+si);
	}
}


	Using % and / operator

	lets see simple example, we have to calculate 13/5

		   2 <------------- (13/5)
		________
	      5 )  13
		 - 10
		---------
		    3 <----------- (13%5)

 lets see some examples, ovserve the result and write the conclusion

	13/5=2		13%5=3
	27/7=3		27%7=6
	67/9=7		67%9=4
	123/10=12	123%10=3
	459/10=45	459%10=9
	3857/10=385	3857%10=7
	7/10=0		7%10=7

	- Div by 10 eliminates the last digit from number.
	  and mod by 10 gives the last digit.
	- In N/D, when N<D then div is 0 and rem is N

   // Enter any 3 digit number from keyboard and find addition of its all digits.
  // no=285 then ans = 5+8+2 => 15

import java.util.Scanner;
class DemoDivMod
{
	public static void main(String []args)
	{
		int no=0,rem=0,tot=0;
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter any 3 digit number: ");
		no=sc.nextInt(); //285
	
		rem=no%10; //5
		tot=tot+rem; // 0+5=5
		no=no/10; //28
	
		rem=no%10; //8
		tot=tot+rem; // 5+8=13
		no=no/10; //2	

		rem=no%10; //2
		tot=tot+rem; // 13+2=15
		no=no/10; //0

		System.out.println("\n Total is "+tot);
	}		
} 

Unlike C/C++, Here in java you can operate the % operator on fractional and -ve values,
when you operate the % operator on -ve values the sign of ans is taken as the sign of N form N/D.
class DemoMod
{
	public static void main(String []args)
	{
		int x=-13, y=5, z=-2;

		System.out.println("-%+: "+(x%y));
		System.out.println("-%-: "+(x%z));
		System.out.println("+%-: "+(21%z));
		System.out.println("+%+: "+(33%4));

		System.out.println("+%+: "+(33.5%4));
		System.out.println("+%+: "+(36.5%2.3));
	}
}

//-----------------------------------------------------------------------------------------

	// Relational Operators: (<, <=, >, >= ==, !=): These operators are used to find the
		relation between two operands. It will forms the condition which is useful in the
		conditional conditional control statements.

		thw ans of condition is boolean value true when it is true and false when false.


	suppose x=23	y=5;

		x>y	----> true 	means if we write z=x>y then true assigned to z.

		x!=y	----> true 
		
		y<1	----> false
		
		x%10==0 ----> false 

		100%y==0 ---> true 

class DemoRel
{
	public static void main(String []args)
	{
		int x=23,y=5;
		boolean b;
		System.out.println("\n x is: "+x+"\t y is: "+y);

		b=x>y;
		System.out.println("\n (x>y) is: "+b);

		b=x!=y;
		System.out.println("\n (x!=y) is: "+b);

		b=y<1;
		System.out.println("\n (y<1) is: "+b);

		b=x%10==0;
		System.out.println("\n (x%10==0) is: "+b);

		b=100%y==0;
		System.out.println("\n (100%y==0) is: "+b);
		
	}
}
output

E:\jprodyp>javac DemoRel.java

E:\jprodyp>java DemoRel

 x is: 23 y is: 5

 (x>y) is: true

 (x!=y) is: true

 (y<1) is: false

 (x%10==0) is: false

 (100%y==0) is: true

//-----------------------------------------------------------------------------------------------

	/// Logical Operator ( && || !): These operators are used to join two or more conditions

		when the conditions are joind by

		- && --> gives true only when both true otherwise false
		- || --> gives false only when both false otherwise true
		- !  --> gives
				!(true) ---> false
				!(false) ---> true
				

	suppose x=23	y=5;

		(x>y)&&(y<100)	----> true 
		(x>y)&&(y>100)	----> false

		(x>y)||(y>100)	----> true 
		(x<y)||(y>100)	----> false
	
		!(x!=y)	----> false 	
		!(y<1)	----> true


class DemoLogical
{
	public static void main(String []args)
	{
		int x=23,y=5;
		boolean b;
		System.out.println("\n x is: "+x+"\t y is: "+y);

		b=(x>y)&&(y<100);
		System.out.println("\n ((x>y)&&(y<100)) is: "+b);

		b=(x>y)&&(y>100);
		System.out.println("\n ((x>y)&&(y>100)) is: "+b);

		b=(x>y)||(y>100);
		System.out.println("\n ((x>y)||(y>100)) is: "+b);

		b=(x<y)||(y>100);
		System.out.println("\n ((x<y)||(y>100)) is: "+b);

		b=!(x!=y);
		System.out.println("\n (!(x!=y)) is: "+b);

		b=!(y<1);
		System.out.println("\n (!(y<1)) is: "+b);
		
	}
}

output: 
E:\jprodyp>javac DemoLogical.java

E:\jprodyp>java DemoLogical

 x is: 23        y is: 5

 ((x>y)&&(y<100)) is: true

 ((x>y)&&(y>100)) is: false

 ((x>y)||(y>100)) is: true

 ((x<y)||(y>100)) is: false

 (!(x!=y)) is: false

 (!(y<1)) is: true

///--------------------------------------------------------------------------------------
// Conditional operator or ternary operator or if-then-else operator(?:):

		This is the only operator which has decision abiity.
	
		syntax:

			<condition> ? <options>;

			<condition> ? <true_part> : <false_part> ;

	// WAP to find the max from 2 nos

import java.util.Scanner;
class DemoConditionalOperator
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int x=0,y=0;

		System.out.println("\n Enter any two nos: ");
		x=sc.nextInt();
		y=sc.nextInt();

		int z = (x>y) ? x : y ;
		System.out.println("\n Max no: "+z);
	}
}

output:
E:\jprodyp>javac DemoConditionalOperator.java

E:\jprodyp>java DemoConditionalOperator

 Enter any two nos:
45
78

 Max no: 78

E:\jprodyp>java DemoConditionalOperator

 Enter any two nos:
90
23

 Max no: 90

///------- Nesting of conditional operators


	// WAP to find the max from 3 nos

import java.util.Scanner;
class DemoConditionalOperator1
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int x=0,y=0,z=0;

		System.out.println("\n Enter any three nos: ");
		x=sc.nextInt();
		y=sc.nextInt();
		z=sc.nextInt();

		int max = (x>y) ? (x>z?x:z) : (y>z?y:z) ;
		System.out.println("\n Max no: "+max);
	}
}

output:
E:\jprodyp>javac DemoConditionalOperator1.java

E:\jprodyp>java DemoConditionalOperator1

 Enter any three  nos:
11
22
33

 Max no: 33

E:\jprodyp>java DemoConditionalOperator1

 Enter any three nos:
111
22
33

 Max no: 111

E:\jprodyp>java DemoConditionalOperator1

 Enter any three nos:
11
222
33

 Max no: 222

//-----------------------------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------------------------------------

   	/// Bitwise Operator: [ & | ^ >> << >>> ]
 
    These operators are used in the bit level operations.

        & ==> 1 & 1 -> 1 otherwise 0
        | ==> 0 | 0 -> 0 otherwise 1

              0^0
        ^ -->     ==> 0 otherwise 1
              1^1

    suppose x=10       y=12

        (0000 1010)     (0000 1100)

    (x&y)       (x|y)       (x^y)

    1010        1010        1010
   &1100       |1100       ^1100
  ========    ========     =======
    1000        1110        0110
    (8)          (14)        (6)


    x=10 (0000 1010)     y=12  (0000 1100)

     z=x<<2              z=y>>2
       (0010 1000)       (0000 0011)
       ==>40            ==> 3


class DemoBitwise
{
	public static void main(String []args)
	{
		int x=10,y=12;
		System.out.println("\n (x&y) is"+ (x&y) );

		System.out.println("\n (x|y) is"+ (x|y) );

		System.out.println("\n (x^y) is"+ (x^y) );

		System.out.println("\n (x<<2) is"+ (x<<2) );

		System.out.println("\n (y>>2) is"+ (y>>2) );
		
	}
}

//---------------------------------------------------------------------------------------------------------------------------------

	Associativity and precedence are fundamental concepts in programming that determine how operators 
	are evaluated in expressions.

	Precedence: Precedence refers to the order in which operators are evaluated when multiple operators 
		    are present in an expression. Operators with higher precedence are evaluated first.

	Associativity: Associativity defines the order in which operators with the same precedence are 
		       evaluated. There are two types of associativity:

			1. Left-to-Right (LTR): Operators are evaluated from left to right.
			2. Right-to-Left (RTL): Operators are evaluated from right to left.

Java Operator Precedence and Associativity Table:

Here's a summary of Java operators, their precedence, and associativity:

| Operator        		| Precedence 	| Associativity |
| ---             		| ---       	| ---          	|
| Postfix ([])    		| 1         	| LTR         	|
| Unary (+, -, !) 		| 2         	| RTL          	|
| Multiplicative (*, /, %) 	| 3 		| LTR          	|
| Additive (+, -) 		| 4         	| LTR          	|
| Shift (<<, >>, >>>) 		| 5 		| LTR       	|
| Relational (<, >, <=, >=) 	| 6 		| LTR          	|
| Equality (==, !=) 		| 7 		| LTR          	|
| Bitwise AND (&) 		| 8         	| LTR          	|
| Bitwise XOR (^) 		| 9         	| LTR          	|
| Bitwise OR (|)  		| 10        	| LTR          	|
| Logical AND (&&) 		| 11 		| LTR          	|
| Logical OR (||) 		| 12        	| LTR          	|
| Ternary (? :)  		| 13        	| RTL         	|
| Assignment (=, +=, -=, ...) 	| 14 		| RTL          	|

Examples:

1. Expression: 2 + 3 * 4

Precedence: Multiplication (*) has higher precedence than addition (+).
Evaluation: 2 + (3 * 4) = 2 + 12 = 14

1. Expression: 5 - 3 + 2

Precedence: Subtraction (-) and addition (+) have the same precedence.
Associativity: Left-to-Right.
Evaluation: (5 - 3) + 2 = 2 + 2 = 4

1. Expression: true && false || true

Precedence: Logical AND (&&) has higher precedence than Logical OR (||).
Associativity: Left-to-Right.
Evaluation: (true && false) || true = false || true = true

1. Expression: x = 5 + 3

Precedence: Addition (+) has higher precedence than assignment (=).
Associativity: Right-to-Left.
Evaluation: x = (5 + 3) = x = 8

//---------------------------------------------------------------------------------------------------------------------------------

// Control Statements in Java: 


				Control Statements
					|
			-------------------------------------
			|				    |
		   Conditional				Un-Conditional
			|					|
	------------------------------	        ---------------------------------
	|		|	    |		|	|		|	|
      Decision	      Loop	  case	       break   continue     lbl.break	return
	|		|	    |				    and 
	|- if()		|- for()   switch			    lbl. continue	
	|- if() else	|- while()
	|- nesting	|- do..while()
	|- ladder


//  Decision Conditional Control statment: 

	
	// Using if(): used to decide, execute the block of code or not. That block is mentioned in the program as

			syntax:
				if(<condi>)
				{
					-------------;
					-------------;
					block of code;
					-------------;
					-------------;
				}
				
	- Block of code will be executed only when the condition is true otherwise it will be skipped

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoIf
{
	public static void main(String []args)
	{
		InputStreamReader isr=new InputStreamReader(System.in);
		BufferedReader br=new BufferedReader(isr);

		int a=0;
		try
		{
			System.out.println("Enter the value of a: ");
			a=Integer.parseInt(br.readLine());
		}
		catch(Exception e){}		

		if(a%7==0)
		{
			System.out.println("Entered no is div by 7 ");
		}
		if(a%7!=0)
		{
			System.out.println("Entered no is not div by 7 ");
		}
	}
}

//-----------------------------------------------------------------------------------


	// Using if() else: It is used when you want to execute any one code block from two different blocks
	//		    according to condition.


		syntax:
			if(<condi>)
			{
				-----------------;
				---------------;
				----------------;
			}
			else 
			{
				-----------------;
				---------------;
				----------------;
			}

		when <condi> is  TRUE --> will execute the if() block only
				 FALSE -> will execute the else block only

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoIfElse
{
	public static void main(String []args)
	{
		InputStreamReader isr=new InputStreamReader(System.in);
		BufferedReader br=new BufferedReader(isr);

		int a=0;
		try
		{
			System.out.println("Enter the value of a: ");
			a=Integer.parseInt(br.readLine());
		}
		catch(Exception e){}		

		if(a%7==0)
		{
			System.out.println("Entered no is div by 7 ");
		}
		else
		{
			System.out.println("Entered no is not div by 7 ");
		}
	}
}


	// 	Using Nesting of if() else:

			Nesting refers to using one control statment in to same or another control statement


	some combinations:


		if()				if()				if()			if()
		{				{				{			{
			if()				if()			}				if()
			{				{			else				{
			}				}			{				}
		}					else				if()		}
							{				{		else
							}				}		{
						}				}				if()
														{
														}
													}


		
		if()					if()
		{					{
			if()					if()	
			{					{
			}					}
		}						else
		else						{
		{						}
			if()				}
			{				else
			}				{
			else					if()
			{					{
			}					}
		}						else
								{
								}
							}


class DemoIfElseNesting
{
	public static void main(String []args)
	{
		int a=Integer.parseInt(args[0]);
		int b=Integer.parseInt(args[1]);
		int c=Integer.parseInt(args[2]);

		if(a>b)
		{
			if(a>c)
			{
				System.out.println("\n a is max");
			}
			else
			{
				System.out.println("\n c is max");
			}
		}	
		else
		{
			if(b>c)
			{
				System.out.println("\n b is max");
			}
			else
			{
				System.out.println("\n c is max");
			}
		}
	}
}

//---------------------------------------------------------------------------------------------------------------------


	// Using if() else Ladder

	syntax:

		if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		[<else>]
		{
			---------;
			---------;
		}


	// Enter the co-ordinates of point in 2D system, and display the exact location of that point.


			       y axis
                                ^
                       II QD    |   I QD
                                |
                        -+      |   ++
                                |
                  <-------------|------------> x axis
                                |(0,0)
                                |
                        --      |   +-
                                |
                    III QD      V     IV QD



                There are 7 different possibilities.

import java.util.Scanner;
class DemoIfElseLadder
{
	public static void main(String []args)
	{
    		int x=0,y=0;
		Scanner sc=new Scanner(System.in);

    		System.out.println("\n Enter the x cord: ");
    		x=sc.nextInt();
    		System.out.println("\n Enter the y cord: ");
    		y=sc.nextInt();

    		if(x>0&&y>0)
    		{
        		System.out.println("\n Point present in I st qd");
    		}
    		else if(x<0&&y>0)
    		{
        		System.out.println("\n point present in II nd qd");
    		}
    		else if(x<0&&y<0)
    		{
        		System.out.println("\n Point is present in 3 rd qd");
    		}
    		else if(x>0&&y<0)
    		{
        		System.out.println("\n Point is present in 4 th qd");
    		}
    		else if(x!=0&&y==0)
    		{
        		System.out.println("\n Point is present on x axis");
    		}
    		else if(x==0&&y!=0)
    		{
        		System.out.println("\n Point is present on y axis");
    		}
    		else 
    		{
        		System.out.println("\n Point present at org");
    		}
	}
}


------------------------------------------------------------------------------------------------------------------------------------

		// Using the Loops in Java: Loops are used to avoid the continue repitition of code in the program.
					 There are three different loops in C.

				1. For() loop		2. While() loop		3. do..While() loop



	1. For() loop:

		syntax:	
				
			for( [<init>] ; <condi> ; [<inc/dec/stat/expr>] )					
			{									
				--------------;							   
				--------------;						
				--------------;							 
				--------------;							
				--------------;				
			}
		


import javax.swing.JOptionPane;
class DemoFor
{
	public static void main(String []args)
	{
		int no=Integer.parseInt(JOptionPane.showInputDialog("Enterany number:"));
	
		int t=0,tot=0;
		for(t=no;no!=0;no=no/10)
		{
			tot=tot+(no%10); 
		}
		System.out.println("\n Addition of all digits from "+t+" is "+tot");
	}
}

                ///-------------------------------------------------------------------------------------------------------------------------

	//  Using while loop: 

		Again the aim is same i.e. used to avoid the code rep.

		syntax:
			while(<cond>)
			{
				----------------;
				----------------;
				----------------;
				----------------;
				****************;
			}

			- It will execute the body of loop, till the condition is true.

			- <init> block is absent in while() but you have init. the iterator before starting of loop.

			- <inc/dec> block is absent, but you have to add atleast one statement which will make the <cond> false
			  after some iterations. otherwise it will attend the infinite looping


	/// WAP to display 1 to 15 nos using while loop

class DemoWhile
{
	public static void main(String []args)
	{
		int i;

		i=1;
		while(i<=15)
		{
			System.out.println(" "+i);
			i++;
		}
	}
}

//-------------------------------------------------------------------------------------------
	/// WAP to display list of odd nos from 1 to 50 using while loop.

class DemoWhile
{
	public static void main(String []args)
	{
		int i;

		i=1;
		while(i<=50)
		{
			if(i%2!=0)
			{
				System.out.println(" "+i);
			}
			i++;
		}
	}
}

//--------------------------------------------------------------------------


	// WAP to find the entered number is prime

import java.util.*;
class DemoWhile
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter any no: ");
		int no=sc.nextInt();
		int d=2;
		int flg=0;
		while(d<=(no/2))
		{
			if(no%d==0)
			{
				flg=1;
				break;
			}
			d++;
		}
		if(flg==0)
		{
			System.out.println("\n Entered no is prime ");
		}
		else
		{
			System.out.println("\n Entered no is not prime ");
		}
	}
}

//-----------------------------------------------------------------------------------------

	/// using  do while()

	syntax:

	do
	{
		----------;
		----------;
		----------;
		----------;
		----------;
	}while(<cond>);

// Display list of prime nos from given range 

import java.util.*;
class DemoWhile
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter the range starts from: ");
		int n1=sc.nextInt();
		System.out.println("\n Enter the range ends to: ");
		int n2=sc.nextInt();

		int d=2,flg=0;
		System.out.println("\n List of prime nos: ");
		for(no=n1;no<=n2;no++)
		{
			d=2;
			flg=0;
			while(d<=(no/2))
			{
				if(no%d==0)
				{
					flg=1;
					break;
				}
				d++;
			}
			if(flg==0)
				System.out.println("  "+no);
		}
	}

//------------------------------------------------------------------------------------------------------------------------------
	
	// WAP to display *

class StarPattern
{
	public static void main(String []args)
	{
		System.out.print("*")
	}
}


class StarPattern
{
	public static void main(String []args)
	{
		System.out.print("*");
	}
}

//-----------------------------------------------------

	WAP to print 
	*****

class StarPattern
{
	public static void main(String []args)
	{
		int j=0;
		for(j=0;j<5;j++)
		{
			System.out.print("*");
		}
	}
}



//-----------------------------------------------------

	WAP to print 
	*****
	*****
	*****
	*****
	*****

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				System.out.print("*");
			}
			System.out.print("\n");
		}
	}
}

//-----------------------------------------------------

	WAP to print 
           j
        01234 
	*****  i=0
	*   *  i=1
	*   *  i=2
	*   *  i=3
	*****  i=4

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<5;i++) // No of lines
		{
			for(j=0;j<5;j++) // no of cols
			{
				if(i==0 || i==4)
				{
					System.out.print("*");
				}
				else if(j==0 || j==4)
				{
					System.out.print("*");
				}
				else
				{
					System.out.print(" ");
				}
			}
			System.out.print("\n");
		}
	}
}

//-------------------------------------------------------------------------------------

	WAP to print 
	* 
	** 
	*** 
	**** 
	*****


class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;

		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				if(j<=i)
				{
					System.out.print("*");	
				}			
			}
			System.out.print("\n");
		}
	}
}



//-----------------------------------------------------

	WAP to print 
	*****
	**** 
	*** 
	** 
	* 

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;

		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				if(j<(5-i))
				{
					System.out.print("*");	
				}			
			}
			System.out.print("\n");
		}
	}
}

//---------------------------------------------------------------------

		*
	       ***
	      *****
	     *******
	    *********
           *********** 	

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<6;i++)
		{
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print("*");
				}
			}
			System.out.print("\n");
		}
	}
}

//-------------------------------------------------------------------------
 
     1
    222
   33333
  4444444
 555555555
66666666666

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<6;i++)
		{
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print(i+1);
				}
			}
			System.out.print("\n");
		}
	}
}

//---------------------------------------------------------------------------------


     A
    ABC
   ABCDE
  ABCDEFG
 ABCDEFGHI
ABCDEFGHIJK

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		char ch;
		for(i=0;i<6;i++)
		{
			ch='A';
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print(ch);
					ch++;
				}
			}
			System.out.print("\n");
		}
	}
}

//----------------------------------------------------------------------------------------

switch(): It is used in the menu driven programming.

	syntax:
		
		switch(<opt>)
		{
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			[<default>]:
				-----------;
				----------;
		}
		------------------;


	The switch case is used when there are more possibilities, and from which we have to 
	choose any one according to users choice.


import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println("1.add \n 2.sub \n 3.multi \n 4.div ");
		System.out.println("select your option: ");
		opt=sc.nextInt();

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case 1:
				ans=a+b;
				break;
			case 2:
				ans=a-b;
				break;
			case 3:
				ans=a*b;
				break;
			case 4:
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}

//--------------------------------------------------------------------------------------

	// Using the character as a option (both lcase and ucase for a single case)

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		char opt=0;
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println(" a.add \n b.sub \n c.multi \n d.div ");
		System.out.println("select your option: ");
		opt=sc.nextLine().charAt(0);

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case 'A':
			case 'a':
				ans=a+b;
				break;
			case 'B':
			case 'b':
				ans=a-b;
				break;
			case 'C':
			case 'c':
				ans=a*b;
				break;
			case 'D':
			case 'd':
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}
//-------------------------------------------------------------------------------------------

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int i=0, opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(i<3)
		{
			i++;
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div ");
			System.out.println("select your option: ");
			opt=sc.nextInt();

			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}
//-------------------------------------------------------------------------------------------

	// Using the switch within infinite loop (Termination using break)

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(true)
		{
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div \n 5.stop");
			System.out.println("select your option: ");
			opt=sc.nextInt();

			if(opt==5)
				break;

			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}



//-------------------------------------------------------------------------------------------

	// Using the switch within infinite loop (Termination using System.exit(0) )

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(true)
		{
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div \n 5.stop");
			System.out.println("select your option: ");
			opt=sc.nextInt();
			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				case 5:
					System.exit(0);
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}
//---------------------------------------------------------------------------------------

	// We can use string as a case constant.
import java.util.Scanner;
class DemoSwitchStr
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println("add \n sub \n multi \n div ");
		System.out.println("select your option: ");
		String opt=sc.nextLine();

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case "add":
				ans=a+b;
				break;
			case "sub":
				ans=a-b;
				break;
			case "multi":
				ans=a*b;
				break;
			case "div":
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}
//---------------------------------------------------------------------------------------

	Unconditional control statements: The control statement does not need any condition.

	NOTE: In Java goto is not present.

	- using the continue: It will keep the enclosing loop in the running condition without
			      considering the remaining body of loop.

class DemoContinue
{
	public static void main(String []args)
	{
		int i,j;

		for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(j>i)
				{
					continue;
				}
				System.out.print("*");
			}
			System.out.println();
		}
	}
}

//-----------------------------------------------------------------------

			  
		// Using Labelled Continue: It will keep loop in running condition, not only
					   enclosing, but outer loops using label(tag)

class DemoLabelledContinue
{
	public static void main(String []args)
	{
		int i,j;

		outer:for(i=0;i<10;i++)
		{			
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(i>5)
				{
					continue outer;
				}
				if(j>i)
				{
					continue;
				}
				System.out.print("*");
			}
			System.out.println();
		}
	}
}		


//-----------------------------------------------------------------------

// Using the break ans labelled break


class DemoBreak
{
	public static void main(String []args)
	{
		int i,j;

		for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(j>i)
				{
					break;
				}
				System.out.print(""+j);
			}
			System.out.println();
		}
	}
}

//----------------------------------------------------------------------------------------------

class DemoLabelledBreak
{
	public static void main(String []args)
	{
		int i,j;

		outer:for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(i>5)
				{
					break outer;
				}
				if(j>i)
				{
					break;
				}
				System.out.print(""+j);
			}
			System.out.println();
		}
	}
}	


//---------------------------------------------------------------------------------------

	// Using return: pass back the value from called method to calling function method.

//===============================================================================================
//===============================================================================================
//===============================================================================================
//===============================================================================================

	// Array in Java

	It is ordered collection of indexed elements having same data type which are
	conti. arranged in the memory.

	Decl. Syntax:
	
		<data_type> <arr_nm>[];		<data_type> []<arr_nm>;	

		e.g.
		int ar[];			int []ar;

	* Note 
		- In this decl, <element_count> is absent.
		- Above decl. creates the reference only.(same as pointer variable in C)

		In above both cases,

		ar
		 [  ]


	To allocate the memnory we need to use new keyword as..

		- Syntax
			<data_type> []<arr_nm> = new <data_type>[<size>];

			e.g.
				int []ar = new int[5];

			ar
			[   ] ----------------> [] [] [] [] []

	* Note that, Here in java array gains the dynamic memory space(like pointer in C), and
	  new keyword used to allocate the memory for it.

	// Init of array in java

	It is simple and same as we have seen in the C-C++, except [] does not contains the SIZE.

	e.g.
		int []x = {12,45,83,42,39};

		x            0    1    2    3    4 
		[ ] ------> [12] [45] [83] [42] [39]

	// WAP to init and display the array.

class InitArray
{
	public static void main(String []args)
	{
		int []x = {12,45,83,42,39,78};

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<6 ; i++)
		{
			System.out.print("   "+x[i]);
		}

		System.out.println("\n2. Array elements are: ");
		for(int i=0 ; i<x.length ; i++)
		{
			System.out.print("   "+x[i]);
		}

		// using for-each loop
		System.out.println("\n3. Array elements are: ");
		for(int val : x)
		{
			System.out.print("   "+val);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using BufferedReader and InputStreamReader

import java.io.*;
class ArrayIOBI
{
	public static void main(String []args) throws Exception
	{
		int []ar = new int[5];

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=Integer.parseInt(br.readLine());
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using Scanner

import java.util.Scanner;
class ArrayIOSI
{
	public static void main(String []args) 
	{
		int []ar = new int[5];

		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=sc.nextInt();
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using Commandline arguments

import java.util.Scanner;
class ArrayIOSI
{
	public static void main(String []args) 
	{
		int []ar = new int[5];

		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=sc.nextInt();
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - showInputDialog()

import javax.swing.JOptionPane;
class ArrayIOSIDialog
{
	public static void main(String []args) 
	{
		String data = JOptionPane.showInputDialog("Enter the Space seperated array of integers");
		System.out.println("Entered string: "+data);

		String []nums = data.split(" ");
		int []ar = new int[nums.length];		

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<nums.length ; i++)
		{
			ar[i]=Integer.parseInt(nums[i]);
		}

		System.out.println("\n1. Array elements are: ");
		for(int x : ar)
		{
			System.out.print("    "+x);
		}
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Dynamic Memory Allocation ( Using java array as a pointer)

import java.util.Scanner;
class DynamicAllocation
{
	public static void main(String []args)
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter the Element count: ");
		int cnt=sc.nextInt();
		int []a = new int[cnt];

		System.out.println("Enter the "+cnt+" Elements: ");
		for(int i=0;i<cnt;i++)
		{
			a[i]=sc.nextInt();
		}

		System.out.println("Elements: ");
		for(int t : a)
		{			
			System.out.println("  "+t);
		}
	}
}

//---------------------------------------------------------------------------------------------
	
	// Some Array Operations

	 - search
	 - sort
	 - sortrange
	 - insert
	 - delete
	 - reverse
	 - copy
	 - copyrange
	 - Reverse Copy
	 - merge
	 - split
	 - concate
	 - compare
	 - fill
	 - fillrange

//---------------------------------------------------------------------------------------------
	
	// Characher Array in Java:

		decl. syntax:
		
			char []<ar_nm>;
			e.g.
				char []ch;	// creates reference only
				char []ch={'H','e','l','l','o'}; // init of character array

	Note that in java input is not inform of characters, it is in form of String. so no any
	special way is there to input the character array. The class String used to represent the
	character coection in its equivalent object form, having one method names toCharArray(),
	used to convert string into character array.

	here character array and String are different

	*What is difference between character array and String?

import java.util.*;
class DemoCharArray
{
	public static void main(String []args)
	{
		char []ch;	// creates reference only
		char []ch1={'H','e','l','l','o'}; // init of character array

		Scanner sc = new Scanner(System.in);

		System.out.print("\n Enter the any string: ");
		String str=sc.nextLine();
		
		System.out.println("Entered String: "+str);

		ch=str.toCharArray();
		System.out.println("Converted String: ");

		for(char t : ch)
		{
			System.out.print(" "+t);
		}
	}
}

//--------------------------------------------------------------------------------------------------------

	Multi-dimentional Array: Collection of references to another arrays.

	<data_type> [][]<ar_ name>;	-->	int [][]ar;

						  ar
						   [ ]

	memory allocation:
						
	<data_type> [][]<ar_ name> = new <data_type>[rows][cols] ;

	case 1:	int [][]ar;

			ar
			[  ]

		
	case 2:	int [][]ar = new int[3][];

			ar
			[  ] -------->  [ ]
					[ ]
					[ ]


		
	case 3:	int [][]ar = new int[3][4];

			ar								ar
			[  ] -------->  [ ]------>[][][][]				[  ] ----> [][][][]
					[ ]------>[][][][]     Simply it is refered as 		   [][][][]
					[ ]------>[][][][]					   [][][][] 
							       ans can be accessed as ar[i][j]	

	// init. of 2D Array:

class Init2dArray
{
	public static void main(String []args)
	{
		int [][]ar = { {12,34,45,56}, {11,22,33,44}, {10,20,30,40} };

		System.out.println("Array elements are");
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<4;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
		System.out.println("\n Array elements are");
		for(int i=0;i<ar.length;i++)
		{
			for(int j=0;j<ar[i].length;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
	}
}
//----------------------------------------------------------------------------------------
	// input and display 2D Array of 3x4

import java.util.Scanner;
class Init2dArray
{
	public static void main(String []args)
	{
		int [][]ar = new int[3][4];
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the Array elements");
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<4;j++)
			{
				ar[i][j] = sc.nextInt();
			}
		}
		System.out.println("\n Array elements are");
		for(int i=0;i<ar.length;i++)
		{
			for(int j=0;j<ar[i].length;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
	}
}

///--------------------------------------------------------------------------------------

	// WAP to perform matrix multi.

import java.util.Scanner;
class Array2DMulti
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int [][]x=new int[3][3];
		int [][]y=new int[3][3];
		int [][]z=new int[3][3];
		int i,j,k;

		System.out.println("Enter array of 3x3: \n");
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				x[i][j]=sc.nextInt();
			}
			System.out.println();
		}

		System.out.println("Enter another array of 3x3: \n");
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				y[i][j]=sc.nextInt();
			}
			System.out.println();
		}

		// multi.
		for(i=0;i<x.length;i++)
		{
			for(j=0;j<x[i].length;j++)
			{
				z[i][j]=0;
				for(k=0;k<x[i].length;k++)
				{
					z[i][j]=z[i][j]+(x[i][k]*y[k][j]);
				}
			}
		}
		
		System.out.println("\n Array elements are: \n");
		for(i=0;i<x.length;i++)
		{
			for(j=0;j<x[i].length;j++)
			{
				System.out.print("  "+x[i][j]);
			}
			System.out.print("\t");
			for(j=0;j<y[i].length;j++)
			{
				System.out.print("  "+y[i][j]);
			}
			System.out.print("\t");
			for(j=0;j<z[i].length;j++)
			{
				System.out.print("  "+z[i][j]);
			}
			System.out.println();
		}
	}
}
///-----------------------------------------------------------------------------------------

 // Different operations of matrix:

	- Tranpose
	- unit matrix
	- upper triangular
	- lower triangular
	- diagonal
	
///-----------------------------------------------------------------------------------------

	// Variable size Array or Jagged Array

	suppose, you decl. an array as,

		int [][]x=new int[3][];

	then see the memory map is as shown below,

		x
		[ ] --------->  [ ]
				[ ]
				[ ]
			  These all 3 are the references, which will able to refer
			  dynamically created location of correct type, having any SIZE. 

	Means to store data, we need to allocate memory for each location. So we need to
	write it as,
	
		x[0]=new int[5];
		x[1]=new int[7];
		x[2]=new int[4];

		x
		[ ] --------->  [ ] -------> [][][][][]
				[ ] -------> [][][][][][][]
				[ ] -------> [][][][]

	So Note that, In Jagged array(variable size array) size(length) of every row
	may be different.

lets see the example.

	We have to create a 2D array to store runs of N player scored in M matches. where
	M may be different for each player.

import java.util.Scanner;
class DemoJagged
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the player count: ");
		int pcnt = sc.nextInt();
		int [][]data = new int[pcnt][];

		System.out.println("\n Enter the details of "+pcnt+" Players");
		for(int i=0;i<data.length;i++)
		{
			System.out.println("\n Enter the march count of player "+(i+1)+": ");
			int mcnt=sc.nextInt();
			data[i] = new int[mcnt];
			System.out.println("\n Enter the runs scored by player: ");
			for(int j=0;j<data[i].length;j++)
			{
				System.out.println("\n Match "+(j+1)+": ");
				data[i][j]=sc.nextInt();
			}
		}

		System.out.println("\n Score Board");

		int i=1;
		for(int []p : data)
		{
			System.out.print("\n Player "+(i++)+": ");
			for(int r : p)
			{
				System.out.print("  "+r);
			}
			System.out.println();
		}
	}
}

//-----------------------------------------------------------------------------------------------------------

	// POINTER - EXPLICIT POINTER IS NOT PRESENT IN JAVA, COZ ITS NEED ALREADY FULLFILLED BY ARRAY.
		     BUT AS OBJECT GAINS THE DYNAMIC MEMORY SPACE, IMPLICITELY IT IS HANDLED BY POINTER.
		     SO IT IS NOT PRESENT FOR AS A PROGRAMMER.


		- Why pointer is not present in java?


//===================================================================================================================

	// OOPs in Java

	What we have seen in C++,

	- Fundamantals - class, Object, Data Hiding, Encapsulation, Abstraction
	- Methods - Method Overloading,and Overriding
	- Static members (static variables, and static methods)
	- constructors and destructors
	- Inheritance: single, multi-level, Multiple, Hierarchical, Hybrid, virtual base class
	- Polymorphism - virtual function, pure virtual function, abstract class.
	- Operator Overloading


	// Fundamantals of Object Oriented Programming:

	  1. class: It is user defined data type, which allows you to define a type using data member(instance
		   variables) and member functions(Methods). It is just blueprint, which divides the members
		   in the private, protected, public and default(No keyword) visibility mofifiers.

		Syntax:
			class <class_name>
			{
				<visibility> <data_type> <var_nm>;
				<visibility> <return_type> <method_nm>();
				.......
			}

		e.g.
			class Demo
			{
				private int x;
				private double y;
				float z;
				public void input() {......}
				public void display() {......}
			}

		*Note: Remember that, visibility modifier must be used as a type qualifier for each member,
		       Absence of any keyword it will be considered as default.	and unlike C++, class does not 
		       ends with ;

	The visibility of class members in Java:	
	
	 - private:   member is only accessible within the same class.
	 - protected: member is accessible within its own package and by subclasses form same of different packages
	 - public: member is accessible from any class, both inside and outside the package.
	 - default / Package-Private (no modifier)class member is accessible only within its own package.
	
	2. Object: It is variable of class type or we can define it as it is standard implementation of class.
		or can be defined as, It is runtime entity - which encapsulates the data and code used to
		process that data.

		Syntax:
			<class_nm> <object_nm> = new <class_constructor>();

	*Note that, C++ style decl. creates the REFERENCE VARIABLE only(like a pointer variable).

	 i.e.
		Demo ob;		ob
					 [  ]

		Demo ob = new Demo();	
		
		 ob
		 [  ] -------> [ Memory allocated for object ] 


	** There is one unwritten rule, which recommanded for programmers and it is followed in
	   java internally while designing the library.

		- Method Names Should Be Verb-Phrase that describes what the method does.
		- Method names should start with a lowercase letter, and each subsequent word should start 
		  with an uppercase letter. This is called lower camel case.
		  e.g.
			calculateTotal(), sendEmail(), getUserDetails(), setAccountBalance()

		- Constants are typically written in uppercase letters with words separated by underscores (_), 
		  a style known as screaming snake case.
		  e.g.
			MAX_WIDTH, PI, DEFAULT_TIMEOUT

		- Class names should follow Upper Camel Case (also called Pascal Case), where the first letter 
		  of each word is capitalized and there are no spaces or underscores.
		  e.g.
			Person, EmployeeDetails, AccountManager
			

	3. data hiding: The private data of class is not accessible directly using the dot
			operator, means that data is get hided from outside world, which is
			known as data hiding.  
				
			The Data Hiding provides the security to data.

	4. Encapsulation: Wrapping up of data members and member functions together under
			  single unit is known as encapsulation. 

			Here in class the data member and member functions are encapsulated together.
				
	5. Abstraction: In simple words "Without knowing too much about it"
			It is an art of defining the new type(class) without including its background details.

			here in case of class and object, we dont think about the amount of
			memory as well as its representation in the memory(memory map), means
			we are abstract about it.

			The data types which supports abstraction known as Abstract Data Types (ADT)


//---------------------------------------------------------------------------------------------------------------------


	ob
	 [  ] -------> [------------------]

class Demo
{
	private int x;
	public void in(){
		x=100;
	}
	public void out(){
		System.out.println("x="+x);
	}
}
class MainClass
{
	public static void main(String []args)
	{
		Demo ob = new Demo();

		ob.in();
		ob.out();
	}
}

//-------------------------------------------------------------------------

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails()
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();

		System.out.println("Enter the height: ");
		hig=sc.nextDouble();
	}
	public void showPersonDetails()
	{
		System.out.println("Name: "+name+"\t Age: "+age+"\t Height: "+hig);
	}	
}

class MainClassExample
{
	public static void main(String []args)
	{
		Person p1 = new Person();
		p1.setPersonDetails();
		p1.showPersonDetails();

		Person p2 = new Person();
		p2.setPersonDetails();
		p2.showPersonDetails();
	}
}


//------------------------------------------------------------------------------
	
	// We can write same program as

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails(String nm, int ag, double h)
	{
		name=nm;
		age=ag;
		hig=h;
	}
	public void showPersonDetails()
	{
		System.out.println("Name: "+name+"\t Age: "+age+"\t Height: "+hig);
	}	
}

class MainClassExample1
{
	public static void main(String []args)
	{

		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		String name=sc.nextLine();
		System.out.println("Enter the age: ");
		int age=sc.nextInt();
		System.out.println("Enter the height: ");
		double hig=sc.nextDouble();

		Person p1 = new Person();
		p1.setPersonDetails(name, age, hig);
		
		System.out.println("Enter the name: ");
		name=sc.nextLine();
		System.out.println("Enter the age: ");
		age=sc.nextInt();
		System.out.println("Enter the height: ");
		hig=sc.nextDouble();

		Person p2 = new Person();
		p2.setPersonDetails(name, age, hig);


		p1.showPersonDetails();
		p2.showPersonDetails();
	}
}

//-----------------------------------------------------------------------------------------

	// Again can be written as

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails()
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();

		System.out.println("Enter the height: ");
		hig=sc.nextDouble();
	}
	public String getName()
	{
		return name;
	}
	public int getAge()
	{
		return age;
	}	
	public double getHeight()
	{
		return hig;
	}
}

class MainClassExample3
{
	public static void main(String []args)
	{
		Person p1=new Person();
		p1.setPersonDetails();

		Person p2=new Person();
		p2.setPersonDetails();

		System.out.println("Name: "+p1.getName()+"\t Age: "+p1.getAge()+"\t Height: "+p1.getHeight());
		System.out.println("Name: "+p2.getName()+"\t Age: "+p2.getAge()+"\t Height: "+p2.getHeight());
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Write a class Number to hold one int value and arrange some methods to process that int value.

import java.util.Scanner;
class Number
{
	private int no;
	public void setNumber(int n) 
	{
		no=n;
	}
	public int getNumber()
	{
		return no;
	}
	public int findReverse()
	{
		int n=no;

		int rev=0;
		while(n!=0)
		{
			rev = (rev*10) + (n%10);
			n = n/10;
		}
		return rev;
	}
	public char isPalindrome()
	{
		if(no==findReverse())
			return 'y';
		else
			return 'n';
	}
	public String isEvenOrOdd()
	{
		if(no%2==0)
			return "even";
		else
			return "odd";
	}
	public void isPrime()
	{	
		int d=2,flg=0;
		while(d<=(no/2))
		{
			if(no%d==0)
			{
				flg=1;
				break;
			}
			d++;
		}
		if(flg==0)
			System.out.println("Number is Prime");
		else
			System.out.println("Number is not Prime");
	}
	public int findMax(int h)
	{
		int ans = (no>h) ? no : h;
		return ans;
	}
}

class DemoNumber
{
	public static void main(String []args)
	{
		Number nob = new Number();

		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the Number: ");
		int t=sc.nextInt();

		nob.setNumber(t);

		System.out.println("\n Number is: "+nob.getNumber());

		int r = nob.findReverse();
		System.out.println("\n Reverse Number is: "+r);

		char ans=nob.isPalindrome();
		if(ans=='y')
			System.out.println("\n Number is Palindrome");
		else
			System.out.println("\n Number is Not Palindrome");

		System.out.println("\n Number is: "+nob.isEvenOrOdd());

		nob.isPrime();

		System.out.println("Enter the Number: ");
		int k=sc.nextInt();

		int max=nob.findMax(k);
		System.out.println("max Number: "+max);
	}
}

//------------------------------------------------------------------------------------------------------------		

	// Write a program to represent an array as a object and perform some operations on that array object.

import java.util.Scanner;
class MyArray
{
	private int []x;
	public void fill(int t)
	{
		x=new int[5];
		for(int i=0;i<x.length;i++)
		{
			x[i]=t;
		}
	}
	public void in()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("\n Enter element count: ");
		int k=sc.nextInt();
		x=new int[k];
		 
		System.out.print("Enter the "+k+" Elements: ");
		for(int i=0;i<k;i++)
		{
			x[i] = sc.nextInt();
		}
	}
	public void out()
	{
		System.out.print("\n Elements are: ");
		for(int val : x)
		{
			System.out.print("   "+val);
		}
	}
	public int search(int t)
	{
		for(int i=0;i<x.length;i++)
		{
			if(x[i]==t)
				return i;
		}
		return -1;
	}
}
class MyArrayExample
{
	public static void main(String[] args) 
	{
		MyArray ob = new MyArray();
		ob.fill(3);
		ob.out();

		ob.in();
		ob.out();

		Scanner sc = new Scanner(System.in);
		System.out.println("\n Enter the element to be searched: ");
		int n=sc.nextInt();
		int pos = ob.search(n);
		if(pos==-1)
			System.out.println("\n Number is not present in an array");
		else
			System.out.println("\n Number is present at "+pos+" position");
	}
}

//--------------------------------------------------------------------------------------

	// Create the class employee and just input and display the employee data.

import java.io.BufferedReader;
import java.io.InputStreamReader;
class Employee
{
	private int id;
	private String name;
	private double sal;
	public void inputInformation() throws Exception
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		System.out.println("Enter the Name: ");
		name=br.readLine();
		
		System.out.println("Enter the id: ");
		id=Integer.parseInt(br.readLine());

		System.out.println("Enter the salary: ");
		sal=Double.parseDouble(br.readLine());
	}
	public void showInformation()
	{
		System.out.println("Employee Name: "+name+"\t ID: "+id+"\t Salary: "+sal);
	}	
}

class MainClassEmployee
{
	public static void main(String []args) throws Exception
	{
		Employee e1=new Employee();

		e1.inputInformation();
		e1.showInformation();
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Creating Anonymous Object:

	Anonymous Object is an instance of class which can not be refered by any referance variable 
	when it is created. we are able to call the methods from same instance only once at the time
	of decl.
	It's often used for situations where you only need an object temporarily, without the need to store 
	or reuse it. You cannot refer to or modify the object later since it is not stored in a variable.

class DemoObj
{
	public void show()
	{
		System.out.println("\n In the DemoObj-show()");
	}
}

class MainDemoObj
{
	public static void main(String []args)
	{
		// Creating Anonymous Object
		new DemoObj().show();
		new DemoObj().show();
	}
}


//------------------------------------------------------------------------------------------------

	// Defining main() method in same class

class DemoMainSameClass
{
	private int x=1;
	private double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		System.out.println("\n x="+x);
		System.out.println("\n y="+y);

		System.out.println("\n main() end");
	}
}

---------- On Compile ---------------
Y:\jsmall>javac DemoMainSameClass.java
DemoMainSameClass.java:9: error: non-static variable x cannot be referenced from a static context
                System.out.println("\n x="+x);
                                           ^
DemoMainSameClass.java:10: error: non-static variable y cannot be referenced from a static context
                System.out.println("\n y="+y);
                                           ^


// Now i want to create multiple instances

	 Note that if you want to access the members of class where main() is defined then also you need to 
  	 create the object of same class and access the methods.
	 

class DemoMainSameClass
{
	private int x=1;
	private double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		DemoMainSameClass ob1 = new DemoMainSameClass();
		System.out.println("\n ob1.x="+ob1.x);
		System.out.println("\n ob1.y="+ob1.y);
		
		DemoMainSameClass ob2 = new DemoMainSameClass();
		System.out.println("\n ob2.x="+ob2.x);
		System.out.println("\n ob2.y="+ob2.y);

		System.out.println("\n main() end");
	}
}


// another ways is decl thode variables as static

class DemoMainSameClass
{
	private static int x=1;
	private static double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		System.out.println("\n x="+x);
		System.out.println("\n y="+y);

		System.out.println("\n main() end");
	}
}

//-----------------------------------------------------------------------------

	// Defining methods within main() class

class DemoMainMethod
{
	public void sampleMethod()
	{
		System.out.println("\n In sampleMethod()");
	}
	public static void main(String []args)
	{
		System.out.println("\n main() starts");
		sampleMethod();
		System.out.println("\n main() end");
	}
}

 ------------- On Compile -----------------

Y:\jsmall>javac DemoMainMethod.java
DemoMainMethod.java:10: error: non-static method sampleMethod() cannot be referenced from a static context
                sampleMethod();
                ^
1 error

	Solution: 
	- Decl. sampleMethod() method as static	OR
	- Create an object of class DemoMainMethod and call sampleMethod()


//---------------------------------------------------------------------------------------------------

	// WAP to input and display the data of two students

import java.util.Scanner;
class Student
{
	private int id;
	private double per;

	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the student ID: ");
		id=sc.nextInt();

		System.out.println("Enter the Percentage: ");
		per=sc.nextDouble();
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Student s1=new Student();
		s1.in();
		s1.out();

		Student s2=new Student();
		s2.in();
		s2.out();
	}
}	

//--------------------------------------------------------------

	// Or can be passed from the main()

import java.util.Scanner;
class Student
{
	private int id;
	private double per;

	public void in(int t1, double t2)
	{
		id=t1;
		per=t2;
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the student ID: ");
		int sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		double sper=sc.nextDouble();

		Student s1=new Student();
		s1.in(sid,sper);
		s1.out();

		//-----------------------------------------------

		System.out.println("Enter the student ID: ");
		sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		sper=sc.nextDouble();

		Student s2=new Student();
		s2.in(sid,sper);
		s2.out();
	}
}	

//------------------------------------------------------------------------------------------------------

	// Method overloading with class

	Method overloading in Java allows you to define multiple methods with the same name but different parameter
	lists. It increases the flexibility, readability, and maintainability of your code. Just remember that
	overloading depends on differences in the method signatures (the method name and parameters), not the 
	return type, and visibility.

import java.util.Scanner;
class Student
{
	private int id;
	private double per;
	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the student ID: ");
		id=sc.nextInt();

		System.out.println("Enter the Percentage: ");
		per=sc.nextDouble();
	}
	public void in(int t1, double t2)
	{
		id=t1;
		per=t2;
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		
		Student s1=new Student();
		s1.in();
		s1.out();
		//-----------------------------------------------

		System.out.println("Enter the student ID: ");
		sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		sper=sc.nextDouble();
		Student s2=new Student();
		s2.in(sid,sper);
		s2.out();
	}
}	


	In above program, there are two different copies of in() method i.e.

		public void in()
		public void in(int t1, double t2)

	as a class contains two copies of function having same name and differ in terms of
	signature, it is known as "Method Overloading"

//---------------------------------------------------------------------------------------------------------

	// Lets discuss the class by value and class by refernce.

	- We know that, In C++, variable are passed by value bydefault. If you want to pass them
	  byreference then pointer is used.

class SwapDemo
{
	public static void swap(int a, int b)
	{
		int tmp;
		tmp=a;
		a=b;
		b=tmp;
	}
	public static void main(String[]args)
	{
		int x=10, y=20;
		System.out.println("\n Before Interchange x="+x+"\t y="+y);
		swap(x,y);
		System.out.println("\n After Interchange x="+x+"\t y="+y);
	}
}

 ----- Output -------
Y:\jsmall>javac SwapDemo.java
Y:\jsmall>java SwapDemo
 Before Interchange x=10   y=20
 After Interchange x=10  y=20

	Means java variables are passed by value bydefault. Then how to pass the byreference coz, in c++,
	pointer is used, here in java pointer is absent.

	solution is that, pass the values in form of object, coz object bydefault passesd by reference.
	for that,
	 - create custom class to reperent the int value in its equivalent object from. OR
	 - User wrapper classes.


	// Lets first confirm that, Object is bydefault passed by reference.

class Int
{
	private int data;
	public void setData(int data)
	{
		this.data=data;
	}
	public int getData()
	{
		return data;
	}
}
class ObjByRefConfirm
{
	public static void sample(Int t)
	{
		t.setData(t.getData()+100);
	}
	public static void main(String[]args)
	{
		int x=10;
		Int obx = new Int();
		obx.setData(x);

		System.out.println("Before - x="+obx.getData());
		sample(obx);
		System.out.println("After - x="+obx.getData());		
	}
}

 --- Output ----

Y:\jsmall>javac ObjByRefConfirm.java

Y:\jsmall>java ObjByRefConfirm
Before - x=10
After - x=110

	It is confirmation, that Object passed by reference.
//--------------------------------------------------------------------------------------------

	// Use same class for swapping (Using custom class)

class Int
{
	private int data;
	public void setData(int data)
	{
		this.data=data;
	}
	public int getData()
	{
		return data;
	}
	public String toString()
	{
		return ""+data;
	}
}
class SwapDemoUsingObj
{
	public static void swap(Int oba, Int obb)
	{
		int tmp;
		tmp=oba.getData();
		oba.setData(obb.getData());
		obb.setData(tmp);
	}
	public static void main(String[]args)
	{
		int x=10, y=20;

		Int obx = new Int();
		obx.setData(x);

		Int oby = new Int();
		oby.setData(y);

		System.out.println("\n Before Interchange x="+obx+"\t y="+oby);
		swap(obx,oby);
		System.out.println("\n After Interchange x="+obx+"\t y="+oby);
	}
}

 ----- output -----

 Before Interchange x=10         y=20

 After Interchange x=20  y=10
Press any key to continue . . .

//----------------------

	Another way to represent the data in its equivalent object from is to use Wrapper classes

class SwapDemoUsingObjUsingWrapper
{
	public static void swap(Integer  oba, Integer obb)
	{
		int tmp;
		tmp=oba;
		oba=obb;
		obb=tmp;
	}
	public static void main(String[]args)
	{
		int x=10, y=20;

		Integer obx = x;
		Integer oby = y;

		System.out.println("\n Before Interchange x="+obx+"\t y="+oby);
		swap(obx,oby);
		System.out.println("\n After Interchange x="+obx+"\t y="+oby);
	}
}


The output will not gives the swaped values coz Integer object is immutable. You need mutable object
or use the array. 

	The values of x and y are not swapping because:

	- Java passes object references by value.
	- The swap method only modifies the local copies of the references.
	- Integer objects are immutable, so their values cannot be changed directly.

	NOTE:
	- When you pass a primitive type (e.g., int, float, char) to a method, a copy of the value is 
	  passed. Changes made to the parameter inside the method do not affect the original variable.

	- When you pass an object to a method, a copy of the reference to the object is passed. This 
	  means that the method receives a reference to the same object, but the reference itself is a copy.
	
	- Changes made to the object through the reference inside the method will affect the original object. 
	  However, changes made to the reference itself (e.g., assigning it to a new object) will not affect 
	  the original reference.


	// Using the array to swap the value

public class SwapDemoUsingArray {
    public static void swap(int[] arr) {
        int tmp = arr[0];
        arr[0] = arr[1];
        arr[1] = tmp;
    }

    public static void main(String[] args) {
        int x = 10, y = 20;

        int[] arr = {x, y};

        System.out.println("\n Before Interchange x=" + arr[0] + "\t y=" + arr[1]);
        swap(arr);
        System.out.println("\n After Interchange x=" + arr[0] + "\t y=" + arr[1]);
    }
}


//------------------------------------

	What is a POJO Class in java?
	 - A POJO (Plain Old Java Object) is a simple object in Java that doesn't adhere to any special restriction 
	  other than those forced by the Java Language Specification and does not require any classpath. 
	  Here are the key points that define a POJO class:

	- No Implements: It does not implement any special interfaces such as Serializable, Externalizable, etc.
	- No Extends: It does not extend prespecified classes which may force it to behave in a certain way.
	- Simple Fields: Fields should be private to achieve encapsulation. Fields can be accessed directly 
	  via getters and setters.
	- Zero-arg Constructor: Often includes a no-argument constructor.

public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Employee{name='" + name + "', Age=" + age + "}";
    }
}

//-----------------------------------------------------------------------------------------------------------

	// Constructors in Java Classes: 

	 A constructor in Java is a special method used to initialize objects when they are created. It has the same 
	 name as the class and does not have a return type (not even void). Constructors are automatically called when 
	 an object of the class is instantiated.You can define multiple constructors with different parameters 
	 (constructor overloading).

	Types of Constructors:
	  - Default Constructor (No-Argument Constructor):
	  - Parameterized Constructor:
	  - Copy Constructor (Not built-in like in C++):


	// Default Constructor (No-Argument Constructor): It is constructor without arguments. Can init.
	   instance variables using input or using literals. In absence of constructor in class, the default 
	   constructor with the empty body will be provided by the compiler itself. 

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		x=10;
		y=23.45;
		System.out.println("\n In default constructor of Sample class");
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainDefaultex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();
	}
}


//--------

	// Default constructor can take the values from keyboard

	
class Sample
{
	private int x;
	private double y;
	public Sample()
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainDefaultex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();
	}
}

//--------------------------------------------------------------------------------------------------------

	- Parameterized Constructor: It is the constructors with arguments.

	 * If we define any constructor in class then it is our responsibility to define default constructor,
	   in such case compiler will not provide the default constructor with empty body. In absence of default 
	   constructor the error will be generated only when compiler will need it for allocation.
	 * A call may contain multiple constructors, but only one executed at a time.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In Default constructor of Sample class");
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor of Sample class");
		x=a1;
		y=a2;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class Mainparaex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12,89.45);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();
	}
}

//---------------------------------------------------------------------------------------------

	Constructor Overloading: Defining multiple constructors in a same class. Only take case that
	there must not be two or more construcctors with same signature.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public Sample(int a) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-1 of Sample class");
		x=a;
		y=a;
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-2 of Sample class");
		x=a1;
		y=a2;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainConOverloading
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();
	}
}

//-----------------------------------------------------------------------------------------------

	Copy Constructor: A constructor used to create a new object by copying an existing object's data.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public Sample(int a) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-1 of Sample class");
		x=a;
		y=a;
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-2 of Sample class");
		x=a1;
		y=a2;
	}
	public Sample(Sample t) // copy constructor
	{
		System.out.println("\n In copy constructor of Sample class");
		x=t.x;
		y=t.y;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainConCopy
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();

		Sample ob4 = new Sample(ob3);
		ob4.showData();
	}
}

//--------------------------------------------------------------------------------------------------------

	Constructor chaining: 
	
	Constructor chaining in Java refers to the process of calling one constructor 
	from another within the same class or in a superclass. It allows you to reuse code by having one
	constructor invoke another, reducing redundancy and ensuring consistent initialization of an object.

	- Within the Same Class (Using this()):
		A constructor calls another constructor of the same class.

	- From a Superclass (Using super()):
		A subclass constructor calls a constructor of its superclass.
	
public class DemoChainCon {
    private String name;
    private int age;
    private String grade;

    // Default constructor
    public DemoChainCon() {
        this("Unknown", 0, "Not Assigned");  // Calls the parameterized constructor
		System.out.println("\n Default constructor of DemoChainCon class");
    }

    // Constructor with two parameters
    public DemoChainCon(String name, int age) {
        this(name, age, "Not Assigned");  // Calls the constructor with three parameters
		System.out.println("\n Para(args-2) constructor of DemoChainCon class");
    }

    // Parameterized constructor with three parameters
    public DemoChainCon(String name, int age, String grade) {
		System.out.println("\n Para(args-3) constructor of DemoChainCon class");
        this.name = name;
        this.age = age;
        this.grade = grade;
    }

    public void display() {
        System.out.println("Name: " + name + ", Age: " + age + ", Grade: " + grade);
    }

    public static void main(String[] args) {
        DemoChainCon s1 = new DemoChainCon();  // Calls default constructor
        DemoChainCon s2 = new DemoChainCon("Amol", 20);  // Calls two-parameter constructor
        DemoChainCon s3 = new DemoChainCon("Baba", 22, "A");  // Calls three-parameter constructor

        s1.display();  // Output: Name: Unknown, Age: 0, Grade: Not Assigned
        s2.display();  // Output: Name: Alice, Age: 20, Grade: Not Assigned
        s3.display();  // Output: Name: Bob, Age: 22, Grade: A
    }
}

	** Note: this() must be first statement in constructor while chaining.


//--------------------------------------

	Constructor Chaining Between Superclass and Subclass:
		You use the keyword super() to call the constructor of the superclass.

class A
{
	int a;
	public A()
	{
		System.out.println("\n In default constructor of A class");
		a=10;
	}
	public A(int a)
	{		
		System.out.println("\n In para constructor of A class");
		this.a=a;
	}
	public void showa()
	{
		System.out.println("\n a="+a);
	}
}
class B extends A
{
	int b;
	public B()
	{
		System.out.println("\n In default constructor of B class");
		b=20;
	}
	public B(int a, int b)
	{		
		super(a);
		System.out.println("\n In para constructor of B class");
		this.b=b;
	}
	public void show()
	{
		showa();
		System.out.println("\n b="+b);
	}
}
class ChainConSuper
{
	public static void main(String []args)
	{
		B ob1 = new B();
		ob1.show();

		B ob2 = new B(100,200);
		ob2.show();
	}
}

//---------------------------------------------------------------------------------------------------------

	// Private Constructor

	A private constructor in Java is a constructor that is declared with the private access modifier. Unlike public 
	or protected constructors, it restricts object creation from outside the class. This means instances of the 	
	class cannot be created directly from outside the class.

	public class Example {
    		private Example() {
        		// Initialization code
    		}
	}


	Why Use a Private Constructor?
	Private constructors are used to achieve specific design patterns and behaviors in Java. 
	Some common use cases include:

	1. Singleton Design Pattern: A singleton ensures that only one instance of a class is created during the 
	   application's lifecycle. The class provides a global access point to this instance.

class Singleton {

    // Static variable to hold the single instance
    private static Singleton instance;
    private static String msg;

    // Private constructor to prevent instantiation
    private Singleton() {
        System.out.println("Singleton instance created.");
    }

    // Public method to provide access to the instance
    public static Singleton getInstance(String str) {
        if (instance == null) {
			msg=str;
            instance = new Singleton();
        }
        return instance;
    }

    public void displayMessage() {
        System.out.println("Hello from Singleton! "+msg);
    }
}
class DemoSingleton
{		
    public static void main(String[] args) {
        Singleton obj1 = Singleton.getInstance("One");  // Creates the instance
        Singleton obj2 = Singleton.getInstance("Two");  // Returns the same instance

        obj1.displayMessage();  // Output: Hello from Singleton!One
        obj2.displayMessage();  // Output: Hello from Singleton!One
        System.out.println(obj1 == obj2);  // Output: true (same instance)
    }
}

 //--------------------------------

	2. Factory Method Pattern: A factory method uses a private constructor to control the 
	   creation of objects and delegates object creation to static methods.

class Product {
    
	private String name;

    // Private constructor
    private Product(String name) {
        this.name = name;
    }

    // Static factory method
    public static Product createProduct(String type) {
        if (type.equalsIgnoreCase("Laptop")) {
            return new Product("Laptop");
        } else if (type.equalsIgnoreCase("Phone")) {
            return new Product("Phone");
        } else {
            return new Product("Unknown Product");
        }
    }

    public void display() {
        System.out.println("Product: " + name);
    }
}

class DemoFactoryMethodPattern
{
    public static void main(String[] args) {
        Product p1 = Product.createProduct("Laptop");
        Product p2 = Product.createProduct("Tablet");

        p1.display();  // Output: Product: Laptop
        p2.display();  // Output: Product: Unknown Product
    }
}

//-------------------------------------------------------------------------------

	3. Preventing Instantiation in Utility Classes:

	Utility classes contain static methods and constants. Since they don’t 
	need instances, a private constructor prevents instantiation.

class UtilityClass {

    // Private constructor to prevent instantiation
    private UtilityClass() {
        throw new UnsupportedOperationException("Cannot instantiate UtilityClass.");
    }

    // Static utility method
    public static int add(int a, int b) {
        return a + b;
    }
}
class DemoUtilityClasses
{
	
    public static void main(String[] args) {
        int result = UtilityClass.add(5, 10);
        System.out.println("Result: " + result);  // Output: Result: 15

        //  UtilityClass obj = new UtilityClass();  // Compilation error if uncommented
    }
}

//-------------------------------------------------------------------------------------------------------------------------------

	// Is Static Constructors Present in java? 

	No, the concept of "static constructors" does not exist in java. However, Java provides a way to 
	achieve similar functionality using static blocks. Static blocks are used to initialize static data 
	members of a class and are executed when the class is loaded.

	Static Blocks in Java
	Static blocks are used to initialize static fields and perform any necessary setup when the class is 
	loaded. They are executed only once, when the class is first loaded into memory.

	class <>
	{
		static {
    			// Initialization code
		}
	}

	As we need constructor in class to initilize the object, and it will be required for each object, means
	it must be at object level. as static meakes it class level it is not allowed in java.
	

//-----------------------------------------------------------------------------------------------------------


	// Default arguments in methods:  it is not allowed to write default arguments in java methods. Unlike some 
	   other programming languages (such as C++ or Python), Java does not support default arguments for methods. 
	   This means that when you define a method in Java, you must specify all the parameters explicitly, and 
	   the caller must provide values for all the parameters.

	Why Java Does Not Support Default Arguments?

	- Java aims to keep the language simple and readable. Default arguments can sometimes make the code harder 
	  to understand, especially when methods are overloaded or when the default values are not obvious.
	- Java emphasizes consistency in its syntax and semantics. Introducing default arguments could lead to 
	  inconsistencies and potential ambiguities in method overloading and method resolution.
	- Java has a strong emphasis on backward compatibility. Introducing default arguments could break existing 
	  code or introduce subtle bugs in legacy systems.

	Alternatives to Default Arguments: 

	While Java does not support default arguments, there are several alternatives to achieve similar functionality:

	1. Method Overloading: You can define multiple versions of a method with different parameter lists. This allows 
	you to provide default values by calling the appropriate overloaded method.

public class Example {
    public void display(String message) {
        System.out.println(message);
    }

    public void display() {
        display("Default message");
    }

    public static void main(String[] args) {
        Example example = new Example();
        example.display(); // Output: Default message
        example.display("Custom message"); // Output: Custom message
    }
}

//--------------

	2. Builder Pattern: The Builder pattern is a design pattern that allows you to construct complex objects 
	   step by step. It provides a flexible way to set default values and build objects with optional parameters.


class Product {
    private String name;
    private double price;
    private String category;

    private Product(Builder builder) {
        this.name = builder.name;
        this.price = builder.price;
        this.category = builder.category;
    }

    public static class Builder {
        private String name = "Default Name";
        private double price = 0.0;
        private String category = "Default Category";

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setPrice(double price) {
            this.price = price;
            return this;
        }

        public Builder setCategory(String category) {
            this.category = category;
            return this;
        }

        public Product build() {
            return new Product(this);
        }
    }

    @Override
    public String toString() {
        return "Product [name=" + name + ", price=" + price + ", category=" + category + "]";
    }
}

public class MainBuilderPattern {
    public static void main(String[] args) {
        Product product1 = new Product.Builder().build();
        Product product2 = new Product.Builder().setName("Laptop").setPrice(999.99).build();

        System.out.println(product1);
        System.out.println(product2);
    }
}

//----------------------------
	3. Varargs: Varargs (variable-length arguments) allow you to pass a variable number of 
	   arguments to a method. This can be used to simulate default arguments by checking the 
	   length of the varargs array.

public class VarargsExample {
    public void display(String... messages) {
        if (messages.length == 0) {
            System.out.println("Default message");
        } else {
            for (String message : messages) {
                System.out.println(message);
            }
        }
    }

    public static void main(String[] args) {
        VarargsExample example = new VarargsExample();
        example.display(); // Output: Default message
        example.display("Custom message 1", "Custom message 2"); // Output: Custom message 1 Custom message 2
        example.display("One", "Two", "Three"); 
    }
}


//-----------------------------------------------------------------------------------------------------------

	// Is friend function allowed in Java like C++?

		No, the concept of "friend functions" as found in C++ does not exist in Java. Friend functions 
		in C++ allow a function to access the private and protected members of a class, even if the function 
		is not a member of that class. This is not possible in Java due to its strict access control and 
		encapsulation principles.

	Alternatives to Friend Functions in Java
	While Java does not support friend functions, there are several design patterns and techniques that can achieve 
	similar functionality:

	- Package-Private Access:
		By placing classes in the same package, you can allow them to access each other's package-private 
		(default) members. This provides a level of encapsulation while still allowing controlled access.

	- Nested Classes:
		Nested classes (inner classes) can access the private members of their enclosing class. This allows 
		for controlled access to private members.

	- Getter and Setter Methods:
		Provide public getter and setter methods to access and modify private fields. This is a common 
		practice in Java to control access to private members.
	
	- Interfaces:
		Define interfaces that provide access to specific methods or fields. This allows controlled access 
		to private members through the interface.


//-----------------------------------------------------------------------------------------------------------------

	Garbage Collector (GC): 

	 In Java, the Garbage Collector (GC) is a part of the Java Virtual Machine (JVM) responsible for 
	 managing memory. It automatically reclaims memory that is no longer in use, ensuring efficient memory 
	 utilization and preventing memory leaks.

	 In another words, It will release the derefernced locations, the derefernced locations are those allocated
	 locations, which are not refered by any reference variables.


			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][/][][][][][][][/][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][/][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]


	Demo ref=new Demo();
	Demo dob=new Demo();
	

		ref
 		 [ ] ------------> [][][][][][][][][][][][]


		dob
 		 [ ] ------------> [][][][][][][][][][][][]



	ref=dob;

		ref		  Dereferenced Location
 		 [ ]		 [][][][][][][][][][][][]
		  |_________________
		 	           |
	      dob                  V
 		 [ ] ------------> [][][][][][][][][][][][]


 
	Garbage collector is a member which is used to free the dereferenced location. It will
	perform same task when it will get enough idle time of processor.

	If you want to utilize the resources hold by that object just before release of that location
	(done with the help of destructor in C++), the java provides the following method.

	protected void finalize()
	{
		--------------;
		-------------;
	}


	If you want to request early release then call System.gc();
import java.util.Scanner;
class Employee
{
	private String nm;
	private int eid;
	private double sal;

	Employee()
	{
		nm="";
		eid=-1;
		sal=-1.0;
	}	
	Employee(String nm,int eid,double sal)
	{
		this.nm=nm;
		this.eid=eid;
		this.sal=sal;
	}
	public void display()
	{
		System.out.println("Name: "+nm);
		System.out.println("Employee ID: "+eid);
		System.out.println("salary: "+sal);
	}
	protected void finalize()
	{
		System.out.println(" In finalize() method");
	}
}

class EmployeeMain
{ 
	public static void main(String []args) throws InterruptedException
	{
		{
			Employee eob=new Employee("Abhi",11,50000);
			eob.display();
			eob=null;
		}
		System.gc();
		Thread.sleep(5000);
		System.out.println(" End of program: ");
	}
}

	The Garbage Collector (GC) in programming, particularly in languages like Java, is a mechanism for automatic memory 
	management. Its primary purpose is to reclaim memory occupied by objects that are no longer in use by a program, 
	preventing memory leaks and ensuring efficient utilization of system memory.

	Key Points About Garbage Collection

	Automatic Memory Management:
	In languages like Java, developers do not manually allocate or deallocate memory for objects. The GC handles the cleanup 
	of unused objects, freeing the programmer from this responsibility.

	Managed Heap Memory:
	Objects in Java are created in the heap memory. The GC identifies objects that are no longer reachable and removes them 
	to free up space for new objects.

	Reachability:
	An object is considered unreachable if it is no longer accessible through any reference in the program. If no thread can 
	access an object, it becomes eligible for garbage collection.

	Garbage Collection Process:
	Mark: The GC identifies all objects currently in use or "reachable."
	Sweep: The GC removes objects that are no longer reachable, freeing up memory.
	Compact (optional): In some implementations, after sweeping, the memory is compacted to reduce fragmentation and 
	optimize performance.

	Generational Garbage Collection:
	Many modern GCs, including those in Java, use a generational model, dividing the heap into:
	Young Generation: Newly created objects. Most objects are short-lived and are quickly collected.
	Old Generation (Tenured): Objects that survive multiple GC cycles in the young generation are moved here.
	Permanent Generation (Metaspace): Stores metadata about classes and methods. (In Java 8 and later, this is replaced by 
	Metaspace.)

	Types of Garbage Collectors in Java:
	Serial Garbage Collector: A simple GC for single-threaded applications.
	Parallel Garbage Collector: Uses multiple threads for GC tasks, suited for multi-threaded environments.
	Concurrent Mark-Sweep (CMS) Collector: Reduces pause times by running GC concurrently with the application threads.
	G1 Garbage Collector: Aims to achieve predictable pause times and improved performance by dividing the heap into regions.
	ZGC: Designed for very low-latency applications, with extremely short pauses.
	Shenandoah GC: Another low-latency garbage collector.

	GC Triggers:
	The JVM triggers garbage collection when it detects that memory is running low or at certain points in the program 
	execution. It can also be triggered explicitly using the method:

	System.gc();

	However, calling this method does not guarantee immediate garbage collection; it's just a suggestion to the JVM.

	Advantages of Garbage Collection:
	Prevents memory leaks.
	Simplifies memory management for developers.
	Helps in managing complex object lifecycles automatically.

	Disadvantages of Garbage Collection:
	Performance Overhead: GC can cause pauses in program execution (known as "stop-the-world" events).
	Less control over memory management compared to manual memory management (e.g., in C/C++).

	//-----------------------------------------

	Generational Garbage Collection is a strategy used in modern garbage collection systems (including Java's JVM) to 
	optimize memory management. It is based on the observation that most objects have a short lifespan, while a smaller 
	number live longer. This strategy divides the heap memory into generations, where objects are grouped by their age, 
	to improve performance and minimize overhead.

	Generations in the Heap Memory
	The heap is divided into three main regions:

	Young Generation:
	This is where all newly created objects are allocated.
	It is further divided into:
	Eden Space: All new objects are initially allocated here.
	Survivor Spaces (S0 and S1): After the first garbage collection, objects that survive are moved here.
	Most objects in the Young Generation are short-lived and are quickly garbage collected. This process is called a Minor GC.
	
	Old Generation (Tenured Generation):
	Objects that survive multiple Minor GCs are promoted to the Old Generation.
	These objects tend to have a longer lifespan.
	Garbage collection in this space is called a Major GC or Full GC.
	Major GC is more time-consuming compared to Minor GC, as it operates on a larger memory space.

	Permanent Generation (or Metaspace):
	In older versions of Java (up to Java 7), the Permanent Generation was used to store metadata about classes, 
	methods, and other JVM structures.
	In Java 8 and later, this was replaced by Metaspace, which is not part of the heap and is allocated in native memory.

		+-------------------+-------------------+-------------------+
		|   Young Gen       |    Old Gen        |   (Metaspace)     |
		|                   |                   |                   |
		|   +-----------+   |                   |                   |
		|   |   Eden    |   |                   |                   |
		|   +-----------+   |                   |                   |
		|   | Survivor0 |   |                   |                   |
		|   +-----------+   |                   |                   |
		|   | Survivor1 |   |                   |                   |
		+-------------------+-------------------+-------------------+

//-----------------------------------------------------------------------------------------------------------------

	// Using the static keyword in java.


	// Static variable(static data member): In Java, a static data member (also known as a static variable) is a 				variable that is shared among all instances of a class. It is declared with the static keyword, meaning 
		that it belongs to the class itself rather than to any specific instance of the class. As a result,
		static data members have the same value across all instances of the class.

	 Characteristics of Static Data Members:

	- Shared Among Instances: All objects of the class share the same static variable, which means that if one 
	  object modifies the static variable, the change is reflected across all objects.

	- Class Level: A static variable is associated with the class rather than any instance of the class. 
	  It can be accessed directly using the class name without creating an object of the class.

	- Memory Allocation: Static variables are allocated memory only once, when the class is loaded into memory, 
	  and they retain their values throughout the execution of the program.


	// static method (static member function):

	A static member function (also known as a static method) in Java is a method that belongs to the class itself,
	rather than to instances (objects) of the class. It can be called on the class directly, without needing to 
	create an object of that class. Static methods are often used for utility or helper functions, where the method 
	does not need access to instance variables or methods.

	Characteristics of Static Member Functions:

	- Class-Level Function: A static method is associated with the class itself rather than with any specific 
	  object or instance of the class. This means that it can be called without creating an object.

	- Access to Static Members: Static methods can access other static members (variables and methods) of the class.
	  However, they cannot directly access instance variables or instance methods, because instance variables belong 
	  to specific objects, and static methods do not belong to any specific object.

	- Memory Allocation: Static methods are allocated memory once, when the class is loaded into memory, and they 
	  exist as long as the class exists in memory.

	- Cannot Use this: Since static methods do not belong to any particular object, they cannot use the this keyword. 
	  The this keyword refers to the current object, which does not exist for static methods.

		Memory allocated for all objects of class Item
	 ________________________________________________________________________
	 |common memory area							|
	 |	void setData(){}		tot				|
	 |	void showData(){}		 [ 0.0 ]			|
	 |	static void showTotalBill()					|
	 |______________________________________________________________________|
	 |Individual memory area						|
	 |	ob1		ob2		list				|
	 |	[]              []  		[    ] - For data only		|
	 |									|
	 |______________________________________________________________________|
	

	In above program, the variable tot holds the data i.e. total bill which is not secure, so we want to hide
	it within a class.


import java.util.Scanner;
class Item
{
	private int icode;
	private double iprice;
	private static double tot;
	public void setData()
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the code of item: ");
		icode=sc.nextInt();
		System.out.println("Enter the price of item: ");
		iprice=sc.nextDouble();
		tot = tot + iprice;
	}
	public void showData()
	{
		System.out.print("\n Item Code: "+icode+"\t Price: "+iprice);
	}
	public static void showTotalBill()
	{
		System.out.println("\n Total Bill: "+tot);
	}
}
class MainItemClass2
{
	public static void main(String []args)
	{
		Item.showTotalBill();
		Item []list = new Item[5];
		
		System.out.println("Enter the details of five Items: ");
		for(int i=0;i<5;i++)
		{
			list[i]=new Item();
			list[i].setData();
		}

		System.out.println("\n Item List ");
		for(int i=0;i<5;i++)
		{
			list[i].showData();
		}
		Item.showTotalBill();
	}
}

//-----------------------------------------------------------------------------------------------------------

	// In a different Style: Using the setter and getter methods


import java.util.Scanner;
class Product
{
	private int id;	
	private static int tot;
	private String name;
	private double price;
	
	public void setId(int id) {
		this.id=id;
	}
	public int getId() {
		return id;
	}
	
	public void setName(String name) {
		this.name=name;
	}
	public String getName() {
		return name;
	}
	
	public void setPrice(double price) {
		this.price = price;
		tot+=this.price;
	}
	public double getPrice() {
		return price;
	}

	public String toString() {
		return "Produce Details: ID: "+id+" Name: "+name+"\n Price: "+price;
	}

	public static float getTot() {
		return tot;
	}
}
class DemoProduct
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the prduct count: ");
		int cnt = sc.nextInt();
		Product []p1 = new Product[cnt];

		int i=0;
		int id;
		String name="";
		double price;

		while(true) {
			System.out.println("Enter 1 insert and the 2 to display product details 3 to display total Bill: ");
			int opt = sc.nextInt();

			if(opt==1) {
				 System.out.println("Enter the id, name and price: ");
				 p1[i]=new Product();
				 id=sc.nextInt();
				 p1[i].setId(id);

				 name=sc.nextLine();
				 name=sc.nextLine();
				 p1[i].setName(name);

				 price=sc.nextDouble();
				 p1[i].setPrice(price);

				 i++;
			}
			else if (opt==2) {
				System.out.println("\n ----------- List of Product ---------- ");
				for(int j=0; j<i ; j++)	{
					System.out.println(p1[j]);
				}
			
			}
			else if (opt==3) {
				System.out.println("\n ----------- Pay Bill: "+Product.getTot()+" ---------- ");

			}
		}
	}
}

	//-----------------------------

	// Static initializer (Static Block):

	In Java, a static initializer (also known as a static block) is a special code block that is used to initialize 
	static variables when the class is loaded into memory. It is executed only once when the class is first loaded, 
	and not every time an object of the class is created. This is different from instance initialization, which 
	occurs whenever a new instance of the class is created.

	- Declaration: A static block is declared using the static keyword, followed by a block of code enclosed in 
	  curly braces {}. It is placed inside the class, but outside any methods or constructors.

	  i.e.
		class Example
		{
			int x;
			static double y;
			static
			{
				y=100.0;
			}
			....
		}

	- It is used, To initialize static variables or perform any setup that is needed at the class level (before 
	  any objects are created).
	- Useful for complex initialization of static variables, especially if the initialization requires multiple 
	  lines of code or logic that cannot be done in a simple assignment.
	- If there are multiple static blocks in a class, they will execute in the order in which they appear 
	  in the code.
	- A static block can also handle exceptions. If an exception is thrown within a static block, it can be 
	  caught and handled, preventing the class from failing to load.


	// lets see the default values of static variables

class Example
{
	static int x;		// we not decl. as private,it is default, and accessible using 
	static double y;	// .operator directly. And we want to access directly for checking purpose.
	static boolean z;
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}


	// class with static initilizer

class Example
{
	static int x;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		x=5;
		y=x*x/3.0;
		System.out.println("\n In Static Block");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}


	// A class with multiple static Blocks
class Example
{
	static int x;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		System.out.println("\n In Static Block-1");
	}	
	static
	{
		x=5;
		System.out.println("\n In Static Block-2");
	}	
	static
	{
		y=x*x/3.0;
		System.out.println("\n In Static Block-3");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}


	// static block with try-catch (handling exception in static block)

class Example
{
	static int x;
	static int t;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		t=2;  // try with t=0
		System.out.println("\n In Static Block-1");
	}	
	static
	{
		try
		{
			x=23/t;
		}
		catch (Exception e)
		{
			System.out.println("\n Unable to init x, so init to default value");
		}
		System.out.println("\n In Static Block-2");
	}	
	static
	{
		y=x*5.7/x;
		System.out.println("\n In Static Block-3");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}

//---------------

	// Using static nested class

	In Java, a static class typically refers to a nested static class. It is a class defined within another class 
	but declared with the static keyword. Static classes are a way to define inner classes that don't depend on an
	instance of the outer class, which allows them to behave differently from regular inner classes.

	Key Points About Static Classes
	- It must be in a scope of enclosing class(Outer), Must not be decl. within constructor or method of outer class.
	- A static class in Java is always a static nested class, which is a class that is defined within another class, 
	  but with the static keyword. It is an inner class but without a reference to an instance of the outer class.
	- A static nested class does not have access to the instance variables or instance methods of the outer class. 
	  It can only directly access the static members of the outer class.
	- Unlike regular inner classes, which require an instance of the outer class to be created, a static nested 
	  class can be instantiated independently, without needing an instance of the enclosing (outer) class.
	- wheneven you want to use inner class, It must be written in fully qualified manner, while creating object 
	  and allocating memory for it.

class Outer
{
	private int x;
	static class Inner
	{
		private int y;
		public void setData()
		{
			y=200;
		}
		public void showData()
		{
			System.out.println("y="+y);
		}
	}
	public void in()
	{
		x=100;
	}
	public void out()
	{
		System.out.println("x="+x);
	}
}
class DemoStaticInnerClass 
{
	public static void main(String[] args) 
	{
		Outer ob1=new Outer();
		ob1.in();
		ob1.out();

		Outer.Inner ob2 = new Outer.Inner();
		ob2.setData();
		ob2.showData();
	}
}


	// Accessing static member of Inner and Outer class

class Outer
{
	static int var_out;
	private int x;
	static class Inner
	{
		static int var_in;
		private int y;
		public void setData()
		{
			y=200;
		}
		public void showData()
		{
			System.out.println("y="+y);
			System.out.println("var_out="+var_out); // Inner method able to access static members of outer class
		}
	}
	public void in()
	{
		x=100;
	}
	public void out()
	{
		System.out.println("x="+x);
		// System.out.println("var_in="+var_in); // Error: we cant access the static member of inner class from outer method
	}
}
class DemoStaticInnerClass 
{
	public static void main(String[] args) 
	{
		Outer ob1=new Outer();
		ob1.in();
		ob1.out();

		Outer.Inner ob2 = new Outer.Inner();
		ob2.setData();
		ob2.showData();
	}
}

	Static nested classes are often used when you want to logically group a class inside another class, but it 
	does not need access to the outer class instance.

//---------------

	// Using Static import
	
	In Java, static import is a feature that allows you to access static members (fields and methods) of a 
	class without needing to qualify them with the class name. This can make the code more concise and 
	readable, especially when you use multiple static members from a class frequently. 
	Static import is introduced in Java 5 (with the release of J2SE 5.0).

	syntax:
	 - 1. Importing Specific Static Members: import static packageName.ClassName.staticMember;
	 - 2. Importing All Static Members: import static packageName.ClassName.*;


// we have to write program to calculate the area of circle(pi*r*r)
/*
// in simple way
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=3.142*r*r;
		System.out.println("Area of Circle: "+area);
	}
}

//----------------------------

// Using java.lang.Math class

class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=Math.PI*Math.pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}


//----------------------------

// Using static import(pow() only)

import static java.lang.Math.pow;
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=Math.PI*pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}

*/
//----------------------------

// Using static import-Importing all static members
import static java.lang.Math.*;
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=PI*pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}


	In above examples:

	- Without static import: You need to fully qualify Math.pow(2, 3).
	- With static import: You can simply use pow(2, 3) directly, making the code cleaner.

	Drawbacks of Static Import:

	- Ambiguity: Static import can lead to ambiguity when multiple static members with the same name are 
	  imported from different classes.
	- Reduced Clarity: it become difficult to determine which static members belong to which class in case 
	  multiple static imports.

//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------

	// Inner(Nested) classes in Java: 

	In Java, an inner class is a class defined within another class. Inner classes are primarily used to logically 
	group classes that will only be used in one place, increasing encapsulation and improving code readability.

	Types of Inner Classes in Java:
	- Nested Inner Class (Non-static Inner Class)
	- Static Nested Class
	- Method-Local Inner Class
	- Anonymous Inner Class

	// Nested Inner Class (Non-static Inner Class):  A non-static inner class is associated with an instance 
	   of the outer class and can access its members (including private members).
	
class Outer 
{
	private int x=100;
	private static int y=100;
	void show()
	{
		System.out.println("Inside Outer Class");
	}
    	class Inner 
	{
        	void display() 
		{
			show();
            		System.out.println("Inside Non-static Inner Class");
            		System.out.println("x= "+x);
            		System.out.println("y= "+y);
        	}
   	}
}
class DemoInner
{
	public static void main(String []args)
	{
		Outer out = new Outer();
		out.show();

		Outer.Inner in = out.new Inner();
		in.display();
	}
}
	// Note
	- If you want to create the object of inner class, first you need to create the object of outer class.
	  and using instance(object) of outer class, we need to use inner class.
	- Inner class having access to outer class member(methods and variables) directly, but 
	  vice-versa not possible.

//-----------------

	// - Static Nested Class: A static nested class is associated with the outer class itself rather than an 
	     instance. It cannot directly access instance variables or methods of the outer class.

class Outer 
{
	private static int y=100;
    	static class Inner 
	{
        	void display() 
		{
            		System.out.println("Inside Non-static Inner Class");
            		System.out.println("y= "+y);
        	}
    	}
}
class DemoInner
{
	public static void main(String []args)
	{
		Outer.Inner in = new Outer.Inner();
		in.display();
	}
}

	// Note
	- If you want to create the object of static inner class, you don't need object of outer class.
	  only outer class name is sufficient to access inner static-nested class.
	- Static inner class having access to only static members of outer class.
	- Non-static methods and instance variables of outer class can not be accessed directly.

//----------------

	// - Method-Local Inner Class: A method-local inner class is defined within a method and is only 
	     accessible within that method.

class Outer 
{
	void outerMethod() 
	{
        	class MethodInner 
		{
            		void display() 
			{
                		System.out.println("Inside Method-Local Inner Class");
            		}
        	}
        	MethodInner inner = new MethodInner();
        	inner.display();
    	}
	void anotherMethod()
	{
		MethodInner ob = new MethodInner(); // will generate error, coz member decl. 
	}					    // in a scope can be accessible with in only.
}

//----------------------

	// anonymous inner class: An anonymous inner class is a class without a name, typically 
				  used to override methods of an interface or superclass.


class Sample
{
	public void sayHi() {
		System.out.println("Hi From Sample");
	}
	public void sayHello() {
		System.out.println("Hello From Sample");
	}
	
}

class Test extends Sample {

	public void sayHello() {
		System.out.println("Hello From Test");
	}
}

class MainClassAIC
{
	public static void main(String []args) {

		Sample ob1 = new Sample();
		ob1.sayHi();
		ob1.sayHello();

		System.out.println("\n ---------------------------");

		Test ob2 = new Test();
		ob2.sayHi();
		ob2.sayHello();

		System.out.println("\n ---------------------------");

		Sample ob3 = new Sample() {
			int z=100;
			public void sayHello() {
				System.out.println("Hello From No-Name");
			}
		};
		ob3.sayHi();
		ob3.sayHello();
	}
}

//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------

	
	 // Using this keyword: 

		In Java, the this keyword is a reference to the current object within a class. It is 
		commonly used in methods, constructors, and inner classes to distinguish between instance 
		variables and parameters or to call other constructors or methods within the same class.

		Here are some common uses

	 1. Returning the Current Object: 'this' always refers to invoking object(object
	    on which method is called). Some times we need to return it from method defined within same class
	    in that case 'this' used as shown below..!!


import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public void setData()
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the Name: ");
		name = sc.nextLine();

		System.out.println("Enter the ID: ");
		id = sc.nextInt();

		System.out.println("Enter the Age: ");
		age = sc.nextInt();

		System.out.println("Enter the Salary: ");
		salary = sc.nextDouble();
	}
	public void showData()
	{
		System.out.print("\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
	public Person findElder(Person x)
	{
		if(x.age>age)
			return x;
		else 
			return this;
	}
}
class ThisExample 
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();
		p1.setData();

		Person p2 = new Person();
		p2.setData();

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();

		Person t = p1.findElder(p2);		
		System.out.println("\n Elder Person ");
		t.showData();
	}
}

//--------------------------------

	 2. Referring to Instance Variables: When method or constructor parameters have the same name as instance 
	 variables, this helps differentiate between the two.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		id = -1;
		name = "NA";
		this.age = -1;
		this.salary = -1.0;
	}
	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	public void setData()
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter the Name: ");
		name = sc.nextLine();

		System.out.println("Enter the ID: ");
		id = sc.nextInt();

		System.out.println("Enter the Age: ");
		age = sc.nextInt();

		System.out.println("Enter the Salary: ");
		salary = sc.nextDouble();
	}
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();
		p1.showData();

		p1.setData();

		Person p2 = new Person();
		p2.setData(11,"Abhay",23,12.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
	}
}

//-----------------------------------

	3. Calling Another Constructor (Constructor Chaining): The this keyword can be used to call 
	   another constructor within the same class.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); // constructor chaining
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); // constructor chaining
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}

//-----------------------------------

	4. Calling Current Class Methods: this can be used to explicitly call methods of the current object.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); // constructor chaining
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); // constructor chaining
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
		System.out.print(" - Status: "+this.isWorking(this.salary));
	}
	private String isWorking(double sal)
	{
		if(sal>0)
			return "Working";
		else
			return "Not Working";
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}

//-----------------------------------------------------------------------------------------------------------------

	// 5. Passing the Current Object as a Parameter: The this keyword can be passed as an argument to 
	      methods or constructors.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); 
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); 
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		if(isWorking(this)) // display if working
			System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
	private boolean isWorking(Person p)
	{
		if(p.salary>0)
			return true;
		else
			return false;
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}


//=====================================================================================================================

	
		// Forming the Class Relationship -  Inheritance and Association


		    Inheritance 				   Association

			IS-A					      HAS-A	

			person				  Engine		Music Player		
			  |				    |			   |		 
		---------------------			    |______________________|	
		|	 |	    |			Strong bonding 	|  weak bonding
	    Trainer   Student    Driver			 Composion     Car  Agrigation

				  		 
				CPP Code just for example

	class person						class Engine
	{							{
	};							};
	class Trainer : public person				class MusicPlayer
	{							{
	};							};
	class Student : public person				class Car
	{							{
	};								Engine ob1;
	class Driver: public person					MusicPlayer ob2;
	{							};
	};

                     | |					  | |
		      V					     	   V
  		Inheritance				 	Association




	- Inheritance: Inheritance is a mechanism where one class (called the child class or subclass) derives 
	  properties and behavior (fields and methods) from another class (called the parent class or superclass). 
	  It promotes code reusability and establishes a relationship like "is-a."

	-  Association: Association is a relationship between two classes that establishes a connection.

	Types of Association:
	 - Aggregation: A weak association where one object can exist independently of the other.
	 - Composition: A strong association where one object cannot exist independently of the other.

	// Inheritance

            /// Inheritance: It is act of defining the new class using the pre-defined classes.
                             It will provide the the next level of reusability.

    consider the example, in normal case,

    class employee              class student           class Teacher           class Driver
    {                           {                       {                       {
        char name[50];              char name[50];         char name[50];           char name[50];
        int age;                    int age;                int age;                int age;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
    };                          };                      };                      };



    some elements are there in each class, and every class having code related to IO of those
    member, which is code repetition and can be avoided using the class inheritance as


    /// syntax of inheritance

    class <base/super/parent_class>
    {
        ........;
    };
    class <derived/sub/child_class> extends <base_class_nm>
    {
        --------;
        --------;
    };

        e.g.

        class person
        {
            char name[50];
            int age;
            --------------;
            --------------;
            --------------;
        };


class employee extends person  class student extends person  class Teacher extends person  class Driver extends person
{                               {                            {                              {
    -----------;                      -----------;                   -----------;                 -----------;
    -----------;                      -----------;                   -----------;                  -----------;
    -----------;                      -----------;                   -----------;                  -----------;
};                              };                            };                           };


///--------------------------------------------------------------------------------------------

///--------------------------------------------------------------------------------------------

        /// Types of Inheritance: In C++ we have seen following inheritances


            single          Multi-level          hierarchical        Multiple         Hybrid
          Inheritance       Inheritance           Inheritance       Inheritance     Inheritance

             [   ] A            [     ]  A             [ ] A           A       B       [ ]A                  A
               |                   |                    |              [ ]     [ ]      |                   [ ]
               |                [     ]  B        --------------        |_______|      [ ] B                 |
               V                   |              |            |             |          |         D     -------------
             [   ]  B           [     ]  C       [ ]B         [ ]c          [ ]        [ ] C     [ ]    |           |
                                                  |            |             C          |         |    [ ] B       [ ] C
                                              ---------      ---------                 [ ] -------|     |___________|
                                              |        |     |   |    |                 Z                     |
                                             [ ]      [ ]   [ ] [ ]  [ ]                                     [ ]
                                              D        E     F   G    H                                       D

    - single Inheritance:   One to one relationship, two layers
    - Multi-level Inheritance: one to one relationship, more than two layers
    - hierarchical Inheritance: One to many relationship
    - Multiple Inheritance: many to one relationship
    - Hybrid Inheritance: combinations of any two or more inheritance

	In Java, There are only three inheritances i.e. 

	- single Inheritance
	- multilevel Inheritance 
	- hierarchical Inheritance.

	*Note: multiple and Hybrid inheritancs are not present in java.
	

	- Single inheritance: 
	  Single inheritance in Java is a concept where a class inherits from one and only one parent (or superclass). 
	  It allows a child class to acquire the properties and methods of a single parent class, promoting code
	  reusability and a hierarchical relationship.

// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Child class
class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

// Child class
class Human extends Animal {
    void speak() {
        System.out.println("The human speaks.");
    }
}

// Main class
public class MainSingleInh {
    public static void main(String[] args) {
        Dog dob = new Dog();
        dob.eat(); // Inherited from the Animal class
        dob.bark(); // Defined in the Dog class

        Human hob = new Human();
        hob.eat(); // Inherited from the Animal class
        hob.speak(); // Defined in the Dog class
    }
}

//------------------------------


	// Accessing members of base class with different visibility.

class Base
{
	private int x=11;
	protected int y=22;
	int z=33; // default visibility
	public int t=44;
	// and some methods
}
class Derived extends Base
{
	public void display()
	{
		// System.out.println("\n x="+x);
		System.out.println("\n y="+y);
		System.out.println("\n z="+z);
		System.out.println("\n t="+t);
	}
}

class MainAccessSingle
{
	public static void main(String []args)
	{
		Derived ob = new Derived();
		ob.display();

		// System.out.println("\n x="+ob.x);
		System.out.println("\n y="+ob.y);
		System.out.println("\n z="+ob.z);
		System.out.println("\n t="+ob.t);
	}
}


------------ On Compile ----------------
MainAccessSingle.java:13: error: x has private access in Base
                System.out.println("\n x="+x);
                                           ^
1 error
Press any key to continue . . .

 -> which means that only private members are not inheritable.

 // After commenting above and accessing using . opertator

MainAccessSingle.java:27: error: x has private access in Base
                System.out.println("\n x="+ob.x);
                                             ^
1 error
Press any key to continue . . .

 -> which means that only private member not inheritable using . operator directly.

	// Note:
		- The extends keyword is used to establish the inheritance relationship.
		- The child class can access all non-private members (fields and methods) of the parent class.


//----------------------------------------------

	// Overloading and Overriding in the single inheritance.

	- Overloading:
	  Overloading occurs when two or more methods in the same class (or in a child class) have the same 
	  name but different parameter lists (number, type, or order of parameters). It is an example of 
	  compile-time polymorphism.

	- Key Points of Overloading:
		- Happens within the same class.
		- Methods must have the same name but different parameter lists.
		- Return type may or may not be different.
		- Resolved at compile time.


class Calculator {
    // Method 1: Adding two numbers
    int add(int a, int b) {
        return a + b;
    }

    // Method 2: Adding three numbers (overloading)
    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class MainOverloading {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(5, 10)); // Calls the first add method
        System.out.println(calc.add(5, 10, 15)); // Calls the second add method
    }
}


//---------------------------------------------------------

	- Overriding:

	  Overriding occurs when a child class provides its own implementation of a method that is already 
	  defined in the parent class. It is an example of runtime polymorphism.

	- Key Points of Overriding:
		 - Happens between parent and child classes.
		 - Method signature (name, parameters, and return type) must be exactly the same.
		 - Resolved at runtime (dynamic method dispatch).
		 - The access modifier of the overriding method must be the same or more permissive 
		   than the method in the parent class.

class Animal {
    void sound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    // Overriding the sound method of the parent class
    void sound() {
        System.out.println("The dog barks.");
    }
}

public class MainOverriding {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        myAnimal.sound(); // Calls the parent class method

        Dog myDog = new Dog();
        myDog.sound(); // Calls the overridden method in the child class
    }
}


	// Accessing the Overriden methods 

	In Java, when a method is overridden, the subclass version is called by default. However, if you want to 
	access the overridden method from the parent class in the subclass, you can use the super keyword. 
	This is useful when you want to extend the behavior of the parent class's method rather than 
	completely replacing

class Animal {
    void sound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    // Overriding the sound method of the parent class
    void sound() {
		super.sound();
        System.out.println("The dog barks.");
    }
}

public class MainOverriding {
    public static void main(String[] args) {

        Animal myAnimal = new Animal();
        myAnimal.sound(); // Calls the parent class method

	System.out.println("\n ---------------------- ");

        Dog myDog = new Dog();
        myDog.sound(); // Calls the overridden method in the child class
    }
}

//------------------------------------------------------------------------------------------

	// Defining the constructors in inheritance

	In Java, When we write the constructors in base and child class, 
	- if we create the base class object, only base class constructor will be executed.
	- if we create an object of child class, then first base class constructor and then child
	  class constructor will be executed. again it confirms that memory is allocated for both 
	  child and base classes.
	- Bydefault default constructors of both classes are executed.
	- If we invoke the parameterized constructor of child class, then at start it will invoke the 
	  default constructor of base class and then parameterized constructor of child.

	So we need to use super keyword to invoke the parameterized constructor of base class.


package com.archer.inhex;
class Person {

	//	fields
	private int uid;
	private String name;

	//	Constructors
	public Person() {
		uid = 0;
		name = "No Name";
	}

	public Person(int uid, String name) {
		super();
		this.uid = uid;
		this.name = name;
	}
	
	// setter and getter methods
	public int getUid() {
		return uid;
	}
	public void setUid(int uid) {
		this.uid = uid;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}

class Student extends Person {
	// fields
	private int rno;
	private double per;
	
	// Constructors
	public Student() {
		rno = 0;
		per = 0.0;
	}
	
	public Student(int uid, String name, int rno, double per) {
		super(uid, name); // calls the para. constructor of base(super) class
		this.rno = rno;
		this.per = per;
	}
	
	public Student(int rno, double per) {
		this.rno = rno;
		this.per = per;
	}

	// setter and getter methods
	public int getRno() {
		return rno;
	}
	public void setRno(int rno) {
		this.rno = rno;
	}
	public double getPer() {
		return per;
	}
	public void setPer(double per) {
		this.per = per;
	}
}
public class MainClassSingleInh {

	public static void main(String[] args) {
		
		// Creating Object Using Setter and Getter methods
		Student s1 = new Student();
		s1.setName("Amol");
		s1.setUid(12345);
		s1.setRno(12);
		s1.setPer(78.45);
		System.out.println("Name: "+s1.getName()+"\t UID: "+s1.getUid()+"\t RNO: "+s1.getRno()+"\t Marks: "+s1.getPer()+"%");

		System.out.println("\n -------------------------------------------- ");
		
		// Creating the Object using the default Constructor
		Student s2 = new Student();
		System.out.println("Name: "+s2.getName()+"\t UID: "+s2.getUid()+"\t RNO: "+s2.getRno()+"\t Marks: "+s2.getPer()+"%");

		System.out.println("\n -------------------------------------------- ");
				
		// Creating the Object using the default Constructor
		Student s3 = new Student(15, 98.23); 
		// here the parameterized constructor of child class Student is invoked, and automatically it will invoke the default constructor of base class.
		System.out.println("Name: "+s3.getName()+"\t UID: "+s3.getUid()+"\t RNO: "+s3.getRno()+"\t Marks: "+s3.getPer()+"%");
		
		System.out.println("\n -------------------------------------------- ");
		
		// to invoke the base class we need to pass the arguments first.
		Student s4 = new Student(495867,"Uday",15,98.23); 
		System.out.println("Name: "+s4.getName()+"\t UID: "+s4.getUid()+"\t RNO: "+s4.getRno()+"\t Marks: "+s4.getPer()+"%");
		
	}

}

//------------------------------------------------------------------------------------------------------------
	// Using the 'super' Keyword

	The super keyword in Java is a powerful tool used within a subclass to directly refer to its immediate parent 
	class. It is primarily used to access parent class members (constructors, methods, or fields) that are overridden 
	or hidden by the subclass. 

	1. Using super to Call Overriden Parent Class Methods in child class.
	   When a subclass overrides a method from the parent class, the super keyword can be used to call the original 
	   method from the parent class. This is particularly useful when you want to reuse the parent class's logic 
	   while extending or modifying its behavior in the subclass.

	2. Using super to Access Overriden Parent Class Fields in child class.
	   If a subclass declares a field with the same name as a field in the parent class, the subclass's field hides 
	   the parent class's field. You can use super to access the hidden field in the parent class.

class Parent {
    String name = "Parent";
}

class Child extends Parent {
    String name = "Child";

    void printNames() {
        System.out.println("Name in Child: " + name);
        System.out.println("Name in Parent: " + super.name);
    }
}

public class MainSuper {
    public static void main(String[] args) {
        Child child = new Child();
        child.printNames();
    }
}


	3. Using super to Call Parent Class Constructors
	   You can use super() to call the parent class's constructor. This is often done to initialize the parent 
	   class fields with parameters passed via child class constructor.


	Rules and Notes:
	 - First Statement in Constructor: When used in a constructor, super() must be the first statement.
	   If you don't explicitly call super(), Java inserts a default super() call (to the no-argument constructor 
	   of the parent).

	- Only Immediate Parent: super always refers to the immediate parent class. It cannot access methods, fields, 
	  or constructors of ancestors beyond the immediate parent.

	- Access Modifiers:super respects Java's access control rules (e.g., private members of the parent class cannot 
	  be accessed using super).

	- No super in Static Contexts:super cannot be used in static methods or blocks because it depends on an instance.

//--------------------

	Are the constructors inheritable?

	No, constructors are not inheritable in Java. This is because constructors are not part of an object's
	instance or class; instead, they are special methods used for initializing an object when it is created. 
	Each class in Java must define its own constructors, even if it is a subclass.

	Can we override the constructor?

	No, constructors cannot be overridden in Java. This is because constructors are not inherited by subclasses, 
	which is a prerequisite for overriding a method. However, constructors can be overloaded within the same class.

//-----------------------------------------------------------------------------------------------------------------------

	// Using Final Keyword:

	In Java, the final keyword is a modifier that can be applied to variables, methods, and classes. 
	It serves different purposes depending on where it is used.


	1. Final Variables: A variable declared as final cannot have its value reassigned after it has 
			    been initialized. It makes the variable constant.

	Rules for Final Variables:

	- If the variable is a primitive type, its value cannot be changed after initialization.
	- If the variable is a reference type (like an object or array), the reference cannot be 
	  changed, but the object's state(like values of fields) can be modified.


	public class FinalVariableExample {
    		final int CONSTANT = 100;  // Initialized during declaration
    		final int anotherConstant;
    
		FinalVariableExample() {
        		anotherConstant = 200;  // Initialized in the constructor
    	}

    public static void main(String[] args) {
       
	FinalVariableExample example = new FinalVariableExample();
        System.out.println(example.CONSTANT);
        System.out.println(example.anotherConstant);

        // example.CONSTANT = 300; // Error: Cannot assign a value to a final variable
		// example.anotherConstant = 400; // Error: Cannot assign a value to a final variable
    }
}

	Note: 
	     - Once you initilize, Value of final variable can not be altered, Even using constructor, 
	       when it is assigned already.
	     - Constructor allows to initilize, only when it is not assined in decleration.

//---------------------------

class Demo
{
	private int x;
	public Demo() {
		x=10;
	}
	public Demo(int t) {
		x=t;
	}
	public void setx() {
		x=1000;
	}
	public void show() {
		System.out.println("x="+x);
	}
}
class FinalVariableExample1 
{
	public static void main(String[] args) 
	{
		final Demo ob1 = new Demo(100);
		Demo ob2 = new Demo(200);
		
		ob1.show();
		ob2.show();

		//ob1=ob2;	// error: cannot assign a value to final variable ob1
		// the reference cannot be changed coz ob1 is final

		ob1.setx(); // evenif ob1 is final as we are not chamging the reference, it will allow
			    // to change the values of fields.
		ob1.show();
	}
}

---------------------

	2. Final Methods: A method declared as final cannot be overridden by subclasses. This is useful 
			when you want to prevent a specific behavior from being modified in child classes.


class Base {
	final public void message() {
		System.out.println("In the Base Class");
	}
}
class Child extends Base {
	public void message() { // error: message() in Child cannot override message() in Base overridden method is final
		System.out.println("In the Child Class");
	}
}
class FinalMethodExample
{
	public static void main(String[] args) 
	{
		Child ob = new Child();
		ob.message();
	}
}

//------------------------------------------

	3. Final Classes: A class declared as final cannot be extended. This is useful for creating immutable 
			  classes or when you want to prevent inheritance.

final class FinalClass {
    void display() {
        System.out.println("This is a final class.");
    }
}

// class SubClass extends FinalClass { 
//     // Error: Cannot inherit from final class
// }

public class FinalClassExample {
    public static void main(String[] args) {
        FinalClass obj = new FinalClass();
        obj.display();
    }
}

//----------------------------------------


4. Final Parameters:
When a parameter is declared as final in a method, it means that 
the value of the parameter cannot be changed within the method.


class Demo
{
	private int x;
	public void in(final int t)
	{
		t=78; // error: final parameter t may not be assigned
		x=t;
	}
	public void show()
	{
		System.out.println("\n x="+x);
	}
}
class DemoFinalParameter
{
	public static void main(String []args)
	{
		Demo ob=new Demo();
		ob.in(100);
		ob.show();
	}
}

Output (Error on Compie)

DemoFinalParameter.java:114: error: final parameter t may not be assigned
                t=78;
                ^
1 error
Press any key to continue . . .

//------------------------------------------

	// Passing the mutable and immutable objects 

	- When we pass the refence of an object which is mutable. then it will allows to modify the contents
	  of actual location, it will keep doing same, even if the are decl. as final while collecting as a
	  a formal arguments, coz in that case reference modification will not attempted.

	- Even though the reference is fixed, the object's internal state (its fields or elements) can still be 
	  modified, provided the object itself is mutable (not declared final for fields or does not contain 
	  immutable fields).

	- When we pass the refence of an object which is immutable, and you try to change the original locations,
	  then as the original location is immutable, the newly assigned data stored in the memory and the formal
	  arguments start refering to that new location.(Implicitly reference modification is attempted) 

	- To avoid such reference modification in case of immutable object the final keyword is used.

	- The object's state, such as fields or array elements, can still be modified as long as the object is mutable.

class DemoRefPass 
{
	public static void fun(String s3, String s4)
	{
		s3="good day";
		s4="bye bye";
	}
	public static void main(String[] args) 
	{
		String s1="Hi";
		String s2="Hello";
		System.out.println("Before Call: s1 - "+s1+"\t s2 - "+s2);
		fun(s1,s2);
		System.out.println("After Call: s1 - "+s1+"\t s2 - "+s2);
	}
}

 It will gives like output same as that of(or like) "By Value", due to String Object is immutable.

	// To avoid it, use final

class DemoRefPassImmutable
{
	public static void fun(final String s3, final String s4)
	{
		s3="good day";
		s4="bye bye";
	}
	public static void main(String[] args) 
	{
		String s1="Hi";
		String s2="Hello";
		System.out.println("Before Call: s1 - "+s1+"\t s2 - "+s2);
		fun(s1,s2);
		System.out.println("After Call: s1 - "+s1+"\t s2 - "+s2);
	}
}

 //------- on compile ----------

DemoRefPassImmutable.java:5: error: final parameter s3 may not be assigned
                s3="good day";
                ^
DemoRefPassImmutable.java:6: error: final parameter s4 may not be assigned
                s4="bye bye";
                ^
2 errors
Press any key to continue . . .

//-----------------------------------------

	// Passing mutable object

class Num
{
	private int x;
	public void setX( int x) {
		this.x = x;
	}
	public int getX() {
		return x;
	}
}
class DemoRefPassMutable
{
	public static void fun(final Num ob3, final Num ob4)  // absence of final will gives same output
	{
		ob3.setX(1000);
		ob4.setX(2000);
	}
	public static void main(String[] args) 
	{
		Num ob1 = new Num();
		Num ob2 = new Num();
		ob1.setX(10);
		ob2.setX(20);
		System.out.println("Before Call: ob1 - "+ob1.getX()+"\t ob2 - "+ob2.getX());
		fun(ob1,ob2);
		System.out.println("Before Call: ob1 - "+ob1.getX()+"\t ob2 - "+ob2.getX());
	}
}


//-------------------------

	// Note to Remember

	- Private members are not inheritable.

class Sample
{
	private int x;
	public float y;
	double z;
	protected char ch;
}
class Test extends Sample
{
	public Test()
	{
		x=100; // error: x has private access in Sample
		y=3.4F;
		z=45.23;
		ch='w';
	}
}
class DemoTestAccess
{
	public static void main(String[] args) 
	{
		Test ob = new Test();
	}
}


//---------------------------------------------------------------------------------------------------------------------


- Multilevel Inheritance:

		[ ] Person		in() and out()	
		 |				 
		 |				 
	  	[ ] Student		input() and output()
		 |
		 |
		[ ] Sport		set() and show()

import java.util.Scanner;
class Person
{
	private String nm="";
	private int age;
	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the name of person: ");
		nm=sc.nextLine();

		System.out.println("\n Enter the age of person: ");
		age=sc.nextInt();
	}
	public void out()
	{
		System.out.println("\n Name: "+nm+"\t age: "+age);
	}
}
class Student extends Person
{
	private int rno;
	private double per;
	protected void input()
	{
		//in();
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the rno of Student: ");
		rno=sc.nextInt();

		System.out.println("\n Enter the percentage of Student: ");
		per=sc.nextDouble();
	}
	public void output()
	{
		//out();
		System.out.println("\n RNO: "+rno+"\t Percentage: "+per);
	}
}
class Sport extends Student
{
	private int points;
	void set()
	{
		//in();
		//input();
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the grade points of Student: ");
		points=sc.nextInt();
	}
	public void show()
	{
		out();
		output();
		System.out.println("\n Points: "+points);
	}
}
class MainStudentMultilevel
{
	public static void main(String []args)
	{
		Sport s=new Sport();

		s.in();
		s.input();
		s.set();

		s.show();	
	}
}

//-------------------------------------------------------------------------------------------------

	/// Using the constructors in inheritance

class Base
{
	private int a;
	public Base()
	{
		System.out.println("\n In Base default");
		a=10;
	}
	public Base(int x)
	{
		System.out.println("\n In Base para");
		a=x;
	}
	public void showBase()
	{
		System.out.println("\n a="+a);
	}
}
class ImdBase extends Base
{
	private int b;
	public ImdBase()
	{
		System.out.println("\n In ImdBase default");
		b=20;
	}
	public ImdBase(int x, int y)
	{
		super(x);
		System.out.println("\n In ImdBase para");
		b=y;
	}
	public void showImdBase()
	{
		showBase();
		System.out.println("\n b="+b);
	}
}
class Derived extends ImdBase 
{
	private int c;
	public Derived()
	{
		System.out.println("\n In Derived default");
		c=30;
	}
	public Derived(int x, int y, int z)
	{
		super(x,y);
		System.out.println("\n In Derived para");
		c=z;
	}
	public void showDerived()
	{
		showImdBase();
		System.out.println("\n c="+c);
	}
}

class MainPassParamInh
{
	public static void main(String []args)
	{
		Derived ob1=new Derived();
		ob1.showDerived();

		Derived ob2=new Derived(100,200,300);
		ob2.showDerived();
	}
}

//---------------------------------------------------------------------------------------------------

	// initializer blocks

	In Java, initializer blocks are used to initialize instance variables or perform some setup operations when an 
	object of the class is created. These blocks are executed as part of the object creation process, and they can 
	be either instance initializer blocks or static initializer blocks, depending on their purpose.

	- Types:
		1. Instance Initializer Blocks
		2. Static Initializer Blocks


	// using Instance Initializer Blocks

		- Definition: Instance initializer blocks are enclosed in curly braces {} but are not part 
		  of any method.

		- Purpose: They are used to perform instance-level initialization that is common across all 
		 	   constructors of the class.

		- Execution: Runs before the constructor and after the memory for the object is allocated.

		- Order: Executed in the order they appear in the class definition, and they run after the 
			 superclass constructor and before the subclass constructor.


	// Example 

class Example {
    int x;

    {
        // Instance initializer block
        x = 10;
        System.out.println("Instance initializer block executed");
    }

    Example() {
        System.out.println("Constructor executed");
    }

    public static void main(String[] args) {
        Example obj = new Example();
        // Output:
        // Instance initializer block executed
        // Constructor executed
    }
}

//-----------------------------

	// instace of multile init. blocks sequence in maintained while execution

class Example {
    int x;

    {
        // Instance initializer block
        x = 20;
        System.out.println("Instance initializer block executed-2");
    }

    {
        // Instance initializer block
        x = 10;
        System.out.println("Instance initializer block executed-1");
    }
    Example() {
        System.out.println("Constructor executed");
    }

    public static void main(String[] args) {
        Example obj = new Example();
        // Output:
        // Instance initializer block executed
        // Constructor executed
    }
}


//--------------------------

	/// Using the constructors and initiliser blocks in inheritance

	When we use the constructor and init block within the class in any inheritance, the execution of 
	initblock-constructor starts from base and move towards child.

class Base
{
	private int a;
	{
		System.out.println("\n In Instance init. block - Base");
	}
	public Base()
	{
		System.out.println("\n In Base default");
		a=10;
	}
	public Base(int x)
	{
		System.out.println("\n In Base para");
		a=x;
	}
	public void showBase()
	{
		System.out.println("\n a="+a);
	}
}
class ImdBase extends Base
{
	private int b;
	{
		System.out.println("\n In Instance init. block - ImdBase");
	}
	public ImdBase()
	{
		System.out.println("\n In ImdBase default");
		b=20;
	}
	public ImdBase(int x, int y)
	{
		super(x);
		System.out.println("\n In ImdBase para");
		b=y;
	}
	public void showImdBase()
	{
		showBase();
		System.out.println("\n b="+b);
	}
}
class Derived extends ImdBase 
{
	private int c;
	{
		System.out.println("\n In Instance init. block - Derived");
	}
	public Derived()
	{
		System.out.println("\n In Derived default");
		c=30;
	}
	public Derived(int x, int y, int z)
	{
		super(x,y);
		System.out.println("\n In Derived para");
		c=z;
	}
	public void showDerived()
	{
		showImdBase();
		System.out.println("\n c="+c);
	}
}

class MainPassParamInh
{
	public static void main(String []args)
	{
		Derived ob1=new Derived();
		ob1.showDerived();

		Derived ob2=new Derived(100,200,300);
		ob2.showDerived();
	}
}


//------------------------------

// what is difference between constructor and initilizer block?

	In Java, constructors and initializer blocks are mechanisms used to initialize objects, but they have different 
	purposes, syntax, and use cases. Here’s a detailed comparison:

	Constructor
	- A special method with the same name as the class.
	- Invoked explicitly when an object is created using new.
	- Can be overloaded to provide multiple ways of object initialization.
	- Executes after all initializer blocks (if present).
	- Used for object-specific initialization.
	- Cannot be static.

	Initializer Block
	- A block of code within braces {} that runs automatically when an object is created.
	- Executes before the constructor.
	- Cannot be overloaded.
	- Used for common initialization logic shared across all constructors.
	- Can also have static variants for initializing static variables, executed once when the class is loaded.



//---------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------

	// Hierarchical Inheritnce

			[ ] Person
	 		 |
	 ________________|_______________________________
	 |			|			|
	[ ] student           [   ] Employee           [   ] Driver
	 |			|                        |
	 |			|                  ---------------   
	[ ] sport          -------------------     |             |
	 |                 |         |        |   [ ] Utility   [ ] Heavy 
	 |               [  ]       [  ]     [ ]
	[ ] Result      Worker    Director    CEO

class Person {}

  class Student extends Person {}
     class Sport extends Student{}
        class Result extends Sport{}

  class Employee extends Person {}
     class Worker extends Employee{}
     class Director extends Employee{}
     class CEO extends Employee{}

  class Driver extends Person {}
     class Utility extends Driver{}
     class Heavy extends Driver{}

class MainHierarchicalExample
{
	public static void main(String []args)
	{
		Ceo ob1=new Ceo();
		boolean b= ob1 instanceof Ceo;
		System.out.println(b);

		b=ob1 instanceof Employee;
		System.out.println(b);

		b=ob1 instanceof Person;
		System.out.println(b);

		System.out.println("\n ---------------------- ");

		Result ob2=new Result();
		b=ob2 instanceof Result;
		System.out.println(b);

		b=ob2 instanceof Person;
		System.out.println(b);
	}
}

//-----------------------------------------------------------------------

	// Multiple and Hybrid inheritances - Absent in Java

	// Why multiple and Hybrid inheritances not present in Java?

	We have two more inheritances multiple and Hybrid, these inheritances are present in C++
	but as both create the Ambiguous condition, so both are eliminated from Java.

	NOTE TAHT TO GAIN GOOD PART OF THESE INHERITANCES JAVA INTRODUCED THE INTERFACE.

	Lets see, how the ambiguous condition is cerated by the both
	
	// Multiple Inheritance:


		     student		     sport
	     get()    [  ]	   	     [  ]  in()
	     put()     |	               |   put()
                       |_______________________|
                               |
                               |
                              [ ]
                             Result

                        get()       in()
                        put()       put()	
			     input()
			     output()

	when we create the object of Result class and call put() method.
	
	Result rob;
	...
	rob.put(); // creates ambiguous condition coz there are two copies of put(). 
		   // one from student and another from sport


	lets consider another class relationship

	// Hybrid Inheritance:

                    in()  Student
		    out()  [ ]               ---|
                            |                   |
                   _________|______________     | -----------> // Hierarchical Inheritnce
          in()    |	                  |out()|
	  out()   |           setdata()   |in() |
	 Set()   Exam        showdata() sport   |
	 Show()  [  ]	     	         [  ] ---
	           |	                   |    |
                   |_______________________|    | ----------> // Multiple Inheritance
                            |                   |
 			  [   ]             ----
	    in()   out()  Result  in()       out()
	   Set()   Show()         setdata()  showdata()


	Ambiguous condition is created when we make a call to in() and out() using object of Result class.


	So to eliminate these Ambiguous condition, Java dont have multiple and Hybrid inheritances.
	Note another fact that java does not needs a virtual keyword to create virtual base class.

///===================================================================================================================


	// Polymorphism in Java: It refers one name many forms. there are two
				 different types as discussed below.
	
		the word polymorphism forms as shown

		- Poly: 	many or more
		- morphism: 	forms or copies



                Polymorphism
                      |
            -----------------------
            |                     |
         Runtime /               Compile-time/
     dynamic binding /          static binding/
     dynamic polymorphism /     static polymorphism /
     late binding              early binding
            |                       |
         Overriding             Overloading
                                   - Method Overloading

	* Operator Overloading not present in Java

	We have seen, the method overloading and Constructor overloading these
	are the examples of static/compile time polymorphism.

 Lets implements Runtime Polymorphism Step by Step

	1. Suppose we want to calculate the area() of different shapes
	   i.e.
		 Rect			Triangle 		Circle
		 [   ] 			[   ]			[   ]
	   
		we can define the methods as 

		findArea()	       showArea()		calcArea()

	   Now create an object of class that you want and call respective method.

		Rect ob1;		Triangle ob2;		Circle ob3;
		ob1.findArea();		ob2.showArea();		ob3.calcArea();

	2. Now, quite modification in the program, and that is, still we want to calculate 
	   the area() of any one shape, but which? --> It will be decided at Runtime.

		- We need one pointer, coz there is dynamic memory allocation. Here in java pointer 
		  is absent, so it is solved by reference variable.

		- Important question is that, reference of which type?  Rect, Triangle or Circle.

		- reference of any one, able to refer only location of same type. we need a reference
		  variable which is able to refer any one of the above.

		- We know that, a reference variable of base class able to refer the object of its any child.

		- Lets create a common base class for all the three classes.

     					     Shape
					     [   ]
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		  findArea()	           showArea()		   calcArea()

		Now, lets implement the above hierarchy,

class Shape
{
}
class Rect extends Shape
{
	public void findArea()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void showArea()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void calcArea()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly1
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref = new ..... ; // which object? it is decided at runtime.
		ref.xxxxarea(); 

		// we are unable to call the method coz every class having a method with different name
		// to calculate the area. solution to this problem is there must be a method in all classes
		// having a same name to calculate the area.
	}
}

//-----------------------------------------------
3. lets rewrite


					     Shape
					     [   ] 
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		      area()	              area()		       area()


	- As we have defined multiple methods in different classes, it comes under the polymorphism.
	  i.e. one name many forms

	- here which method will recive a call is dependent on the option selected by the user at runtime.

	- means from multiple copies, one method for execution will be selected at runtime, therefore it is
	  called as runtime polymorphism / dynamic polymorphism.

		Now, lets implement the above hierarchy,

class Shape
{
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly2
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 
	}
}
//--------- on Compile --------

DemoRuntimePoly2.java:36: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
DemoRuntimePoly2.java:41: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
DemoRuntimePoly2.java:46: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
3 errors
Press any key to continue . . .

	
//-------------------------------------------------------

	4. Will face some errors, they are due to

		- Shape ref; means reference is of Shape type, so interpreter searching the method in Shape class.

		- lets provide the method area() in Shape.

					     Shape
					     [   ]  public void area(){}
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		      area()	              area()		       area()


class Shape
{
	public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly3
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 
	}
}

------------- Output on Run ---------------------

In Rect area()
In Circle area()
In Triangle area()
Press any key to continue . . .


//-----------------------------------------------------------------------------------------------------------------------

	5. Note Carefully,

	- If we try same implementation in C++, then in above example we will get the output after execution of area()
	 from Shape class. and to execute the child class methods we need to decl. area() from Shape class as a Virtual.

	- this change in the behaviour, known as "Dynamic Method Dispatch"

	Dynamic Dispatch: When a method is called on an object, Java determines at runtime which version of the method 
	to execute. This is called dynamic dispatch. If the object is of the subclass type, the overridden method in 
	the subclass will be invoked.

	- As the method selection is done correctly without using virtual keyword, java eliminates the virtual keyword.

//---------------------------------------------------------------------------------------------------------------------

	6. Now we want to keep the above aritecture as it is and functional, To keep it functional every child of 
	   Shape class must override the area() method.

	   Then how to make it compulsory? 
	   (In C++, it is done with defining pure virtual function using vitrual keyword, but virtual keyword absent in java)

	   Here, the abstract keyword is provided.



					     Shape
					     [   ]  public absrtact void area();
					       |
					       |
			-------------------------------------------------========================
			|			|			|			|
		      Rect		     Triangle 		     Circle		    Parabola
		      [   ] 		       [   ]		      [   ]		      [   ]	

		      area()	              area()		       area()		     area()		



class Shape
{
	public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

---------- Output on Run --------------
In Rect area()
In Circle area()
In Triangle area()
In Shape area()
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------

	Means it is not compulsory to define the area() method within class Parabola. Now lets define the 
	base class(Shape) method as abstract.

class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Circle area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

---------------- Output on compile --------------------------

DemoRuntimePoly4.java:1: error: Shape is not abstract and does not override abstract method area() in Shape
class Shape
^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------


	7. Note that when a class contains one or more abstract methods, the class must be declare ed as abstract.
	   and we are unable to create the object of abstract class. but it is possible to create its reference.
	   Abstract class can act as the base in class hierarchy.


abstract class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Circle area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//------------------------ output on compile -----------------------------

DemoRuntimePoly4.java:26: error: Parabola is not abstract and does not override abstract method area() in Shape
class Parabola extends Shape
^
1 error
Press any key to continue . . .

	Now this error due to, as class Parabola does not have defination of area(), it contains inherited abstract
	copy of area() method.

 if we declare  class Parabola as abstract, the we will get an error as

DemoRuntimePoly4.java:57: error: Parabola is abstract; cannot be instantiated
                ref=new Parabola ();
                    ^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------------------------

	8. Note that abstract method dont have body


abstract class Shape
{
	abstract public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Parabola findarea()");
	}
	public void area()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//----------------- On Compile ---------------------

DemoRuntimePoly4.java:4: error: abstract methods cannot have a body
        abstract public void area()
                             ^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

9. MEANS FINALY WE NEED TO DEFINE(OVERRIDE) THE area() METHOD IN CLASS Parabola.
	   i.e. NOW IT BECOME COMPULSORY, IF YOU WANT TO CREATE AN OBJECT OF CLASS Parabola.


abstract class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void area()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly5
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//--------------- output on compile -------------------
In Rect area()
In Circle area()
In Triangle area()
In Parabola area()
Press any key to continue . . .

//--------------------------------------------------------------------------------------------------------------

	// Some facts about the abstract keyword

	/// Using abstract keyword

	 The Keyword abstract used to declare  Abstract Class and Abstract Methods

	=> Abstract Class: 

	In Java, an abstract class is a class that cannot be instantiated on its own and is meant to be subclassed 
	by other classes. It serves as a blueprint for other classes, providing common functionality and structure. 	Abstract classes can have both abstract and concrete methods.

	Here are key characteristics of abstract classes in Java:

 	- It is decared as an abstract using abstract keyword.

		abstract class Demo
		{
			.......
		}

  	- Abstract class have atleast one abstract method, and child class must override the all abstract methods of 
	  base otherwise we need to declare the child class as abstract, and remember that we are not allowed to 
	  create the object of an abstract class. 

		abstract class Demo
		{
			abstract void show();
			.......
		}

  	- Abstract classes can also have regular (concrete) methods with a complete implementation

		abstract class Demo
		{
			abstract void show();
			public void display()
			{
			}
			.......
		}

  	- Abstract classes can have constructors, and they are called when a subclass object is created.

  	- Abstract classes can be used as a base class for other classes. Subclasses extend the abstract class 
	  and provide concrete implementations for the abstract methods.

  	- Abstract classes can have instance variables just like regular classes.


	abstract class Demo
	{
		private int x=10;
		public Demo()
		{
			System.out.println("\n In the Demo Class Constructor");
		}
		public void out()	
		{
			System.out.println("\n In out() method - x is "+x);
		}
		abstract void show();
	}
	class Test extends Demo
	{
		int y;
		public Test()
		{
			y=100;
			System.out.println("\n In child Test class Constructor");
		}
		public void show()
		{
			System.out.println("\n Hi from show() Test and y="+y);
		}
	}
	class DemoAbstractExample 
	{
		public static void main(String[] args) 
		{
			Test ob=new Test();
			ob.show();
			ob.out();
		}
	}

 	- The inner class can be declared abstract by declaring it local.
  	- A static method can be part of an abstract class.
  	- constructor can be part of an abstract class.
  	- When the final keyword is used, the abstract keyword cannot be used.
  	- Abstract methods cannot be declared private.
  	- Abstract methods cannot be declared static.
  	- An abstract keyword cannot be used with variables or constructors.

//========================================= Additional =============================================================

can abstract class contains inner class?

Yes, an abstract class in Java can contain an inner class. There are no restrictions that prevent an abstract class from having inner classes, whether they are regular (non-static) inner classes, static nested classes, or local/anonymous classes.

The inner class can serve as a helper or utility class for the outer abstract class.

Types of Inner Classes in Abstract Classes

1. Non-Static Inner Class
A non-static inner class is associated with an instance of the outer abstract class. It can access the instance variables and methods of the outer class, even if the class is abstract.


abstract class OuterAbstractClass {
    abstract void outerMethod();

    // Non-static inner class
    class InnerClass {
        void innerMethod() {
            System.out.println("Inner class method called");
        }
    }
}

class ConcreteClass extends OuterAbstractClass {
    void outerMethod() {
        System.out.println("Outer method implemented");
    }

    public static void main(String[] args) {
        ConcreteClass outer = new ConcreteClass();
        InnerClass inner = outer.new InnerClass();
        outer.outerMethod();
        inner.innerMethod();
    }
}

2. Static Nested Class
A static nested class is a static member of the abstract class. It does not depend on an instance of the outer class and can only access the static members of the outer class.

abstract class OuterAbstractClass {
    static void staticOuterMethod() {
        System.out.println("Static method of outer abstract class");
    }

    // Static nested class
    static class StaticNestedClass {
        void nestedMethod() {
            System.out.println("Static nested class method called");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        OuterAbstractClass.StaticNestedClass nested = new OuterAbstractClass.StaticNestedClass();
        nested.nestedMethod();
        OuterAbstractClass.staticOuterMethod();
    }
}

3. Local Inner Class
A local inner class is defined within a method of the abstract class. It can access the local variables of the method (if they are effectively final) and the members of the abstract class.

abstract class OuterAbstractClass {
    abstract void outerMethod();

    void methodWithLocalClass() {
        // Local inner class
        class LocalInnerClass {
            void localInnerMethod() {
                System.out.println("Local inner class method called");
            }
        }

        LocalInnerClass localInner = new LocalInnerClass();
        localInner.localInnerMethod();
    }
}

class ConcreteClass extends OuterAbstractClass {
    void outerMethod() {
        System.out.println("Outer method implemented");
    }

    public static void main(String[] args) {
        ConcreteClass obj = new ConcreteClass();
        obj.methodWithLocalClass();
    }
}

4. Anonymous Inner Class
An abstract class can also have an anonymous inner class. This is often used to provide an implementation for the abstract methods of the abstract class or its parent.


abstract class OuterAbstractClass {
    abstract void abstractMethod();

    void createAnonymousClass() {
        OuterAbstractClass anonymous = new OuterAbstractClass() {
            @Override
            void abstractMethod() {
                System.out.println("Abstract method implemented in anonymous inner class");
            }
        };

        anonymous.abstractMethod();
    }
}

public class Main {
    public static void main(String[] args) {
        OuterAbstractClass obj = new OuterAbstractClass() {
            @Override
            void abstractMethod() {
                System.out.println("Anonymous class implementation of abstract method");
            }
        };
        obj.abstractMethod();
    }
}
//===================================================================================================
//----------------------------------------------------------------------------------------------------

	 => Abstract method:

	In Java, an abstract method is a method that is declared without an implementation in an abstract class. An 
	abstract class is a class that cannot be instantiated on its own and may contain abstract methods, which are 
	meant to be implemented by concrete (non-abstract) subclasses. Abstract methods serve as a blueprint for 
	concrete classes to provide their own implementation.

	Here are the key points about abstract methods in Java:

  	- The abstract method declared as abstract using abstract keyword and it dont have body.

		i.e. abstract void dispay();

  	- When any method declared as abstract, the containing class must be declared as abstract.
	i.e.
		abstract class Test
		{
			abstract void display();
			....
		}
 
	- Subclasses that extend an abstract class must provide implementations for all the abstract methods declared 
	  in the superclass, otherwise you have to declare that class as abstract.

		abstract class Test
		{
			abstract void display();
			....
		}

		class Demo extends Test
		{
			.....
			public void dispay()
			{
				.....
			}
			....
		}

  	- Abstract methods provide a way to define a common interface for a group of related classes, ensuring that 
	  each concrete subclass provides its own implementation. This promotes code reusability and helps in 
	  creating a consistent interface for different classes.

 	key points about abstract classes and abstract methods in Java:
	
	Abstract Class:
	
	- An abstract class is a class that cannot be instantiated directly. It serves as a blueprint 
   	  for other classes to inherit from.
 	- Abstract classes may contain both abstract and concrete methods.
 	- Abstract classes are declared using the abstract keyword.
 	- Abstract classes can have constructors, fields, and regular methods, just like normal classes.
 	- Abstract classes can have access modifiers like public, protected, and private.
	  if class is
		public: To make the abstract class accessible to all classes.
		protected: To restrict access to the same package or subclasses.
		private: For use in nested abstract classes, fully encapsulating it within the enclosing class.
		Default (no modifier): To limit access to the package.

	Abstract Method:

 	- An abstract method is a method declared without an implementation (i.e., without a method body).
 	- Abstract methods are declared using the abstract keyword and must be contained within an abstract class.
 	- Abstract methods are meant to be implemented by subclasses. Subclasses must provide a concrete 
   	  implementation for all abstract methods unless they are also abstract classes.
 	- Subclasses that extend an abstract class with abstract methods must either provide concrete implementations 
   	  for all abstract methods or be declared as abstract themselves.

//---------------------------------------------------------------------------------------------------

	// Actual implementation of above example

abstract class Shape 
{
    // Abstract method declaration
    public abstract double area();

    // Concrete method
    public void display() 
	{
        System.out.println("This is a shape.");
    }
}

class Circle extends Shape
{
    private double radius;

    public Circle(double radius) 
    {
        this.radius = radius;
    }

    // Implementing the abstract method
    @Override
    public double area() 
    {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape 
{
    private double length;
    private double width;

    public Rectangle(double length, double width) 
    {
        this.length = length;
        this.width = width;
    }

    // Implementing the abstract method
    @Override
    public double area() 
    {
        return length * width;
    }
}

public class Main 
{
    public static void main(String[] args) 
    {
        Circle circle = new Circle(5);
        System.out.println("Area of circle: " + circle.area());

        Rectangle rectangle = new Rectangle(4, 6);
        System.out.println("Area of rectangle: " + rectangle.area());
    }
}

//--------------------------------------------------------------------------------------------------------------------

	// Casting in terms of class

Casting in terms of classes in Java refers to the process of converting an object of one type into another type within the class hierarchy. It is a way to tell the compiler how you want to treat a specific object at runtime. Casting is often used when working with inheritance and polymorphism.

Types of Casting in Java

- Upcasting (Implicit Casting):

Converts a subclass object into a superclass reference.
Always safe and does not require an explicit cast because the subclass contains all the properties and behaviors of the superclass.
Performed automatically by the compiler.
Example:

class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Animal animal = dog; // Upcasting
        animal.sound(); // Output: Dog barks (runtime polymorphism)
    }
}
Here, dog (a Dog object) is upcast to Animal.
The method sound() is called based on the runtime type (Dog), demonstrating polymorphism.

 - Downcasting (Explicit Casting):

Converts a superclass reference back to a subclass reference.
Requires an explicit cast because it can be unsafe.
The compiler allows it, but it throws a ClassCastException at runtime if the object is not actually of the target type.
Often used when you know the object is of a more specific type.
Example:

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // Upcasting
        Dog dog = (Dog) animal; // Downcasting
        dog.sound(); // Output: Dog barks
    }
}

	- Incorrect Downcasting:

public class Main {
    public static void main(String[] args) {
        Animal animal = new Animal();
        Dog dog = (Dog) animal; // Unsafe Downcasting
        dog.sound(); // Throws ClassCastException at runtime
    }
}
The Animal object is not a Dog, so the cast fails at runtime.

//---------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

	// Interface in Java

	An interface in Java is a reference type that defines a contract or a set of abstract methods that a 
	class must implement. 

	It acts as a blueprint for classes. Unlike a class, an interface can contain only:

	- Abstract methods (methods without a body; method declarations)(implicitly public and abstract).
	- Constant fields (implicitly public static final).
	- Static methods (with a body, introduced in Java 8).
	- Default methods (with a body, introduced in Java 8).
	- private and private static methods (with a body, introduced in Java 9).
	- Cannot have constructors, meaning interfaces cannot be instantiated.
	- A class can implement multiple interfaces, enabling multiple inheritance in Java.

	


	Decl. Syntax;

	interface <interface_name>	e.g.
	{					interface Demo
		<fields>;			{
		<methods>;				int DATA=100;
	};						void method1();
							static void method2(){
								System.out.println("In Static method of interface");
							}
							default void method3() {
							      System.out.println("In default implementation of method in interface");
							}
						}


	- Typically, interfaces are declared with public access modifiers to allow usage across different packages.
	- Follow naming conventions: Capitalize the first letter and use camel case (e.g., Animal, Drawable).
	- Fields in an interface are always public static final, even if you don't explicitly write it.
	- Abstract Methods: Declared without a body, they must be implemented by any class that implements the interface.
	- Default Methods: Have a method body and can provide a default implementation.
	- Static Methods: Belong to the interface and can be called without an instance.


	// A Class Implements an Interface

	A class that implements an interface must provide concrete implementations for all of its abstract methods 
	unless the class itself is abstract.

interface Demo
{
	void show();
}
class Sample implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
	}
}


//--------------------------------------------------------------------------

	// A class Extends class and implements an interface

	- To extend the class, extends keyword must be used.
	- To implement, implements keyword must be used

interface Demo
{
	void show();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
	}
}

//--------------------------------------------------------------------------

	// A class extends class and implements an interface multiple interfaces

interface Demo
{
	void show();
}
interface Example
{
	void present();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo, Example
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
	public void present() {
		System.out.println("In present - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
		ob.present();
	}
}

//-------------------------------------------------------------------------------

	// Note that As one class extends the another class, One interface also extends another interface.
	// and A class implements one or more interfaces.

interface Example
{
	void present();
}
interface Demo extends Example
{
	void show();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
	public void present() {
		System.out.println("In present - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
		ob.present();
	}
}

//-------------------------------------------------------------------------------------------

	// Knowing the facts when reference of base interface refers to object of child class.

	when a reference of a base interface refers to an object of a child class, it demonstrates the concept of 
	polymorphism. This is a fundamental object-oriented programming principle that allows a single interface 
	reference to be associated with different implementations dynamically (at runtime).

	In Such case we able to call only implemented methods from child.(methods present in same interface)

interface Demo 
{
	void show();
}

class Sample implements Demo
{
	public void show() {
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		Sample ob = new Sample();
		ob.show();
		ob.display();

		// -- Create the reference of interface(base) to refer object of class(child)

		Demo ref = new Sample();
		ref.show();
		ref.display();
		
	}
}

//----------- On Compile ------------
ClassImplInterface.java:28: error: cannot find symbol
                ref.display();
                   ^
  symbol:   method display()
  location: variable ref of type Demo
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

	/// Knowing the details about the members of interface

	// Interface fields

	fields in an interface behave differently from fields in a class. Interface fields are used to define 
	constants that are shared across all implementing classes. They are fundamentally different because they 
	are implicitly public, static, and final, regardless of how they are declared.

	 - public: Accessible everywhere.
	 - static: Belong to the interface, not to any instance of the implementing class.
	 - final: Cannot be modified once initialized (constant)

interface Constants {
    int MAX_VALUE=100;  // Implicitly public, static, and final
	// init. is compulsory even if you want to keep it zero.
}

class Example implements Constants {
    void printConstant() {
        System.out.println(MAX_VALUE); // Accessing the constant
    }
}

class InterfaceFieldsExample
{
	public static void main(String []args) {
		Example ob = new Example();
		ob.printConstant();
		System.out.println(Constants.MAX_VALUE);
		System.out.println(ob.MAX_VALUE);		
	}
}

	Note: 
	 - must init the interface fields, coz they are implicitly final, (even if they are static)
	 - As it is public and static by default, it can accessed using <interface_name>.<field_name>
	 - You can access it with in implementing class directly coz it is public in interface so it is inherited.
	 - using object of implementing class you can access it directly as <obj_nm>.<field_name>, coz it os public.


	// Advantages of Interface Fields

	 - Interface fields provide a mechanism to define constants that are globally accessible throughout 
	   the application.
	 - All implementing classes share the same constant values, reducing redundancy.
	 - Fields can be accessed directly via the interface name, making them convenient to use in different 
	   parts of the application.

	//  Limitations of Interface Fields
	 
	- Fields are final, meaning their values cannot be changed once initialized. This limits their use to 
	  constant values only.
	- Since fields are static, they are not associated with any instance of a class. They cannot hold 
	  instance-specific data.
	- Using an interface solely to define constants is often considered poor design because interfaces are 
	  intended to define behavior, not data. A better alternative is to use an enum or a utility class.


	// Alternatives to Interface Fields

	 - In Java, Enum can serve as an alternative to using fields in interfaces for defining a fixed set of 
	   constants. While interface fields are traditionally used for this purpose, using Enum is often a better 
	   and more robust approach. Enums are preferred when you need to define a set of constants with type safety.

	 - Constants can also be defined in a utility class with a private constructor to prevent instantiation.

	 - For more advanced and immutable constant configurations, you can use Java record(Java 14+).

	   record is a special type of class designed to represent immutable data. It is a concise way to define 
	   a class whose main purpose is to carry data, similar to Data Transfer Objects (DTOs) or value objects.

//-------------------------------------------

	// Methods within interface

	// Public and Abstract Methods (Pre-Java 8 and Onward)
	
	Abstract methods are the core of interfaces. They define behavior that any implementing class must provide.

	Characteristics:

	- Declared without a body.
	- Must be implemented by any concrete (non-abstract) class that implements the interface.
	- Implicitly public and abstract (you can omit these modifiers).

	Purpose: Abstract methods enforce a contract, ensuring that all implementing classes share a common behavior.

	interface Animal {
    		void eat();    // Abstract method
    		void sleep();  // Abstract method
	}

	class Dog implements Animal {

    		public void eat() {
        		System.out.println("Dog is eating");
    		}

    		public void sleep() {
        		System.out.println("Dog is sleeping");
    		}
	}
	class DemoFAIM
	{
		public static void main(String []args) {

			Dog ob = new Dog();
			ob.eat();
			ob.sleep();
		}
	}


///-------------------------------------

	// Implementing runtime polymorphism using interface

interface Shape
{
	 void area();
}
class Rect implements Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle implements Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle implements Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePolyusingInterface
{
	public static void main(String []args)
	{
		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

	}
}

/---------------------------------------------------------------------------------------------------------------------

	// Default Methods in Interface

	Default methods in Java interfaces were introduced in Java 8 to provide method implementations in interfaces. 
	Before Java 8, interfaces could only contain abstract methods, but default methods offer a way to add 
	functionality to interfaces without breaking the existing classes that implement them.

	- Default methods allow you to define a method body (implementation) in the interface itself.
	- Default methods enable adding new methods to existing interfaces without forcing the classes that 
	  implement them to modify their code.
	- Implementing classes can override default methods if a specific implementation is needed.
	- Default methods must always be public (implicit in interfaces). They cannot be private, protected, or static.
	- If a class implements multiple interfaces with the same default method name, the class must explicitly 
	  resolve the conflict.


interface MyInterface
{
	void show();
	default void displayMessage() {
		System.out.println("This is Default Message");
	}
}
class MyClass implements MyInterface
{
	public void show() {
		System.out.println("In MyClass show()");
	}
	public void display() {
		System.out.println("In MyClass display()");
	}
}
class YourClass implements MyInterface
{
	public void show() {
		System.out.println("In YourClass show()");
	}
	public void displayMessage() {
		System.out.println("This is Custom Message");
	}
}
class DemoDefaultInterfaceMethod 
{
	public static void main(String[] args) 
	{
		MyClass ob = new MyClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	
		System.out.println("\n ------------------------------------------");

		YourClass ob1 = new YourClass();
		ob1.show();
		ob1.displayMessage();
	}
}


//---------------------------------------------------
	
	// Multiple interface implementation having default method with same name

	If a class implements multiple interfaces with the same default method, the class must explicitly 
	resolve the conflict.

interface MyInterface
{
	void show();
	default void displayMessage() {
		System.out.println("This is Default Message - MyInterface");
	}
}
interface YourInterface
{
	void display();
	default void displayMessage() {
		System.out.println("This is Default Message - YourInterface");
	}
}
class CommanClass implements MyInterface, YourInterface
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
	public void displayMessage() {
		YourInterface.super.displayMessage();
		MyInterface.super.displayMessage();
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommanClass ob = new CommanClass();
		ob.show();
		ob.display();
		ob.displayMessage();
		ob.displayMessage();

	}
}

	// Error in case of conflict
	//  error: types MyInterface and YourInterface are incompatible;
	// class CommanClass inherits unrelated defaults for displayMessage() from types MyInterface and YourInterface

	Note: you cannot directly call A.super.greet() or B.super.greet() from the main method. 
	The super keyword is used to access a parent interface's or class's method from within the child 
	class that implements or extends it.

//------------------------------------------------------------------------

	// A class extends class and implements interface where class having show() method and interface
	// having default implementation of show() - Both acts as base of CommonClass class.

	--> In such case, no ambiguous condition, compiler gives priority to copy of show() via class.

class MyClass
{
	void show(){}
	public void displayMessage() {
		System.out.println("This is Default Message - Myclass");
	}
}
interface YourInterface
{
	void display();
	default void displayMessage() {
		System.out.println("This is Default Message - YourInterface");
	}
}
class CommonClass extends MyClass implements YourInterface 
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommonClass ob = new CommonClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	}
}


//-------------------------------------------------------------------------------

	// In case of class extends class and implements interface where a base having implementation of method,
	// and same method present in base interface(public and abstract), in such case, method implementation in
	// child is optional, and in such case, it will takes inherited copy of method from class as an implementation.


class MyClass
{
	void show(){}
	public void displayMessage() {
		System.out.println("This is Default Message - Myclass");
	}
}
interface YourInterface
{
	void display();
	void displayMessage();
}
class CommonClass extends MyClass implements YourInterface 
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommonClass ob = new CommonClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	}
}

//---------------------------------------------------------------------------------------------------------

	// Static methods in interfaces

	Static methods in interfaces were introduced in Java 8. Unlike instance methods or default methods, 
	static methods belong to the interface itself and are not inherited by implementing classes. They serve 
	utility-like functionality, similar to static methods in classes, but are specific to the interface.


	Characteristics of Static Methods in Interfaces

	- Static methods are part of the interface itself, not the implementing class.
	- They are called using the interface name, not the implementing class name or an object.
	- Implementing classes do not inherit static methods from the interface.
	- They cannot be overridden by the implementing classes.
	- Provide utility or helper methods related to the interface.
	- Avoid creating a separate utility class to hold such methods.
	- Static methods in interfaces are always public by default.
	- They cannot have any other access modifier (private, protected, or package-private).

interface MathOperations {

    static int add(int a, int b) {
        return a + b;
    }

    static int multiply(int a, int b) {
        return a * b;
    }
}

public class StaticMethodsInInterface {
    public static void main(String[] args) {

        // Calling static methods using the interface name
        System.out.println("Addition: " + MathOperations.add(5, 3));    // Output: 8
        System.out.println("Multiplication: " + MathOperations.multiply(5, 3)); // Output: 15
    }
}


	Static Methods vs Default Methods:
	-----------------------------------

	- Static methods belong to the interface and cannot be called on objects.
	- Default methods are instance methods and can be called on objects of the implementing class.

//---------------------------------------------------------------------------------------------------------

	// Private Methods in Interfaces (Java 9)

	Private methods in interfaces, introduced in Java 9, are designed to provide shared, reusable logic 
	within the interface. These methods are accessible only within the interface itself and are not 
	visible to implementing classes or other interfaces.
	
	- This avoids code duplication in default and static methods.
	- Private methods can only be called by default or static methods within the same interface.
	- They are not inherited by implementing classes.
	- Private methods in interfaces must have a body (implementation). They cannot be abstract.
	- Private methods can have two forms:
		- Instance-level private methods: Can be called from default method only.
		- Static private methods: Declared with static and invoked by static methods and default methods.


interface Greeting {
    // Default method using a private instance method
    default void sayHello() {
        System.out.println("Default sayHello method:");
        log("Hello from default method");
		logStatic("Hi from default method");
    }

    // Static method using a private static method
    static void sayHi() {
        System.out.println("Static sayHi method:");
        logStatic("Hi from static method");
		// log("Hello from default method"); // error: non-static method log(String) cannot be referenced from a static context
    }

    // Private instance method
    private void log(String message) {
        System.out.println("Logging: " + message);
    }

    // Private static method
    private static void logStatic(String message) {
        System.out.println("Logging (static): " + message);
    }
}

public class PrivateStaticMethods {
    public static void main(String[] args) {
        Greeting obj = new Greeting() {}; // Anonymous implementation of Greeting

        // Call the default method
        obj.sayHello();

        // Call the static method
        Greeting.sayHi();
    }
}
/-----------------------------------------------------------------------------------------------

	// Difference Between Class and Interface
	// Difference between abstract class and Interface.

//-----------------------------------------------------------------------------------------------
//======================================================================================================

	// Write a program to peform the stack by implementing given StackFormat interface.

interface StackFormat {
	void push(int);
	int pop();
}

//--------------
import java.util.Scanner;
interface StackFormat {
	void push(int t);
	int pop();
}
class MyStack implements StackFormat
{
	int []data = null;
	int top;

	public MyStack() {

		top=-1;
		data = new int[10];
	}

	public void push( int t) {

		top++;
		if(top>=data.length) {
			top--;
			System.out.println("Stack is Full");
		}
		else {
			data[top]=t;
			System.out.println("\n Data Insertation Sucessful...!!");
		}
	}

	public int pop() {

		if(top<0) {
			System.out.println("Stack is empty");
			return -1;
		}
		else
			return data[top--];
	}
}
class StackByInterface
{
	public static void main(String []args)
	{
		StackFormat stack = new MyStack();
		Scanner sc = new Scanner(System.in);
		int no, opt;
		while(true) {		
			System.out.println("\n ========== Menu ==========");
			System.out.println("\n 1.Push \n 2.Pop \n 3.Stop");
			System.out.println("\n Select your option: ");
			opt=sc.nextInt();
			switch(opt) {
				case 1:
					System.out.println("Enter any Number: ");
					no=sc.nextInt();
					stack.push(no);
					break;
				case 2:
					no=stack.pop();
					if(no!=-1)
						System.out.println("Poped No: "+no);
					break;
				default:
					System.out.println("\n Incorrect option: ");
			}
		}
	}
}

//----------------------------------------------------------------------------------------------------

	// Types of interfaces in java: 

	 - Basic Interface:
	 - Marker Interface:
	 - Functional Interface:


	1. Basic Interface: The Interface we have seen till Now.

//-----------------------------

	2. Marker Interface / Empty Interface / Tag Interface

	A Marker Interface is a special type of interface in Java that does not contain any methods 
	or fields. It is also known as a Tag Interface because its primary purpose is to act as a 
	tag or a marker to indicate a specific property or capability of a class implementing it.

	Marker interfaces convey metadata to the JVM or frameworks about a class's ability to perform
	specific actions (e.g., serialization, cloning, or remote access).
	  
	Frameworks or libraries can check at runtime if a class implements a marker interface and 
	apply specific logic accordingly.	

	Examples of Marker Interfaces in Java:

	1. Serializable: Classes implementing this interface can be serialized (converted into a byte 
	  stream) and deserialized.

	(Serialization: The process of converting a Java object into a byte stream so that it can be 
	 saved to a file, transmitted over a network, or stored in a database.)

	 (Deserialization: The process of converting a byte stream back into a Java object.)

	e.g.

	import java.io.Serializable;

	class Person implements Serializable {
   	 	private String name;
    		private int age;

    		// Constructor, getters, setters
	}

	2.Cloneable: Classes implementing this interface indicate that their objects can be cloned 
	  using the clone() method.
	 
	  (Object Cloning in Java is the process of creating an exact copy (or duplicate) of an object. 
	  This is typically done using the clone() method provided by the Object class.)


	class Person implements Cloneable {
    		private String name;

    		/// .....
	}

	3. Remote: Marks a class as capable of being invoked remotely in a Remote Method Invocation 
	   (RMI) application.

	 (Remote Method Invocation (RMI) is a Java API that allows an object on one Java Virtual Machine 
	  to invoke methods of an object on another JVM, typically over a network.)
	
	import java.rmi.Remote;
	public interface MyRemote extends Remote {
    		String sayHello() throws java.rmi.RemoteException;
	}

//--------------------------------------------------------------------------------------------

	- Functional Interface:

	A Functional Interface is an interface that contains exactly one abstract method. It can 
	have multiple default or static methods, but only one abstract method defines its primary 
	functionality. Functional interfaces enable the use of lambda expressions and method 
	references, making Java functional programming-friendly.

	Functional interfaces were introduced in Java 8, along with the java.util.function package, 
	which provides many built-in functional interfaces.

	// Consider Simple program

interface Calculator {
    int calculate(int a, int b);
}
class Example implements Calculator
{
	public int calculate(int a, int b) {
		return a + b;
	}
}

public class DemoFunctionalInterface {
    public static void main(String[] args) {

        Calculator add = new Example();

        System.out.println("Sum: " + add.calculate(5, 4)); 
    }
}

//----------------

	//  program using anonomous inner class (can also be written normally)

interface Calculator {
    int calculate(int a, int b);
}

public class DemoFunctionalInterface {
    public static void main(String[] args) {
        // Traditional implementation using anonymous class
        Calculator add = new Calculator() {

            public int calculate(int a, int b) {
                return a + b;
            }
        };

        System.out.println("Sum: " + add.calculate(5, 4)); 
    }
}

	// same programming Using the functional interface

interface Calculator {
    int calculate(int a, int b);
}

public class DemoFunctionalInterface {
    public static void main(String[] args) {
        // Using lambda expression
        Calculator add = (a, b) -> a + b;
        System.out.println("Sum: " + add.calculate(50, 40)); 
    }
}

//----------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------

	// Nested Interface 

	A nested interface is an interface that is declared inside another class, interface, or even 
	within another nested interface. Nested interfaces are primarily used for logically grouping 
	interfaces or to provide restricted access within a containing class or interface. They can 
	be declared as either static or non-static.

	class Outer {
    		interface NestedInterface {
        		void display();
    		}
	}

	or

	interface ParentInterface {
    		// Nested interface
    		interface ChildInterface {
        		void show();
    		}
	}


//======================================================================================================================

	// Packages in java


	A package in Java is a namespace that organizes a group of related classes and interfaces. It is essentially 
	a mechanism to bundle multiple classes, interfaces, and sub-packages together into a single unit. Packages 
	act as containers for classes and help avoid naming conflicts by providing a structured hierarchy. 
	
	For example, java.util is a package that contains utility classes like Scanner, ArrayList, HashMap, etc.

	- Packages can be classified into two categories:

		- Built-in Packages: These are pre-defined packages provided by Java (e.g., java.util, java.io).
		- User-defined Packages: These are custom packages created by developers to organize their code.


	Importance/Advantages of Packages in Java: Packages are critical to Java development for the following reasons:

	- Organization: They help in organizing classes and interfaces logically, making the codebase easier to 
	  understand and manage.
	- Reusability: Classes in a package can be reused across different projects or modules 
		       without reimplementation.
	- Avoiding Naming Conflicts: Packages prevent name clashes by providing unique namespaces for classes.
	- Access Control: Packages support access modifiers like protected and package-private (default), 
			  enabling fine-grained control over visibility.
	- Modularity: By grouping related classes and interfaces, packages promote modularity, making it easier 
		      to maintain and scale applications.


//-------------------------------------------------------------------------------------------------------------

	Types of Packages: 

	- Built-in Packages 

	Built-in packages in Java are pre-defined packages provided by the Java Development Kit (JDK) to simplify 
	development. These packages contain classes, interfaces, and methods that solve common programming tasks 
	like string manipulation, data structure handling, file I/O, networking, database connectivity, etc.


	Most Commonly Used Built-in Packages
	 Below is a list of commonly used built-in packages along with some of their popular classes and methods:

	1. java.lang (Automatically Imported): Contains classes fundamental to Java programming.

	Common Classes:
	 - String: Represents a sequence of characters.
		- Methods: length(), charAt(), substring(), equals()

	- Math: Provides mathematical operations.
		- Methods: abs(), sqrt(), pow(), random()

	- System: Provides system-related utilities.
		- Methods: currentTimeMillis(), gc(), exit()

	- Object: The root class of all Java classes.
		- Methods: toString(), equals(), hashCode(), clone()

	2. java.util: Provides utility classes like collections framework, date-time utilities, and more.

	Common Classes:
	- ArrayList: A resizable array implementation.
		- Methods: add(), get(), size(), remove()

	- HashMap: A key-value mapping data structure.
		- Methods: put(), get(), containsKey(), remove()

	- Date: Represents date and time.
		- Methods: getTime(), toString()

	- Random: Generates random numbers.
		- Methods: nextInt(), nextDouble()

	- Scanner: Represents the standard input stream		
		- Methods: nextInt(), nextDouble()


	3. java.io: Provides classes for input and output operations.

	Common Classes:
	- File: Represents a file or directory.
		- Methods: exists(), createNewFile(), delete(), length()

	- BufferedReader: Reads text from an input stream.
		- Methods: readLine(), close()

	- FileWriter: Writes text to files.
		- Methods: write(), flush(), close()


	4. java.net: Supports networking operations like URL processing and socket programming.

	Common Classes:
	- URL: Represents a Uniform Resource Locator.
		- Methods: openConnection(), getHost(), getPath()

	- Socket: Represents a client-side socket.
		- Methods: connect(), close()

	- HttpURLConnection: Handles HTTP connections.
		- Methods: connect(), getResponseCode()

	5. java.sql: Provides classes for database connectivity and SQL operations.

	Common Classes:
	- Connection: Represents a connection to a database.
		- Methods: createStatement(), close()

	- Statement: Executes SQL queries.
		- Methods: executeQuery(), executeUpdate()

	- ResultSet: Holds data returned by a query.
		- Methods: next(), getString(), close()

	6. java.time: Introduced in Java 8 for date and time operations.
	
	Common Classes:
	- LocalDate: Represents a date without time.
		- Methods: now(), plusDays(), getYear()

	- LocalTime: Represents a time without a date.
		- Methods: now(), plusHours(), getMinute()

	- LocalDateTime: Combines date and time.
		- Methods: now(), plusDays(), toLocalDate()



//---------------------------------------------------------------------------------------

  // Some examples using classes from built-in packages

	// Using java.lang.String

	public class StringExample {
    public static void main(String[] args) {
        // Create a String
        String greeting = "Hello, World!";

        // Find the length of the String
        System.out.println("Length: " + greeting.length());

        // Access a character at a specific index
        System.out.println("Character at index 7: " + greeting.charAt(7));

        // Convert the String to uppercase
        System.out.println("Uppercase: " + greeting.toUpperCase());

        // Check if the String contains a substring
        System.out.println("Contains 'World': " + greeting.contains("World"));

        // Replace a substring
        String newGreeting = greeting.replace("World", "Java");
        System.out.println("Replaced String: " + newGreeting);

        // Extract a substring
        String sub = greeting.substring(7, 12);
        System.out.println("Substring: " + sub);

        // Check if two strings are equal
        String anotherGreeting = "Hello, World!";
        System.out.println("Strings are equal: " + greeting.equals(anotherGreeting));
    }
}

//-------------------------------------------------------------------------

	// Using java.lang.Math class

public class MathExample {
    public static void main(String[] args) {
        // Find the maximum of two numbers
        int a = 10, b = 20;
        System.out.println("Maximum of " + a + " and " + b + ": " + Math.max(a, b));

        // Calculate the square root of a number
        double number = 25.0;
        System.out.println("Square root of " + number + ": " + Math.sqrt(number));

        // Generate a random number between 0 and 1
        double random = Math.random();
        System.out.println("Random number (0 to 1): " + random);

        // Raise a number to a power
        double base = 2, exponent = 3;
        System.out.println(base + " raised to the power of " + exponent + ": " + Math.pow(base, exponent));

        // Find the absolute value of a number
        int negativeNumber = -15;
        System.out.println("Absolute value of " + negativeNumber + ": " + Math.abs(negativeNumber));

        // Round a number to the nearest integer
        double decimalNumber = 4.6;
        System.out.println("Rounded value of " + decimalNumber + ": " + Math.round(decimalNumber));
    }
}

//-----------------------------------------------------------------------------------

	// Using java.util.Date Class

import java.util.Date;

public class DateExample {
    public static void main(String[] args) {
        // Create a Date object to represent the current date and time
        Date currentDate = new Date();
        System.out.println("Current Date and Time: " + currentDate);
    }
}

//-----------------------------------------------------------------------------------

	// Using java.time Classes

import java.time.*;
import java.time.format.DateTimeFormatter;

public class TimeExample {
    public static void main(String[] args) {
        // Get the current date
        LocalDate currentDate = LocalDate.now();
        System.out.println("Current Date: " + currentDate);

        // Get the current time
        LocalTime currentTime = LocalTime.now();
        System.out.println("Current Time: " + currentTime);

        // Get the current date and time
        LocalDateTime currentDateTime = LocalDateTime.now();
        System.out.println("Current Date and Time: " + currentDateTime);

        // Format the date and time
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss");
        String formattedDateTime = currentDateTime.format(formatter);
        System.out.println("Formatted Date and Time: " + formattedDateTime);

        // Add days to the current date
        LocalDate futureDate = currentDate.plusDays(10);
        System.out.println("Date After 10 Days: " + futureDate);

        // Subtract hours from the current time
        LocalTime pastTime = currentTime.minusHours(5);
        System.out.println("Time 5 Hours Ago: " + pastTime);
    }
}

//====================================================================================================================

//====================================================================================================================

	- User-defined packages: 

	In Java, user-defined packages are packages that are created by the programmer to group related classes, 
	interfaces, and sub-packages. Packages help in organizing the classes logically, making the program more 
	manageable, readable, and modular.

	To create a user-defined package, you use the package keyword followed by the package name at the beginning 
	of the Java source file.

	Steps to Create a User-Defined Package

	- Define the Package: The first step is to define the package at the top of your Java file using 
	  the package keyword.

	- Compile the Package: Compile the Java file to create a .class file for the class within the package.

	- Import the Package: To use the classes in the user-defined package in another program, import the 
	  package using the import statement. Use set classpath command to define from where the package should
	  be taken. 
		  e.g. 
			Y:\javapackageproject\mainapp>set classpath=.*;y:\javapackageproject;

	 (The class path is valid till curression of command prompt, if you want to set it permantently then
	  use Environment ariable.)

//--------------------------------------------------------------------------------------

	// Accessing different member from same class with different visibility

	i.e.

						private		default		protected	public
	//==============================================================================================
 	 same class				Yes		Yes		Yes		Yes

class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}

class DemoSameClassMembers
{
	public static void main(String []args)
	{
		Member ob =new Member();
		ob.display();
	}
}

 The final conclusion is that, you can access any member(private, default, protected, public) with in same class.

//-------------------------------------------------------------------------------------------------------------------

	
	// Accessing different member from same class(non-subclass) in same package with different visibility

	i.e.
					private		default		protected	public
	//==============================================================================================

  same package non-subclass		No		Yes		Yes		Yes


	using same example in different style

class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}

class DemoSameClassMembers
{
	public static void main(String []args)
	{
		Member ob =new Member();
		ob.display();

		//System.out.println("\n x="+ob.x); //error: x has private access in Member
		System.out.println("\n y="+ob.y+"\t z="+ob.z+"\t t="+ob.t);
	}
}


//---------------------------------

	another way: classes written in different files but in same package(folder)

// Package: c:\documents\....\demopack\Member.java
class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}


// Package: c:\documents\....\demopack\MainClass.java
class MainClass
{
	public static void main(String []args)
	{
		Member ob =new Member();
		ob.display();

		// System.out.println("\n x="+ob.x); //error: x has private access in Member
		System.out.println("\n y="+ob.y+"\t z="+ob.z+"\t t="+ob.t);
	}
}


	The final conclusion after ananysing the output of both, is that, you can access only member(default, 
	protected, and public) outside of package with directly using . operator, private member not accessed
	in a same package from different class.

//-----------------------------------------------------------------------------------------------------

	// Accessing different member from same class(subclass) in same package with different visibility

	In this case, there is no chane in the behaviour of private member, it is accessible with the
	class only, where it is defined.


					private		default		protected	public
//==============================================================================================

  same package subclass		No		Yes		Yes		Yes

  same package non-subclass		No		Yes		Yes		Yes

// Package: c:\documents\....\demopack\Member.java
class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}


// Package: c:\documents\....\demopack\MainClass.java
class MainClass extends Member
{
	public static void main(String []args)
	{
		Member ob =new Member();
		ob.display();

		// System.out.println("\n x="+ob.x); //error: x has private access in Member
		System.out.println("\n y="+ob.y+"\t z="+ob.z+"\t t="+ob.t);
	}
}

//--------------------------------------------------------------------------------------------------------------

	// Accessing different member from class(subclass) in different package with different visibility

					private		default		protected	public
//==============================================================================================

  Different package subclass		No		No		Yes		Yes

package dp;
// loction Y:\different\dp\Member.java
public class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}

import dp.Member;
// Location: y:\main\mp\MainClass.java
class Test extends Member
{
	public void showTest() {
		System.out.println("\n x="+x); //error: x has private access in Member
		System.out.println("\n y="+y);
		System.out.println("\n z="+z); //error: z is not public in Member; cannot be accessed from outside package
		System.out.println("\n t="+t);
	}
}
class MainClass 
{
	public static void main(String []args)
	{
		Member ob = new Member();
		ob.display();

		Test ob1 = new Test();
		ob1.showTest();

	}
}


//---------------- output on Compile ----------------

Y:\main\mp>javac MainClass.java
MainClass.java:7: error: x has private access in Member
                System.out.println("\n x="+x); //error: x has private access in Member
                                           ^
MainClass.java:9: error: z is not public in Member; cannot be accessed from outside package
                System.out.println("\n z="+z);
                                           ^
// In absence of public visibility of class Member(means in default visibility), class Member/ Member constructor / 
   display method of member, not accessible. Means default member not visible outside of Package.

// Which indicates that in case of different packages and subclass, only public and protected members are accessible.

//--------------------------------------------------------------------------------------------------------------------

	// Accessing different member from class(Non-subclass) in different package with different visibility
	
					private		default		protected	public
//==============================================================================================

  Different package non-subclass	No		No		No		Yes	

package dp;
// loction Y:\different\dp\Member.java
public class Member
{
	private int x;
	protected int y;
	int z; // default (package-private)
	public int t;
	public Member() {
		x=10;
		y=20;
		z=30;
		t=40;
	}
	public void display() {
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z+"\t t="+t);
	}
}

import dp.Member;
// Location: y:\main\mp\MainClass.java

class MainClass 
{
	public static void main(String []args)
	{
		Member ob = new Member();
		ob.display();

		System.out.println("\n x="+ob.x); //error: x has private access in Member
		System.out.println("\n y="+ob.y); // error: y has protected access in Member
		System.out.println("\n z="+ob.z); // error: z is not public in Member; cannot be accessed from outside package
		System.out.println("\n t="+ob.t);
	
	}
}

//------------ on compile ----------


Y:\main\mp>javac MainClass.java
MainClass.java:12: error: x has private access in Member
                System.out.println("\n x="+ob.x);
                                             ^
MainClass.java:13: error: y has protected access in Member
                System.out.println("\n y="+ob.y);
                                             ^
MainClass.java:14: error: z is not public in Member; cannot be accessed from outside package
                System.out.println("\n z="+ob.z);
                                             ^
3 errors


 // Which indicates that, in class non sub-class from different package, only public member is accessible
//  private. protected and default are not accessible.


//----------------------------------------------------------------------------------------------------------

	// Accessibility Table for Different Visibility Modifiers

//==============================================================================================
					private		default		protected	public
//==============================================================================================
  same class				Yes		Yes		Yes		Yes

  same package subclass		No		Yes		Yes		Yes

  same package non-subclass		No		Yes		Yes		Yes

  Different package subclass		No		No		Yes		Yes

  Different package non-subclass	No		No		No		Yes					

//==============================================================================================


	Why and When to Create Custom Packages in Java

	Creating custom packages in Java helps in organizing and managing large applications or libraries by 
	logically grouping related classes, interfaces, and sub-packages. It offers various benefits that improve 
	code maintainability, reusability, and readability.
	
	Here are the key reasons and scenarios when you should consider creating custom packages:

	1. Code Organization and Readability
	2. Avoiding Class Name Conflicts
	3. Code Reusability
	4. Access Control and Encapsulation
	5. Logical Grouping of Related Classes
	6. Dependency Management
	7. Scalability
	8. Separation of Concerns


	When to Create Custom Packages?

	- For Large Projects:
	- When Reusing Code:
	- When Working in Teams:
	- When Developing Libraries:
	- When You Need Access Control:

	Conclusion
	Creating custom packages in Java is a fundamental practice for code organization, maintainability, modularity, 
	and reusability. Packages help in avoiding conflicts, enhancing security, and managing code in large 
	applications. It's crucial to create custom packages when the project becomes complex, and logical grouping 
	of classes, interfaces, and sub-packages becomes necessary.


	Package Naming Conventions in Java

	In Java, package naming conventions are important for maintaining consistency, readability, and manageability 
	of code. Naming packages properly helps avoid conflicts, improves clarity, and ensures that the code is easily 
	navigable by other developers.

	Here are the general guidelines and best practices for naming packages in Java:

	1. Use Lowercase Letters

	Example:
		Correct: com.myapp.utilities
		Incorrect: com.MyApp.Utilities

	2. Use Reverse Domain Name Notation

	- If your company's domain is mycompany.com, you would start your package names with com.mycompany.

	3. Organize by Functionality or Modules

	Example:
	- com.myapp.model for classes representing data and business logic (e.g., User, Product).
	- com.myapp.controller for classes that handle the logic of the application (e.g., UserController, 
	  ProductController).
	- com.myapp.ui for user interface classes (e.g., LoginWindow, MainScreen).

	4. Avoid Using Reserved Keywords

	Example:
		Incorrect: com.myapp.int
		Correct: com.myapp.utils

	5. Use Meaningful and Descriptive Names

	Example:
	 - com.myapp.payment for payment-related classes.
	 - com.myapp.authentication for classes related to user authentication.
	 - com.myapp.logging for logging-related classes.

	6. Use Hyphens or Underscores Sparingly

	 Example:
		Correct: com.myapp.paymentprocessing
		Incorrect: com.myapp.payment-processing

	7. Limit Package Depth

	Recommended: Limit package depth to 3-4 levels.
		Example: com.myapp.services.payment
		Too deep: com.myapp.services.payment.gateway.processing

	8. Use Singular or Plural Naming Based on Context

	Example:
	 - Singular: com.myapp.customer for a package related to a customer entity.
	 - Plural: com.myapp.customers for a package managing a group of customers.

	9. Avoid Using Java Library Package Names

	Example:
		- Correct: com.myapp.mylibrary
		- Incorrect: java.myapp or org.myapp


	Introduction to Java Modules
	
	In Java, modules are a way to organize and manage large codebases, introduced in Java 9 with the Java 
	Platform Module System (JPMS). They provide a higher level of encapsulation, improved security, and 
	better dependency management compared to traditional Java packages.


	1. What is a Java Module?

	- A module is a collection of related packages, classes, and resources that can be compiled and deployed 
	  together. It defines which classes and resources are available to other modules and which are kept internal.

	- A module can be seen as a self-contained unit that encapsulates both the implementation (the code) and the 
	  API (the public interface) of a part of an application.

	2. Java Module Declaration:

	- A module is defined by a special file called module-info.java. This file is placed at the root of the module 
	  and declares the module's name, its dependencies, and which packages it exports or makes available 
	  to other modules.

	- This file is mandatory for a module. Without it, the code is simply a traditional Java application.

	//-----------------------------------------------------------------------------------------------------------

	Sealed Packages in Java: 

	- Sealed packages were introduced in Java 17 

	 - A sealed package is a concept that enables you to restrict the classes and interfaces that can be contained 
	   in a package, essentially limiting which packages or modules can add classes to it. This feature helps in 
	   providing more encapsulation and modularity.

	//------------------------------------------------------------------------------------------------------------------
	
	Third-party Package Management with Maven/Gradle

	In Java, managing third-party dependencies (external libraries or packages) is made easier with tools 
	like Maven and Gradle. These tools help automate the process of downloading, updating, and managing dependencies, 
	ensuring that the correct versions are used throughout the development process. Both Maven and Gradle are build 
	automation tools that support dependency management, but they operate in slightly different ways.

	1. Maven : Maven is a popular build automation tool that primarily uses an XML configuration file called pom.xml 
	   to manage dependencies, build configurations, and project details.

	2. Gradle: Gradle is a modern, flexible build automation tool that uses Groovy or Kotlin DSL for configuration. 
	   It offers more flexibility compared to Maven and is often used for both Java and non-Java projects.

//-----------------

 // Basic Questions
What is an interface in Java?
Why do we use interfaces?
Can an interface have method implementations?
What is the difference between an interface and an abstract class?
Can an interface extend another interface?

Intermediate Questions
What are functional interfaces?
Can we declare variables in an interface?
What happens if two interfaces have methods with the same signature?
What are marker interfaces?
How are multiple inheritance issues resolved in Java interfaces?
How can you use default methods to add functionality to existing interfaces without breaking their implementations?
What are the limitations of interfaces in Java?
What is the difference between static and default methods in interfaces?
Can a class implement multiple interfaces? Give an example.
What happens if a class implements two interfaces with default methods having the same signature?
Can a class inherit a default method from an interface but override it with an abstract method?
Can a class implement two interfaces that have static methods with the same name?
Explain the working of functional interfaces with a practical example. How do they interact with lambda expressions?
What is the difference between extends and implements in the context of interfaces?

//=======================================================================================================
//=======================================================================================================

	/// Java Errors and Exceptions: (Exception Handing in java)

	What is an Exception?

	In programming, an exception is an event that occurs during the execution of a program that disrupts its normal 
	flow. Exceptions are typically caused by runtime errors such as:

	- Invalid user input (e.g., trying to divide a number by zero)
	- File not found (e.g., attempting to open a file that doesn’t exist)
	- Network issues (e.g., failed server connection)
	- Out-of-bounds array access (e.g., trying to access an element beyond the array size)
	- In Java, exceptions are objects that represent these error conditions. They are part of the 
	  java.lang.Exception class hierarchy.


	What is Exception Handling?

	Exception handling is a mechanism in programming to handle runtime errors gracefully and 
	maintain the normal flow of a program. It involves detecting errors, taking corrective 
	action, and recovering from unexpected situations without crashing the program.

	In Java, exception handling is achieved using the following keywords:

	- try: Defines a block of code to monitor for exceptions.
	- catch: Handles the exception if one occurs in the try block.
	- finally: Contains code that executes regardless of whether an exception was thrown or not.
	- throw: Used to explicitly throw an exception.
	- throws: Declares exceptions that a method might throw.

	Advantages of Exception Handling

	- Prevents program crashes.
	- Simplifies debugging by clearly identifying the error cause.
	- Enhances code readability and maintainability.
	- Allows graceful recovery from unexpected situations.

	We Know the execution flow of java program


					     *.java
						|
						|
					     Compile
					     (javac)			=====> Errors, Checked Exception
						|
						|
					    Bytecode	
					    (*.class)
						|			
       						|			Compile	--> Error (Nornally syntax errors)	
				---------------------------------	============================================
				|		|		|	Interpretation --> Exceptions (Runtime Error)
			       JVM	       JVM	       JVM     	
  				|		|		|			 
			      Windows	      Linux	       Mac
				|		|		|
			 Native Code       Native Code    Native Code	=====> Exceptions (Unchecked Exception)
				|		|		|
			       Run	       Run             Run
				|		|		|
			     Output	     Output          Output



	In Java, there are two different places where the Errors may occured,

	Errors:  An error is the mistake in developing  program causes a unexpected output or 
		 we are unable to execute the program. 

		The error may of two types 
		 - Compile time errors:
 		 - Run time errors:

	Compile time errors: these are the syntax errors which are displayed by java compiler and therefore these are 
			     known as Compile time errors
	  e.g.	use of undeclared  variable
		bad reference to object
		missing semi comma
		misspelling of identifier and keyword
		missing/mismatching brackets in classes and methods

	Run time errors: some time the program may compile but gives error at the time of execution due to some mistakes 
			 at run time such errors are known as Run time errors.
		e.g.	divide an integer by zero.
			access an element that is out of bounds of an array.
			attempting to use a negative size for an array.


	These error are represented in form of classes in java

	- The compile time errors are generally known as errors and are represented using the class Error 
	  or any of its subclass.

	- The runtime errors are generally termed as exceptions and represented with the help of class Exception
	  or any one of its subclass.

	Both Error and Exception classes are the childs of Throwable and all are present in java.lang package.
	it hierarchy is as shown

				java.lang.Object
					|
					|
				java.lang.Throwable
					|
			------------------------------------------
			|					|
		java.lang.Error				java.lang.Exception
			├── AssertionError			├── IOException
			├── ExceptionInInitializerError		├── RuntimeException
			├── ExceptionInInitializerError		│   │    
			├── StackOverflowError			│   ├── NullPointerException
			├── OutOfMemoryError			│   ├── ArrayIndexOutOfBoundsException
			├── NoClassDefFoundError		│   ├── ClassCastException
			└── ...					│   └── ...
								├── SQLException
								├── ParseException
								├── ClassNotFoundException
								├── InterruptedException
								├── FileNotFoundException
								├── ArithmeticException
								└── ...


	What is effect of error or Exception on a program execution.

	 - If Error is in the program, we are unable to execute the code.
	 - If Exception is there in the program, the execution will be terminated abnormally. which may	
	   introduce the unexpected or random output or result. 

	Exceptions can be caught and handled by the program. When an exception occurs within a method, 
	it creates an object. This object is called the exception object. It contains information about the
	exception such as the name and description of the exception and state of the program when the 
	exception occurred.

	now focus on different types of exceptions in Java.

	Java Exception Types
	 - The exception hierarchy also has two branches: RuntimeException and IOException.

	 1. RuntimeException
		A runtime exception happens due to a programming error. They are also known as unchecked exceptions.
		These exceptions are not checked at compile-time but thery are checked at run-time. 

		Some of the common runtime exceptions are:

		 - Improper use of an API - IllegalArgumentException
	 	 - Null pointer access (missing the initialization of a variable) - NullPointerException
	  	 - Out-of-bounds array access - ArrayIndexOutOfBoundsException
		 - Dividing a number by 0 - ArithmeticException

	You can think about it in this way. “If it is a runtime exception, it is your fault”.
	- The NullPointerException would not have occurred if you had checked whether the variable was initialized or not 
	  before using it.
	- An ArrayIndexOutOfBoundsException would not have occurred if you tested the array index against the array
	  bounds.

	2. IOException
		An IOException is also known as a checked exception. They are checked by the compiler at the 
		compile-time and the programmer is prompted to handle these exceptions.

		Some of the examples of checked exceptions are:

		- Trying to open a file that doesn’t exist results in FileNotFoundException
		- Trying to read past the end of a file


	Java Exception Handling - Note that handling the exception means not eliminating it.
	
	We know that exceptions abnormally terminate the execution of a program, to avoid it, it is important to handle 
	exceptions. And it will allows us to take some corrective efforts.

	There are 5 different keywords provided to handle the exceptions. and these are 
	try, catch, finally, throw, and throws.



	try			try				try
	{			{				{
 	 .........		  ..........			}	
	}			}				catch(Exception e)
	catch(Exception e)	catch(XException e)		{
	{			{				}
 	 ---------		}				finally
	}			catch(YException e)		{
				{				}
				}
				catch(Exception e)
				{
				}
		


	try 					try
	{					{
     
	}					}
	catch (ExceptionType1 Ob) 		finally
	{					{
 	 					}
	}
	catch (ExceptionType2 Ob) 
	{
    
	}
	finally
	{
	}

 	Note:
	- Try can not be used alone. It must be used with catch block or finally block or both.
	- finally is optional
	- you are allowed to use multiple catch blocks but only one finally.
	- In case of multiple catch blocks, only one will be executed at a time if there will be exception.

//-------------------------------------------------------------------------------------

	Some programs with Errors:

	Errors are serious issues that usually arise from external circumstances or system-level problems. 
	These are represented by the Error class in Java and are generally not recoverable. Errors indicate 
	problems that a program should not attempt to handle (e.g., memory issues, JVM-related problems).

	// Use of un-decl. variable, missing ; , misspelling  of keyword

class ErrorExample 
{
	public static void main(String[] args) 
	{
		int x=10;
		flaot y=10.23f;	// error: cannot find symbol, class flaot
		System.out.println("x="+x) // error: ';' expected
		System.out.println("x="+t); //error: cannot find symbol, variable t
	}
}

//--------------------------

	// Error due to incompatible types

import java.io.BufferedReader;
import java.io.InputStreamReader;
class DemoIOException
{
	public static void main(String[] args) 
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		x=br.readLine();
		System.out.println("\n x="+x);
	}
}

 ---- On Compile ---- 
 DemoIOException.java:9: error: incompatible types: String cannot be converted to int
                x=br.readLine();
                             ^
1 error
Press any key to continue . . .

//------------------------

	// OutOfMemoryError: When the Java Virtual Machine (JVM) runs out of memory.
	
	An OutOfMemoryError in Java occurs when the Java Virtual Machine (JVM) cannot allocate more 
	memory for an object because it has run out of available memory. This error is part of the 
	java.lang package and typically indicates that your application needs more memory than what 
	is allocated or that there are memory management issues like memory leaks.

	Here are the common scenarios when OutOfMemoryError might occur:

	 - Heap Space Exhaustion( java.lang.OutOfMemoryError: Java heap space )
	 - PermGen Space Exhaustion (Pre-Java 8 - java.lang.OutOfMemoryError: PermGen space)
	 - Metaspace Exhaustion (Java 8 and later - java.lang.OutOfMemoryError: Metaspace) 
	 - Direct Buffer Memory Exhaustion (java.lang.OutOfMemoryError: Direct buffer memory)
	 - GC Overhead Limit Exceeded (java.lang.OutOfMemoryError: GC overhead limit exceeded)
	 - Unable to Create Native Thread (java.lang.OutOfMemoryError: Unable to create new native thread)


import java.util.ArrayList;
public class OutOfMemoryErrorExample {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        try {
            while (true) {
                list.add(1); // Continually adding elements
            }
        } catch (OutOfMemoryError e) {
            System.out.println("Error: Out of memory!");
        }
    }
}

//-----------------------
 -- After execution, wait for some sec, you will get ---

Error: Out of memory!

//------------------------------------------------------	

	// StackOverflowError: When the call stack size exceeds due to excessive recursion.

	A StackOverflowError in Java occurs when the application’s call stack exceeds its limit. 
	The call stack is a special memory area used to store method calls, local variables, and 
	other information related to active methods in a program. When the stack runs out of space, 
	the JVM throws a java.lang.StackOverflowError.
	
	The error typically results from excessive recursion or deep method call hierarchies. 
	Here's a breakdown of common causes:
	- Infinite Recursion
	- Excessive Recursion
	- Cyclic Method Calls
	- Deep Call Chains

public class StackOverflowErrorExample {
    public static void recursiveCall() {
        recursiveCall(); // Infinite recursion
    }

    public static void main(String[] args) {
        try {
            recursiveCall();
        } catch (StackOverflowError e) {
            System.out.println("Error: Stack overflow occurred!");
        }
    }
}
--- Output ---
Error: Stack overflow occurred!
Press any key to continue . . .

//-----------------------------------------------------------------------------------

	// LinkageError: When there is a problem with loading a class or dependent libraries.


	A LinkageError in Java is an error that occurs when the JVM encounters issues during the 
	linking phase of loading, linking, and initializing classes. This error typically arises 
	when there are inconsistencies or conflicts in the class definitions that the JVM tries
	to load. 
	
	LinkageError is a subclass of Error in the java.lang package, meaning it is a serious problem 
	that usually indicates a problem with the application’s environment, such as mismatched class 
	versions or corrupted binaries.

	- Class Definition Incompatibility
	- Conflicting Class Versions
	- Missing Dependencies

	Subclasses of LinkageError
	 - ClassCircularityError
	 - ClassFormatError
	 - NoClassDefFoundError
	 - UnsatisfiedLinkError
	 - VerifyError
	 - IncompatibleClassChangeError
		- NoSuchMethodError: A method called does not exist in the class.
		- NoSuchFieldError: A field accessed does not exist in the class.
	  	- IllegalAccessError: An attempt to access a class, method, or field that



 //-------------------------------------------------------------------------------------------------------------------
 //-------------------------------------------------------------------------------------------------------------------

	Some programs with Exceptions:

	Exceptions are events that disrupt the program's normal flow but can often be recovered. 
	Exceptions are represented by the Exception class and can be handled using try-catch blocks.

	When Exceptions Occur:

	 - Checked Exceptions: Occur at compile time and must be handled 
			       (e.g., IOException, SQLException).
	
	 - Unchecked Exceptions: Occur at runtime and can optionally be handled 
				(e.g., NullPointerException, ArithmeticException).

	// NullPointerException Example: Generated when the user not allocated memory for object, and
					 calling the method using that object reference.

public class NullPointerExceptionExample {
    public static void main(String[] args) {
        String text = null; // Null reference
        System.out.println(text.length()); // Attempt to access null
    }
}
 ------ On Execution - unchecked ---------
Exception in thread "main" java.lang.NullPointerException: Cannot invoke "String.length()" because "<local1>" is null
        at NullPointerExceptionExample.main(NullPointerExceptionExample.java:4)
Press any key to continue . . .


//-----------------

	FileNotFoundException Example: interduced when using file which is not present

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class FileNotFoundExceptionExample {
    public static void main(String[] args) {
       
            File file = new File("nonexistent.txt");
            Scanner scanner = new Scanner(file); // File doesn't exist
       
    }
}
 ------ On compile - checked ---------
FileNotFoundExceptionExample.java:9: error: unreported exception FileNotFoundException; must be caught or declared to be thrown
            Scanner scanner = new Scanner(file); 

//---------------------------------

	// Arithmetic Exception: when Divide by zero

public class ArithmeticExceptionExample {
    public static void main(String[] args) {
       
            int result = 10 / 0; // Division by zero
            System.out.println("Result: "+result);
    }
}

 ------ On Execution - unchecked ---------

Exception in thread "main" java.lang.ArithmeticException: / by zero
        at ArithmeticExceptionExample.main(ArithmeticExceptionExample.java:4)
Press any key to continue . . .

//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------

	What is Exception Handling?

	Exception handling is a programming construct that allows you to gracefully manage runtime errors (exceptions) 
	that disrupt the normal flow of a program. It enables you to "hit," "throw," "catch," and "handle" errors 
	systematically, ensuring the program doesn't crash unexpectedly.


	Key Terms in Exception Handling

	Hit:

	This is when an exception occurs during the program's execution, i.e., an error condition is "hit" or 
	encountered. Example: Trying to divide by zero or accessing an invalid array index.

	Throw:

	When an exception is detected, it is "thrown" to signal that an error has occurred.
	This is done using the throw keyword in Java or automatically by the JVM when a runtime exception occurs.

	Catch:

	Once an exception is thrown, it is "caught" by an appropriate catch block.
	A catch block is used to handle the exception and define what actions should be taken.

	Handle:
 
	Handling means providing a way to recover or gracefully terminate the program.
	This involves executing custom code to deal with the exception (e.g., logging errors, showing user-friendly 
	messages, or retrying operations).


	Exception Handling Workflow

	- Code is executed.
	- If an error is "hit," an exception is "thrown."
	- The program looks for a corresponding catch block to "catch" the exception.
	- The exception is "handled" by the catch block or propagated further if no matching handler exists.
	- In absence of proper handler, exception object is passed towards JVM, which will terminates the program

	Summary of Keywords in Exception Handling

      Keyword			Purpose
     --------------------------------------------------------------------------------------------
	try		Encapsulates code that might throw an exception.
	throw		Explicitly generates an exception.
	catch		Defines a block to catch and handle the thrown exception.
	finally		Executes code regardless of whether an exception was thrown or caught.
	throws		Declares exceptions a method might throw.

//----------------------------------------------------------------------------------------------------

	// Handling the checked exception - IOException

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x: ");
		try
		{
			x= Integer.parseInt(br.readLine());
		}
		catch (IOException ie)
		{
		}
		System.out.println("\n x="+x);
	}
}

/*
	----------- Without try-catch -----------------
	DemoIOException.java:9: error: unreported exception IOException; must be caught or declared to be thrown
                x= Integer.parseInt(br.readLine());
                                               ^
1 error

	NOTE: It is due to "throws clause" used while defining readline method in BufferedReader class.


	--------------- With try-catch or Using throws ------------------

	
 enter the value of x:
11

 x=11
Press any key to continue . . .

*/

//----------------------------------------------------------------------------------------------------------------------

	// Lets deal with the exception object collected in catch

	The readLine() method from the java.io.BufferedReader class can throw an IOException in the following 
	scenarios:
	
	1. Input/Output Failure
	2. Stream Closed
	3. Underlying Reader Fails
	4. File Deleted or Modified
	5. Exceeding Input Size Limits

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x: ");
		try
		{	
			br.close();
			x= Integer.parseInt(br.readLine()); // generates IOException coz attempting read after stream closed.
		}
		catch (IOException ie)
		{
			System.out.println("\n Exception is generated in the program..!!"); // Custom Message
		}
		System.out.println("\n x="+x);
	}
}

//-------------------------------------------------

	// Rather than custom message there are 3 different ways of getting information about Exception.

	- printing exception object directly.
	- using getMessage() 
	- using printStackTrace()


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x: ");
		try
		{	
			br.close();
			x= Integer.parseInt(br.readLine());
		}
		catch (IOException e)
		{
			System.out.println("\n Exception is generated in the program..!!"); // Custom Message
			System.out.println("\n ---------------------------------------------------------------\n");
			System.out.println("\n printing exception object: "+e);
			System.out.println("\n ---------------------------------------------------------------\n");
			System.out.println("\n Exception Message: "+e.getMessage());
			System.out.println("\n ---------------------------------------------------------------\n");
			System.out.println("\n Exception stack Trace: ");
			e.printStackTrace();
		}
		System.out.println("\n x="+x);
	}
}

------------------------ On execution -------------


 enter the value of x:

 Exception is generated in the program..!!

 ---------------------------------------------------------------


 printing exception object: java.io.IOException: Stream closed

 ---------------------------------------------------------------


 Exception Message: Stream closed

 ---------------------------------------------------------------


 Exception stack Trace:
java.io.IOException: Stream closed
        at java.base/java.io.BufferedReader.ensureOpen(BufferedReader.java:121)
        at java.base/java.io.BufferedReader.implReadLine(BufferedReader.java:362)
        at java.base/java.io.BufferedReader.readLine(BufferedReader.java:347)
        at java.base/java.io.BufferedReader.readLine(BufferedReader.java:436)
        at DemoIOException.main(DemoIOException.java:14)

 x=0
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------------

	// Using Multiple Catch statements:


	- Why multiple catch blocks: 

	Using multiple catch blocks in Java allows you to handle different types of exceptions differently. This approach
	ensures that each exception type is treated appropriately, making the code more robust and maintainable.

	Key Reasons for Using Multiple Catch Blocks
	- Different Handling for Different Exceptions
	- Improved Readability and Debugging
	- Avoid Catching Unnecessary Exceptions
	- More Specific Exception Handling
	- Extending Functionality Without Changing Existing Code

	// lets reexecute the same code without br.close(), and input char rather than int value
	
	
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x: ");
		try
		{	
			x= Integer.parseInt(br.readLine());
		}
		catch (IOException e)
		{
			System.out.println("\n Exception is generated in the program..!!"); 
		}
		System.out.println("\n x="+x);
	}
}

-------- On execution --------


 enter the value of x:
q
Exception in thread "main" java.lang.NumberFormatException: For input string: "q"
        at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)
        at java.base/java.lang.Integer.parseInt(Integer.java:588)
        at java.base/java.lang.Integer.parseInt(Integer.java:685)
        at DemoIOException.main(DemoIOException.java:14)
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------

	 // again suppose we changed the program and now it may be capable of generating any other exception.
	//  to deal with such unexpected exception always use additional catch at end with Execption class reference
	 // coz Exception class is in the top hierarchy, and we knw reference of base able to any of its child object.


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0,y=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x and y: ");
		try
		{	
			x= Integer.parseInt(br.readLine());
			y= Integer.parseInt(br.readLine());
			double z=x/y;
		}
		catch (IOException e)
		{
			System.out.println("\n Exception due to stream problem"); 
		}
		catch (NumberFormatException e)
		{
			System.out.println("\n Exception due non-numeric input"); 
		}
		catch (Exception e)
		{
			System.out.println("\n Exception: "+e.getMessage()); 
		}
		System.out.println("\n x="+x);
	}
}

//-------------------------------------------------------------------------------------------------------

	/// Using finally Block: 
	
	What is the finally Block in Java?
	The finally block in Java is an optional part of the try-catch-finally construct. It is used to define 
	a block of code that will always execute after the try block, regardless of whether an exception was 
	thrown or caught. The finally block ensures that important cleanup operations are performed.


	
	What is the finally Block in Java?
	The finally block in Java is an optional part of the try-catch-finally construct. It is used to define a 
	block of code that will always execute after the try block, regardless of whether an exception was thrown 
	or caught. The finally block ensures that important cleanup operations are performed.

	Key Characteristics
	- Always Executes:
	  The finally block executes whether or not an exception is thrown in the try block.
	  - If no exception is thrown, the finally block runs after the try block.
	  - If an exception is thrown and caught, the finally block runs after the catch block.

	- Cannot Be Bypassed:
	  The finally block executes even if the try or catch block contains a return, break, or continue statement. 
	  However, it can be bypassed in some extreme cases, such as:
	  - When the JVM exits (System.exit()).
	  - When a thread is terminated or killed.

	- Cleanup Operations:
	  The primary purpose of the finally block is to release resources or perform cleanup tasks, such as closing 
	  files, releasing database connections, or closing sockets.

	- Optional:
	  It is optional in try-catch


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
class DemoIOException
{
	public static void main(String[] args)  
	{
		int x=0,y=0;
		BufferedReader br = new BufferedReader( new InputStreamReader(System.in));
		System.out.println("\n enter the value of x and y: ");
		try
		{	
			x= Integer.parseInt(br.readLine());
			y= Integer.parseInt(br.readLine());
			double z=x/y;
		}
		catch (IOException e)
		{
			System.out.println("\n Exception due to stream problem"); 
		}
		catch (NumberFormatException e)
		{
			System.out.println("\n Exception due non-numeric input"); 
		}
		catch (Exception e)
		{
			System.out.println("\n Exception: "+e.getMessage()); 
		}
		finally 
		{
			System.out.println("\n In the finally block"); 
		}
		System.out.println("\n x="+x);
	}
}


//-----------------------------------

	// What is Try-With-Resources in Java? (When to Avoid the finally Block)

	The try-with-resources statement is a feature introduced in Java 7 that simplifies resource management.
	It ensures that resources (e.g., files, database connections, sockets) are closed automatically when 
	they are no longer needed. This eliminates the need for a finally block to explicitly close resources.

	The resources used in a try-with-resources statement must implement the AutoCloseable 
	interface (or its subtype Closeable).

	try (ResourceType resource = new ResourceType()) 
	{
    		// Code that uses the resource
	} 
	catch (ExceptionType e) 
	{
    		// Handle exceptions
	}

 // Custom program 
class Demo implements AutoCloseable 
{
	public void close() {
		System.out.println("Resource Closed");
	}
}
class DemoAC 
{
	public static void main(String[] args) 
	{
		System.out.println("start");
		try(Demo ob = new Demo())
		{
			
		}
		catch (Exception e)
		{
			System.out.println("In catch");
		}
		System.out.println("End");
	}
}

///--------------

	// As BufferedReader implements AutoCloseable can be used in Try-With-Resources as

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        String line;
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)) ) {
            System.out.println("Enter any line: ");
            line = reader.readLine();
            System.out.println(line);
        } catch (IOException e) {
            System.out.println("An error occurred: " + e.getMessage());
        }
    }
}
 
    // The BufferedReader automatically closes at the end of the try block, even if an exception occurs.

   

  // ----------------------------------

	Lets demonstrate the exact use..

class MyStream implements AutoCloseable
{
    public void close() {
        System.out.println("Stream Closed Sucessfully");
    }
}
public class Main {
    public static void main(String[] args) {
        
        try (MyStream stream = new MyStream() ) {
            
        } catch(Exception e) {
            
        }
    }
}
 
   
//--------------------------------------------------------------------------------------------------------

	// Knowing some other exceptions 

	// ArithmeticException 

import java.util.Scanner;
class Main
{
	public static void main(String []args)
	{
		int x=0,y=0;
		double ans=0.0;

		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the values of x and y: ");
		try {
		    
		    x=sc.nextInt();
	    	    y=sc.nextInt();
		    ans=x/y;
		    
		} catch(ArithmeticException e) {
		    System.out.println("Exception: "+e.getMessage());
		}catch(Exception e) {
		    System.out.println("Exception: "+e);
		}

		System.out.println("ans: "+ans);
	}
}

///-----------------------------------------------------------------------------

	// ArrayIndexOutOfBoundsException


import java.util.Scanner;
class Main
{
    public static void main(String []args)
    {
        Scanner sc = new Scanner(System.in);
        // int x[]=new int[-5]; // Exception in thread "main" java.lang.NegativeArraySizeException: -5
        int x[]=new int[-5];
        System.out.println("Enter the array elements");
        for(int i=0;i<x.length;i++)
        {
            x[i]=sc.nextInt();
        }
        
        System.out.println("Enter the array elements: ");
        for(int i=0;i<x.length;i++)
        {
            System.out.println(" "+x[i]);
        }
        
      //  System.out.println("x[-2]: "+x[-2]); // Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException
        System.out.println("x[3]: "+x[3]); 
     // System.out.println("x[7]: "+x[7]);  // // Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException
    }
}
//-------------------------------------

	// NullPointerException

import java.util.Scanner;
class Main
{
    public static void main(String []args)
    {
        String str=null;
        System.out.println("\n String Length: "+str.length()); //Exception in thread "main" java.lang.NullPointerException
 
    }
}
//--------------------------------------------------------------------------------------------------------

	//  Types of Exceptions in Java and Their Reasons

	In Java, exceptions are broadly classified into checked exceptions, unchecked exceptions, and errors. 
	Here's a list of common exceptions in each category and their causes:

	- IOException: Issues with input/output operations (e.g., file not found, unable to read/write).
	- FileNotFoundException: Trying to access a file that does not exist.
	- SQLException: Issues while interacting with a database (e.g., connection failure, invalid SQL query).
	- ClassNotFoundException: Trying to load a class that is not found in the classpath.
	- InterruptedException: A thread is interrupted while it is in a sleeping or waiting state.
	- MalformedURLException: An invalid URL is provided.
	- CloneNotSupportedException: Attempting to clone an object that does not implement the Cloneable interface.

	- NullPointerException: Attempting to access an object or call a method on a null reference.
	- ArrayIndexOutOfBoundsException: Accessing an array element with an index outside its valid range.
	- ArithmeticException: Performing an illegal arithmetic operation (e.g., division by zero).
	- ClassCastException: Invalid type casting of objects.
	- IllegalArgumentException: Passing an invalid argument to a method.
	- NumberFormatException: Converting a string to a number when the string is not in a valid format (e.g., parsing "abc" as an integer).
	- StringIndexOutOfBoundsException: Accessing characters in a string with an invalid index.
	- UnsupportedOperationException: An unsupported operation is invoked on a collection or other object.


//----------------------------------------------------------------------------------------------------------

	// Nesting of Try-Catch Block

	Nesting of try-catch blocks in Java refers to placing one try-catch block inside another. This 
	approach is useful when you need to handle exceptions for different parts of the code separately.    

public class Main 
{
    public static void main(String[] args) 
    {
        try 
        {
            // Outer try block
            int[] numbers = {1, 2, 3};
            System.out.println("Outer try block starts.");

            try 
            {
                // Inner try block
                int result = 10 / 0; // This will throw ArithmeticException
                System.out.println("Result: " + result);
            } 
            catch (ArithmeticException e) 
            {
                System.out.println("Inner catch: ArithmeticException caught!");
            }

            // This code executes after inner try-catch block
            System.out.println("Accessing an array element: " + numbers[5]); // ArrayIndexOutOfBoundsException
        } 
        catch (ArrayIndexOutOfBoundsException e) 
        {
            System.out.println("Outer catch: ArrayIndexOutOfBoundsException caught!");
        }

        System.out.println("Program continues...");
    }
}
             
//---------------------------------------------------------------------------------------------
	// Try to find output


public class MainEx1
{
    public static void main(String[] args) 
    {
        try 
        {
            // Outer try block
            int[] numbers = {1, 2, 3};
            System.out.println("Outer try block starts.");

            try 
            {
                // Inner try block
                int result = 10 / 0; // This will throw ArithmeticException
                System.out.println("Result: " + result);
            } 
            catch (NullPointerException e) 
            {
                System.out.println("Inner catch: ArithmeticException caught!");
            }

            // This code executes after inner try-catch block
            System.out.println("Accessing an array element: " + numbers[5]); // ArrayIndexOutOfBoundsException
        } 
        catch (ArrayIndexOutOfBoundsException e) 
        {
            System.out.println("Outer catch: ArrayIndexOutOfBoundsException caught!");
        }            
	catch (Exception e) 
        {
                System.out.println("Exception caught!");
        }

        System.out.println("Program continues...");
    }
}

//----------------------------------------------------------------------------------------------

	// Handling Exception from the another class

	When you are calling the any one of method from a class, using its object, and suppose that
	method having the unhandled exception then that can be / must be handled while calling the method 

	- must be: for that user must know this 

class MyMath
{
	private int x;
	private int y;
	public void input() {
		x=5;
		y=0;
	}
	public void div() {
	    int z=0;
		try{ z=x/y; }catch(NullPointerException e){System.out.print("\n exception in MyMath: "+e);}
		System.out.print("\n Ans: "+z);
	}
} 

class Main
{
	public static void main(String []args)
	{
		MyMath ob = new MyMath();
		ob.input();
		
		try{ ob.div(); }catch(Exception e){System.out.print("\n exception in Main: "+e);}
	}
}


//------------------------------------------------------------------

	// Using throws keyword:

	The throws keyword in Java is used to declare exceptions that a method might throw during its 
	execution. It indicates to the caller of the method that they must handle or further propagate the 
	specified exceptions.

	- It is used in the method signature to declare one or more exceptions that might occur.
	- It is mandatory to declare checked exceptions in the throws clause if a method can throw them and 
	  does not handle them internally.
	- Checked exceptions must be either caught using a try-catch block or declared using the throws keyword.
	- Unchecked exceptions can be thrown by methods but do not need to be declared using throws. This is optional.

	In above case, you must know that the method contains the unhandled Exception, so we have to 
	it from try-catch. To inform such behaviour of method the throws keyword is used.

	so the same program can be written as..

class MyMath
{
	private int x;
	private int y;
	public void input() {
		x=5;
		y=0;
	}
	public void div() throws ArithmeticException {
	    int z=0;
		try{ z=x/y; }catch(NullPointerException e){System.out.print("\n exception in MyMath: "+e);}
		System.out.print("\n Ans: "+z);
	}
} 

class Main
{
	public static void main(String []args)
	{
		MyMath ob = new MyMath();
		ob.input();
		
		 ob.div();
		 
		//try{ ob.div(); }catch(Exception e){System.out.print("\n exception in Main: "+e);}
	}
}

	But the program continues to generate an exception, evenif throws clause is written, coz throws clause
	will not eliminates the exception, it just informs to caller, so it is responsibility of caller that
	he has to call it from try.

	 - It is not compulsory to call till the method is not throwing checked exception,

	lets see,

import java.io.IOException;
class MyMath
{
	private int x;
	private int y;
	public void input() {
		x=5;
		y=0;
	}
	public void div() throws ArithmeticException, IOException {
	    int z=0;
		try{ z=x/y; }catch(NullPointerException e){System.out.print("\n exception in MyMath: "+e);}
		System.out.print("\n Ans: "+z);
	}
} 

class Main
{
	public static void main(String []args)
	{
		MyMath ob = new MyMath();
		ob.input();
		
		// ob.div(); // error: unreported exception IOException; must be caught or declared to be thrown
		 
		//try{ ob.div(); }catch(Exception e){System.out.print("\n exception in Main: "+e);}
	}
}

//----------------------------------------------------------------------------------------------------------------

	// Using throw keyword

	The throw keyword in Java is used to explicitly throw an exception from within a method or block of 
	code. It enables developers to generate exceptions either to signal an error condition or to propagate 
	an existing exception.

	// lets write code to submit form, and continue the taking information till the age in within the
	// age window of 18 to 25. otherwise terminate the execution by displaying the message.


import java.util.Scanner;
class Form
{
	private String name;
	private int age;
	private int id;
	private double marks;
	public void input() throws ArithmeticException
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();
		if(age<18 || age>25)
			throw new ArithmeticException("Age is not within age window");
		System.out.println("Enter the id: ");
		id=sc.nextInt();

		System.out.println("Enter the marks: ");
		marks=sc.nextDouble();
	}
	void display()
	{
		System.out.println("Info: Name: "+name+"\t id: "+id+"\t age: "+age+"\t marks: "+marks);
	}
}

class Main
{
	public static void main(String []args)
	{
		Form f=new Form();
		try 
		{
			f.input();
			f.display();
		} 
		catch(Exception e) 
		{
		    System.out.println("Info:"+e);
		    System.out.println("Info:"+e.getMessage());
		}
		System.out.println("End of program");
	}
}

//------------------------------

	// Which Exception class should be choosen...!!

	- if you want to check it at compile time use IOException or any its sub-class.
	- rather that that it become runtime (unchecked)

import java.util.Scanner;
import java.io.IOException;
class Form
{
	private String name;
	private int age;
	private int id;
	private double marks;
	public void input() throws IOException,ArithmeticException
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();
		if(age<18 || age>25)
		{
			throw new ArithmeticException("Age is not within age window"); 
			// As it is unchecked exception, will compile sucessfully but generate the exception when age is not within age window
			
			// throw new IOException("Age is not within age window"); 
			// As it is checked exception it will asking for exception handling at the time of compilation
		}
		System.out.println("Enter the id: ");
		id=sc.nextInt();

		System.out.println("Enter the marks: ");
		marks=sc.nextDouble();
	}
	void display()
	{
		System.out.println("Info: Name: "+name+"\t id: "+id+"\t age: "+age+"\t marks: "+marks);
	}
}

class Main
{
	public static void main(String []args)
	{
		Form f=new Form();
		try 
		{
			f.input();
			f.display();
		} 
		catch(Exception e) 
		{
		    System.out.println("Info:"+e);
		}
		System.out.println("End of program");
	}
}

//--------------------------------------------------------------------------------------------------------------------

	// Classification OF Exception by Purpose

	- Built-in Exceptions
	  - Predefined exceptions provided by Java.
	  - Examples: NullPointerException, ArrayStoreException, ClassCastException.

	- User-defined Exceptions
	  - Custom exceptions created by extending the Exception or RuntimeException class.
	  - Example:

		class CustomException extends Exception {
		    public CustomException(String message) {
		        super(message);
		    }
		}

	User-defined exceptions in Java are custom exceptions that developers create to represent specific conditions 
	or errors unique to an application. These exceptions are useful when the built-in exceptions in Java are not 
	sufficient to describe an application-specific problem.

	Steps to Create and Use User-defined Exceptions

	- Define the Exception Class
	  - Extend the Exception class for checked exceptions.
	  - Extend the RuntimeException class for unchecked exceptions.
	  - Provide constructors to initialize the exception object, optionally passing error messages 
	    or other details.
	- Throw the Exception: Use the throw keyword to explicitly throw the custom exception in your code.
	- Handle the Exception: Catch the exception using a try-catch block or propagate it using the throws keyword.

import java.util.Scanner;
import java.io.IOException;

// User-defined Exception class
class AgeException extends Exception
{
	private String exmsg;
	public AgeException(String msg)
	{
		super(msg);
		exmsg=msg;
	}
	public String toString()
	{
		return "Exception Message: "+exmsg;
	}
}
class Form
{
	private String name;
	private int age;
	private int id;
	private double marks;
	public void input() throws Exception
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();
		if(age<18 || age>25)
		{
			throw new AgeException ("Age is not within age window"); 
		}
		System.out.println("Enter the id: ");
		id=sc.nextInt();

		System.out.println("Enter the marks: ");
		marks=sc.nextDouble();
	}
	void display()
	{
		System.out.println("Info: Name: "+name+"\t id: "+id+"\t age: "+age+"\t marks: "+marks);
	}
}

class Main
{
	public static void main(String []args)
	{
		Form f=new Form();
		try 
		{
			f.input();
			f.display();
		} 
		catch(Exception e) 
		{
		    System.out.println("Info:"+e.getMessage());
		    System.out.println("\n ---------------------------------------------");
		    System.out.println("Info:"+e);
		    System.out.println("\n ---------------------------------------------");
		    System.out.println("Info:");
			e.printStackTrace();
		}
		System.out.println("End of program");
	}
}

//---------------------------------------------------------------------------------------------------------------------------

	// Some practic exampes of userdefined exceptions

Example 1: In this example, we have created a custom exception class NegativeBalanceException, which extends Exception, as well as a class BankAccount, which includes a withdrawal method. If the balance is less than the amount withdrawn, an instance of NegativeBalanceException with an error message is thrown. The exception is then caught and the error message is printed in the main method.

class NegativeBalanceException extends Exception 
{
    	public NegativeBalanceException(String message) 
	{
        	super(message);
    	}
}
class BankAccount 
{
	private double balance;
    	public BankAccount(double balance) 
	{
        	this.balance = balance;
    	}
    	public double getBalance()
	{
        	return balance;
    	}
	public void withdraw(double amount) throws NegativeBalanceException 
	{
        	if (balance - amount < 0) 
		{
            		throw new NegativeBalanceException("Insufficient funds to withdraw " + amount + " rs.");
        	} 
		else 
		{
            		balance -= amount;
        	}
    	}
}
class Main 
{
	public static void main(String[] args) 
	{
        	BankAccount ba = new BankAccount(100);
        	try 
		{
            		ba.withdraw(200);
        	} 
		catch (NegativeBalanceException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

        	System.out.println("Remaining balance: " + ba.getBalance());
    	}
}

//----------------------------------------------------------------------------------------------------------------

// Example 2: User Defined exception in java for Validating Login Credentials

class InvalidCredentialsException extends Exception 
{
    	public InvalidCredentialsException(String message) 
	{
        	super(message);
    	}
}

class Login 
{
    	private String username;
    	private String password;

   	public Login(String username, String password) throws InvalidCredentialsException 
	{
        	if (username == null || username.isEmpty()) 
		{
            		throw new InvalidCredentialsException("Username cannot be null or empty.");
        	}

        	if (password == null || password.isEmpty()) 
		{
            		throw new InvalidCredentialsException("Password cannot be null or empty.");
        	}

        	this.username = username;
        	this.password = password;
    	}

    	public boolean validate()
	{
        	// Check the username and password against a database or other sources
        	return true;
    	}
}

class MainLoginApplication 
{
    	public static void main(String[] args) 
	{
        	try 
		{
            		Login login = new Login("", "password");
       	 	} 
		catch (InvalidCredentialsException ex) 
		{
            		System.out.println(ex.getMessage());
       		}

		//-----------------

       		try 
		{
        		Login login = new Login("username", "");
        	} 
		catch (InvalidCredentialsException ex) 
		{
            		System.out.println(ex.getMessage());
        	}
		
		//-----------------

        	try 
		{
            		Login login = new Login("username", "password");
           		if (login.validate()) 
			{
                		System.out.println("Login successful.");
           		} 
			else 
			{
                		System.out.println("Login failed.");
            		}
        	} 
		catch (InvalidCredentialsException ex) 
		{
            		System.out.println(ex.getMessage());
        	}
    	}
}

//------------------------------------------------------------------------------------------------

	// Example 3: User Defined exception in java for Validity of an Entity

class InvalidEntityException extends Exception 
{
	public InvalidEntityException(String message) 
	{
        	super(message);
    	}
}

class Entity 
{
	private String name;
    	private int age;

    	public Entity(String name, int age) throws InvalidEntityException 
	{
        	if (name == null || name.isEmpty()) 
		{
            		throw new InvalidEntityException("Name cannot be null or empty.");
        	}

        	if (age < 0) 
		{
            		throw new InvalidEntityException("Age cannot be negative.");
        	}

        	this.name = name;
        	this.age = age;
    	}

    	public String getName() 
	{
        	return name;
    	}

    	public int getAge() 
	{
        	return age;
    	}
}

class MainEntityCheck
{
    	public static void main(String[] args) 
	{
        	try 
		{
            		Entity e = new Entity("John", -30);
        	} 
		catch (InvalidEntityException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

        	try 
		{
            		Entity e = new Entity("", 25);
        	} 
		catch (InvalidEntityException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

       	 	try 
		{
            		Entity e = new Entity("Jane", 30);
            		System.out.println("Name: " + e.getName());
            		System.out.println("Age: " + e.getAge());
        	} 
		catch (InvalidEntityException ex) 
		{
            		System.out.println(ex.getMessage());
        	}
   	}
}	

//--------------------------------------------------------------------------------------

	// Example 4: User Defined exception in java for Validating the age of user

class InvalidAgeException extends Exception 
{
    	public InvalidAgeException(String message) 
	{
        	super(message);
    	}
}

class User 
{
    	private int age;
    	public User(int age) throws InvalidAgeException 
	{
       		if (age < 0) 
		{
            		throw new InvalidAgeException("Age cannot be negative.");
        	}

        	if (age > 150) 
		{
            		throw new InvalidAgeException("Age is too high.");
        	}
	        this.age = age;
   	}
}

class Main 
{
    	public static void main(String[] args) 
	{
        	try 
		{
            		User user = new User(-1);
        	} 
		catch (InvalidAgeException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

        	try 
		{
            		User user = new User(151);
        	} 
		catch (InvalidAgeException ex) 
		{
            		System.out.println(ex.getMessage());
        	}

        	try 
		{
            		User user = new User(30);
            		System.out.println("Age is valid.");
        	} 
		catch (InvalidAgeException ex) 
		{
            		System.out.println(ex.getMessage());
        	}
    	}
}


///===================================================================================================================
///===================================================================================================================
///===================================================================================================================

	// ------------------------- Multi-Threading(Concurrent Programming) in Java ---------------------------------

	- Concurrent means operating or occurring at the same time.

Why to go for the concurrent programming? 
-------------------------------------------
	- Improved Performance: Utilizes available computational resources efficiently, leading to faster 
	  execution times.

	- Enhanced Responsiveness: Allows systems to remain responsive even during time-consuming operations, 
	  crucial for user-facing applications.

	- Better Resource Utilization: Maximizes CPU and I/O resources by overlapping computation with I/O 
	  operations or executing tasks concurrently.

	- Scalability: Enables systems to handle increasing workloads by distributing tasks across multiple 
	  threads or processes.

	- Parallelism: Provides multi-core processors to execute multiple tasks simultaneously, speeding 
	  up processing for computationally intensive tasks.

	- Fault Isolation: Contains errors within separate threads or processes, preventing them from affecting 
	  the entire system and enhancing reliability.

	- Modularity and Maintainability: Encourages modular software design, making systems easier to understand,
	  maintain, and modify.


what is thread and what is process.
------------------------------------
A process and a thread are both independent sequences of execution, but they differ in a few key ways:

Process: A process is an instance of a program that is being executed. It includes the program itself, data,
resources such as files, and execution info such as process relation information kept by the OS. Each process 
exists within its own address or memory space and does not share it with other processes. 

Thread: A thread is a segment of a process or a part of process, which means a process can have multiple threads. 
These threads are managed independently by the scheduler. Unlike processes, threads within the same process run 
in a shared memory space. 

Here are some key differences between a process and a thread:

- A process takes more time to terminate and create, while a thread takes less time, as the process is heavyweight 
  and thread is lightweigth.
- Processes having different memory area, where as the threads shares the same memory space.
- Processes do not share data with each other, while threads share data with each other.
- You can say that Procsess is Heavyweigth Thread and Thread is ligthweight Process.
- Interthread communication is quite easy coz threads are within same memory area.
- InterProcess communication is complex as they are exists within different memory space.

//-----------------------------------------------

What is Single Thread?
A single thread in Java is basically a lightweight and the smallest unit of processing, which will execute all its 
instructions in sequence. 

Advantages of single thread:
	- Reduces overhead in the application as single thread execute in the system.
	- Also, it reduces the maintenance cost of the application.

What is Multithreading in Java?
Multithreading in Java is a process of executing two or more threads simultaneously to maximum utilization of CPU.
where java allows user to split the code into two or more parts and provides the ability to execute them in parallel
with each other.

Advantages of multithread:
	- The users are not blocked because threads are independent, and we can perform multiple operations at a times
	- As such the threads are independent, the other threads won’t get affected if one thread meets an exception.

so in simple terms, Multithreading is a programming concept in which the application can create a small unit of tasks 
to execute in parallel. If you are working on a computer, it runs multiple applications and allocates processing power 
to them. A simple program runs in sequence and the code statements execute one by one. This is a single-threaded 
application. But, if the programming language supports creating multiple threads and passes them to the operating 
system to run in parallel, it’s called multithreading.


Multithreading vs Multiprocessing:

Multiprocessing refers to the use of multiple processors or processor cores within a single computer system to execute 
multiple tasks concurrently. It is a technique used to improve the performance and scalability of software systems by 
distributing computational workload across multiple processing units.

When we talk about multithreading, we don’t care if the machine has a 2-core processor or a 16-core processor. Our work 
is to create a multithreaded application and let the OS handle the allocation and execution part. In short, 
multithreading has nothing to do with multiprocessing.

//-------------------------------------------------

How does Java Support Multithreading?
Java has great support for multithreaded applications. Java supports multithreading through Thread, then How to 
create the threads?
	
In Java, There are two different ways of Thread creation.
	 - By extending Thread class.
	 - By implementing Runnable Interface

What are the different types of threads?

	There are two types of threads in an application - user thread and daemon thread. 
	When we start an application, the main is the first user thread created. We can create multiple user threads 
	as well as daemon threads. When all the user threads are executed, JVM terminates the program.

//-----------------------------------------------


Thread Lifecycle:
 
	New Born
	    |
	    | start()
	    V
      Ready to Run <-------------
	(Runnable)		|
	    |			| - resume(),  notify(), noyifyAll()
   run()    |			|
 |--------->|		  Waiting/Blocked
 |	    V			^
 |<-----Running ------>---------|
	    |      sleep(), join() - will enters into Runnable state automatically
      stop()|	   - suspend(),wait()-> resumes only when resume() or notify(), noyifyAll() methods are called.
   destroy()|
 interrupt()|
	    V
	  Dead
	    

 - New: In this phase, the thread is created using class “Thread class”.It remains in this state till the program starts the thread. It is also known as born thread.

 - Runnable: In this page, the instance of the thread is invoked with a start method. The thread control is given to scheduler to finish the execution. It depends on the scheduler, whether to run the thread.

 - Running: When the thread starts executing, then the state is changed to “running” state. The scheduler selects one thread from the thread pool, and it starts executing in the application.

 - Waiting/Blocked: This is the state when a thread has to wait. As there multiple threads are running in the application, there is a need for synchronization between threads. Hence, one thread has to wait, till the other thread gets executed. Therefore, this state is referred as waiting state.

 - Dead: This is the state when the thread is terminated. The thread is in running state and as soon as it completed processing it is in “dead state”.

//-----------------------------------------------------------------------------------------------
	
	// Creating Threads 

	- Using java.lang.Thread class.

	// Thread class Constants: 
	
	In Java, the java.lang.Thread class provides several constants. Here's a list of some of the important constants 
	in the Thread class:

	- MIN_PRIORITY: The minimum priority that a thread can have. Its value is 1.
	- NORM_PRIORITY: The default priority of a thread. Its value is 5.
	- MAX_PRIORITY: The maximum priority that a thread can have. Its value is 10.

	These constants are typically used when setting or getting the priority of a thread using the setPriority() 
	and getPriority() methods. default priority is 5. i.e. NORM_PRIORITY


	// Thread class Constructors: 

	In the java.lang.Thread class, there are several constructors available for creating a new thread instance. 
	Here's a list of constructors:

	$- Thread(): Constructs a new thread instance.
	$- Thread(Runnable target): Constructs a new thread with the specified Runnable target.
	$- Thread(ThreadGroup group, Runnable target): Constructs a new thread with the specified ThreadGroup and Runnable target.
	$- Thread(String name): Constructs a new thread with the specified name.
	$- Thread(ThreadGroup group, String name): Constructs a new thread with the specified ThreadGroup and name.
	$- Thread(Runnable target, String name): Constructs a new thread with the specified Runnable target and name.
	$- Thread(ThreadGroup group, Runnable target, String name): Constructs a new thread with the specified ThreadGroup, 
		Runnable target, and name.
	- Thread(ThreadGroup group, Runnable target, String name, long stackSize): Constructs a new thread with the specified
		ThreadGroup, Runnable target, name, and stack size.



	// Thread class methods: 
	
	The java.lang.Thread class in Java provides a variety of methods for managing threads. Here's a list of some of the 
	commonly used methods in the Thread class:

	$- start(): Causes this thread to begin execution. The Java Virtual Machine calls the run method of this thread.
	$- run(): If this thread was constructed using a separate Runnable run object, then that Runnable object's run method is 		 called; otherwise, this method does nothing and returns.
	$- sleep(long millis): Causes the currently executing thread to sleep (temporarily cease execution) for the specified 
		number of milliseconds.
	- interrupt(): Interrupts this thread.
	- isInterrupted(): Tests whether this thread has been interrupted.
	- join(): Waits for this thread to die.
	$- setName(String name): Changes the name of this thread to the specified name.
	$- getName(): Returns the name of this thread.
	$- getPriority(): Returns the priority of this thread.
	$- setPriority(int priority): Changes the priority of this thread.
	$- getId(): return int id of thread.
	- isAlive(): Tests whether this thread is alive.
	- yield(): Causes the currently executing thread object to temporarily pause and allow other threads to execute.
	- currentThread(): Returns a reference to the currently executing thread object.
	- isDaemon(): Tests if this thread is a daemon thread.
	- setDaemon(boolean on): Marks this thread as either a daemon thread or a user thread.


	// simple example 

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Thread is created...!!");
	}
	public void run() {
		System.out.println("Thread is Running...!!");
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");
		MyThread t1 = new MyThread();
		t1.start();
		System.out.println("T1 is Running: "+t1.isAlive());
		System.out.println("main() end..!");
	}
}
// ---------- On Execution -------------
main() started..!
Thread is created...!!
Thread is Running...!!
T1 is Running: true
main() end..!
Press any key to continue . . .

//--------------------------------------------------------------------------------------------

	// Creating the main and one userdefined thread

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Thread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this);
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");
		MyThread t1 = new MyThread();
		t1.start();
		System.out.println("T1 is Running: "+t1.isAlive());
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//--------------------------------------------------------------------------------

	// Creating Multiple threads of same type

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Default - Thread is created...!!");
	}	
	public MyThread(String name) {
		super(name);
		System.out.println("Para - Thread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this);
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");
		MyThread t1 = new MyThread("One");
		t1.setPriority(1);
		t1.start();
		MyThread t2 = new MyThread("Two");
		t2.setPriority(10);
		t2.start();
		System.out.println("T1 is Running: "+t1.isAlive());
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//--------------------------------------------------------------------------------

	// Creating Multiple threads of Different type

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Default - MyThread is created...!!");
	}	
	public MyThread(String name) {
		super(name);
		System.out.println("Para - MyThread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this);
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class YourThread extends Thread
{
	public YourThread() {
		System.out.println("Default - YourThread is created...!!");
	}	
	public YourThread(String name) {
		super(name);
		System.out.println("Para - YourThread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this.getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");

		MyThread t1 = new MyThread("One");
		t1.setPriority(1);
		t1.start();

		YourThread t2 = new YourThread("Two");
		t2.setPriority(10);
		t2.start();

		System.out.println("T1 is Running: "+t1.isAlive());
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//-----------------------------------------------------------------------------------------

	// Using ThreadGroup

class MyThread extends Thread
{
	public MyThread() {
		System.out.println("Default - MyThread is created...!!");
	}	
	public MyThread(ThreadGroup tg, String name) {
		super(tg, name);
		System.out.println("Para - MyThread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this);
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class YourThread extends Thread
{
	public YourThread() {
		System.out.println("Default - YourThread is created...!!");
	}	
	public YourThread(ThreadGroup tg,String name) {
		super(tg, name);
		System.out.println("Para - YourThread is created...!!");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(this.getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ThreadExample
{
	public static void main(String[] args) 
	{
		System.out.println("main() started..!");

		ThreadGroup tg = new ThreadGroup("MyGroup");

		MyThread t1 = new MyThread(tg,"One");
		t1.setPriority(1);
		t1.start();

		YourThread t2 = new YourThread(tg,"Two");
		t2.setPriority(10);
		t2.start();

		System.out.println("T1 is Running: "+t1.isAlive());
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//---------------------------------------------------------------------------------------------------------------------------

	// Using Runnable Interface to create the Threads.
	//===================================================

class DemoThread implements Runnable
{
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ExampleThreadRunnable 
{
	public static void main(String[] args) 
	{
		System.out.println("Main start....!!");

		DemoThread d1 = new DemoThread();
		Thread t1 = new Thread(d1);
		t1.start();

		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//-----------------------------------------

	// Another Way

class DemoThread implements Runnable
{
	Thread t=null;
	public  DemoThread() {
		t=new Thread(this);
		t.setName("Dthread");
		t.start();
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(t.getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ExampleThreadRunnable 
{
	public static void main(String[] args) 
	{
		System.out.println("Main start....!!");
		DemoThread d1 = new DemoThread();

		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//--------------------------------------------------------------------------------

	// calling start() from outside

class DemoThread implements Runnable
{
	Thread t=null;
	public  DemoThread() {
		t=new Thread(this);
		t.setName("Dthread");
	}
	public void run() {
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(200);}catch(Exception e){}
		}
	}
}
class ExampleThreadRunnable 
{
	public static void main(String[] args) 
	{
		System.out.println("Main start....!!");
		DemoThread d1 = new DemoThread();
		d1.t.start();
		for(int i=0 ;i<20 ; i++) {
			System.out.println(Thread.currentThread().getName());
			try{Thread.sleep(400);}catch(Exception e){}
		}
		System.out.println("main() end..!");
	}
}

//--------------------------------------------------------------------------------------------------

	// Using the anonymous inner class:

	// Using Thread class
class DemoAnoThread 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...!!!");

		Thread t1 = new Thread() {
			public void run() {
				for(int i=0 ; i<20 ; i++) {
					System.out.println("t1 - "+i);
					try{ Thread.sleep(600); } catch(Exception e){}
				}
			}
		};
		t1.start();

		for(int i=0 ; i<20 ; i++) {
				System.out.println("main - "+i);
				try{ Thread.sleep(1200); } catch(Exception e){}
		}

		System.out.println("Main ended...!!!");
	}
}

//--------------------

	// Using Runnable Interface


class DemoAnoInterface
{
	public static void main(String[] args) 
	{
		System.out.println("Main Started...!!!");

		Thread t1 = new Thread( new Runnable() {
			public void run() {
				for(int i=0 ; i<20 ; i++) {
					System.out.println("t1 - "+i);
					try{ Thread.sleep(1200); } catch(Exception e){}
				}
			}
		});
		t1.start();

		Thread t2 = new Thread( new Runnable() {
			public void run() {
				for(int i=0 ; i<20 ; i++) {
					System.out.println("t2 - "+i);
					try{ Thread.sleep(1200); } catch(Exception e){}
				}
			}
		});
		t2.start();

		for(int i=0 ; i<20 ; i++) {
				System.out.println("main - "+i);
				try{ Thread.sleep(1200); } catch(Exception e){}
		}

		System.out.println("Main ended...!!!");
	}
}

//------------------------------------------------------------------------------------------------------------------------

	// Thread Transaction: changing the thread states

	// Suspend and resume() methods:

	- Suspend() method puts thread from running to waiting state. And thread can go from waiting to runnable state 
		    only when resume() method is called on thread. Suspend method is deprecated method.
	- Resume() method is only used with suspend() method that’s why it’s also deprecated method.

	Suspend() and resume() are deprecated methods and marked for removal because if not used properly they might 
	lead to deadlock.

//-------------------------------------------------------------------------------------------------------------------------

	// Using interrupt() method: 

	- used to interrupt an executing Thread and for that it will set interrupt status true.
	- interrupt() method will work when thread is in sleeping or waiting state.
	- when thread is not in sleeping or waiting state then calling the interrupt() method wil perform normal behavior.
	- when we use an interrupt() method, it throws an InterruptedException, and then thread execution is terminated.

class MyThread extends Thread
{
	public void run()
	{
		try
		{
			for(int i=0;i<15;i++)
			{
				System.out.println(i + " - "+this);
				Thread.sleep(3000);
			}
		}
		catch (InterruptedException e)
		{
			System.out.println("Thread t1 Terminated");
		}
	}
}
class InterruptExample 
{
	public static void main(String[] args) 
	{
		MyThread t1=new MyThread();
		t1.start();

		try
		{
			for(int i=0;i<15;i++)
			{
				System.out.println("main - "+ i);
				Thread.sleep(600);
				if(i==5)
					t1.interrupt();
			}
		}
		catch(Exception e){}

		
	}
}

//-------------------

	// interrupted() and isInterrupted():

		- Both returns true when thread is interrupted, otherwise both will return false.
		- Note that the call to interrupt() method will generates the InterruptedException only when the interrupt status
		  is ture.
		- Difference is that interrupted() method changes the interrupted status from true to false but isInterrupted()
		  does not affact the interrupted status.
		- interrupted() will change the result, but isInterrupted() wil not change the result if called twice.
		- method signature: 
			- public static boolean interrupted()
			- public boolean isInterrupted()


///-------------------------------------------------------------------------------------------------------------------------------

	// Using the yield() methods:

		- will stops current executing thread and gives chance to other thread.
		- Till Java 5, internally the sleep() was used but from Java 6 Onwords it will informs to scheduler 
		  about the his opinion, but it is decided by scheduler

class MyThread extends Thread
{
	public MyThread(String name)
	{
		super(name);
		start();
	}
	public void run()
	{
		try
		{
			for(int i=0;i<20;i++)
			{
				System.out.println(i+" - "+this.getName());
				Thread.sleep(300);
			}
		}
		catch (Exception e)
		{
		}
	}
}
class  ThreadYieldExample
{
	public static void main(String[] args) 
	{
		MyThread t1=new MyThread("One");
		MyThread t2=new MyThread("Two");
		MyThread t3=new MyThread("Three");
		MyThread t4=new MyThread("Four");
		MyThread t5=new MyThread("Five");
		try
		{
			t3.yield();
			for(int i=0;i<20;i++)
			{
				System.out.println("Hi");
				Thread.sleep(300);
			}
		}
		catch (Exception e)
		{
		}
	}
}

//-------------------------------------------------------------------------------

	// Using the join() and isAlive()

	
	The join() method in Java is a part of the Thread class and is used to ensure that one thread waits for 
	the completion of another thread before proceeding further. It provides a way to pause the execution of 
	the current thread until the thread on which join() is called finishes its execution.

	public final void join() throws InterruptedException
	public final void join(long millis) throws InterruptedException
	public final void join(long millis, int nanos) throws InterruptedException

	The current thread will wait for the specified number of milliseconds for the target thread to complete. 
	If the target thread does not finish in that time, the current thread resumes execution.


	isAlive(): 

	The isAlive() method in Java is part of the Thread class and is used to check whether a thread is currently 
	active or alive. A thread is considered alive when it has been started and has not yet finished its execution.

	returns true: If the thread has been started (using start()) and has not yet terminated. otherwise false

class MyThread extends Thread
{
	public void run() {
		for(int i=0 ; i<20 ; i++) {
			System.out.println(this.getName()+" - "+i);
			try{ Thread.sleep(600); } catch(Exception e){}
		}
	}
}
class YourThread extends Thread
{
	public YourThread() {
		super("Test_Thread");
	}
	public void run() {
		for(int i=0 ; i<20 ; i++) {
			System.out.println(this.getName()+" - "+i);
			try{ Thread.sleep(200); } catch(Exception e){}
		}
	}
}
class DemoJoinMethod
{
	public static void main(String[] args) 
	{
		MyThread t1 = new MyThread();
		t1.start();
        
		YourThread t2 = new YourThread();
		t2.start();
		
		MyThread t3 = new MyThread();
		t3.start();
        
        	for(int i=0 ; i<20 ; i++) {
			System.out.println("main - "+i);
			System.out.println("T2 is Alive - "+t2.isAlive());
			try{ Thread.sleep(600); } catch(Exception e){}
			if(i==5) {
				try{ t2.join(); } catch(Exception e){}
			}
		}
		
	}
}

///-------------------------------------------------------------------------------------------------------------------------

	Thread Synchronization
	------------------------
	
	Synchronization is a process of handling resource accessibility by multiple thread requests. The main purpose 
	of synchronization is to avoid thread interference. At times when more than one thread try to access a shared 
	resource, we need to ensure that resource will be used by only one thread at a time. The process by which 
	this is achieved is called synchronization. 

	in simple terms, When two or more threads need access to a shared resource, they need some way to ensure that 
	the resource will be used by only one thread at a time. The process by which this is achieved is called 
	synchronization. Java implements synchronization through use of the synchronized keyword.

	Why we need Syncronization?
	If we do not use syncronization, and let two or more threads access a shared resource at the same time, it 
	will lead to distorted results.

	Lets consider the Shared Resource (Object of Message class), which is accessed by multiple threads.

class Message
{
	public void show() {
		System.out.println("Hello ");
		System.out.println("All ");
		System.out.println("good ");
		try{ Thread.sleep(1600); } catch(Exception e){}
		System.out.println("afternoon ");
		System.out.println("to ");
		System.out.println("all ");
		try{ Thread.sleep(2600); } catch(Exception e){}
		System.out.println("of ");
		System.out.println("you ");
	}
}
class DemoThread extends Thread
{
	Message msg;
	public DemoThread(Message ob) {
		msg = ob;
	}
	public void run() {
		msg.show();
	}
}
class DisplayMessageExample
{
	public static void main(String[] args) 
	{
		Message ob = new Message();

		DemoThread t1 = new DemoThread(ob);
		t1.start();

		DemoThread t2 = new DemoThread(ob);
		t2.start();
	}
}

//----------- output -----------

Hello
All
good
Hello
All
good
afternoon
afternoon
to
all
to
all
of
you
of
you
Press any key to continue . . .

//-------------------------------------------------------

	The synchronized keyword in Java is used to handle thread synchronization, ensuring that only one 
	thread can access a critical section of code at a time. This prevents race conditions and ensures 
	thread safety when multiple threads are accessing shared resources.

	When a thread enters a synchronized block or method, it acquires a lock (monitor) on the object or 
	class. Other threads trying to execute synchronized code on the same object or class must wait until 
	the lock is released.

	Note some important terms:
	
	- A lock is a mechanism that allows only one thread to access a shared resource (like a variable or a 
	  critical section of code) at a time. Locks ensure mutual exclusion, preventing data inconsistency 
	  caused by concurrent access.

		- Every object in Java has an intrinsic lock or monitor lock, which is used in conjunction with 
		  the synchronized keyword.
		- Explicit locks, like those provided by java.util.concurrent.locks.Lock, offer more advanced 
		  features such as try-lock and timed-lock.

	- A monitor is a synchronization construct that is built into each Java object. It combines:
		- Mutual exclusion (lock): Ensures that only one thread can execute a synchronized method or 
		  block at a time.
		- Thread coordination (wait/notify): Helps threads coordinate their execution using methods 
		  like wait(), notify(), and notifyAll().
	   A monitor is automatically associated with a synchronized method or block in Java. When a thread enters 
	   a synchronized method or block, it acquires the monitor lock for the object. No other thread can enter 
	   any synchronized code on the same object until the monitor is released.

	- A mutex is a synchronization primitive that ensures mutual exclusion, meaning only one thread can access 
	  a critical section at a time. It is conceptually similar to a lock, but the term is more general and widely 
	  used across programming languages.
	  In Java, the intrinsic lock of an object (used with synchronized) or explicit locks (like ReentrantLock) 
	  can act as a mutex.

	- A race condition occurs when two or more threads access shared data concurrently, and the result of the 
	  program depends on the timing of their execution. This often leads to unpredictable behavior or incorrect 
	  results.

class Message
{
	synchronized public void show() {
		System.out.println("Hello ");
		System.out.println("All ");
		System.out.println("good ");
		try{ Thread.sleep(1600); } catch(Exception e){}
		System.out.println("afternoon ");
		System.out.println("to ");
		System.out.println("all ");
		try{ Thread.sleep(2600); } catch(Exception e){}
		System.out.println("of ");
		System.out.println("you ");
	}
}
class DemoThread extends Thread
{
	Message msg;
	public DemoThread(Message ob) {
		msg = ob;
	}
	public void run() {
		msg.show();
	}
}
class DisplayMessageExample
{
	public static void main(String[] args) 
	{
		Message ob = new Message();

		DemoThread t1 = new DemoThread(ob);
		t1.start();

		DemoThread t2 = new DemoThread(ob);
		t2.start();
	}
}

//----------- Output ------------
Hello
All
good
afternoon
to
all
of
you
Hello
All
good
afternoon
to
all
of
you
Press any key to continue . . .

//-----------------------------------------------------------------------------------------------------------------

	In java, the synchronization is achieved using the following concepts.

	- Mutual Exclusion (Using Synchronized keyword)
	- Inter thread communication (wait(), notify() notifyAll() )


	Mutual Exclusion(Mutex) [Exclusion-The act of not allowing someone or something to take part in an activity or 
	to enter a place] Using the mutual exclusion process, we keep threads from interfering with one another while 
	they accessing the shared resource. In java, mutual exclusion is achieved using the following concepts.

	- Synchronized method
	- Synchronized block
	- Static synchronization.


	// - Synchronized method

	When a method defined using a synchronized keyword, it allows only one Thread to access resource at a time. 
	When an object calls a synchronized method, it put a lock on that method so that other objects or thread 
	that are trying to call the same method must wait, until the lock is released. Once the lock is released 
	on the shared resource, one of the threads among the waiting threads will be start using the shared 
	resource again.

	lets see the above exampe with the synchronized keyword...!!

class Resource
{
	private String []data = {"hello", "Good day", "to", "all", "of you","wish", "you ", "all the", "best"};
	
	synchronized public void show() {
		System.out.println("The Data is: ");
		for( int i=0 ; i<data.length ; i++ ) {
			try{ Thread.sleep(600); } catch(Exception e){}
			System.out.println(data[i]);
		}
	}
}
class DemoSyncMethod
{
	public static void main(String[] args) 
	{
		System.out.println("Main started");

		Resource rob = new Resource();

		// Thread 1
		Thread t1 = new Thread(){
			public void run() {
				rob.show();
			}
		};
		t1.start();

		// Thread 2
		Thread t2 = new Thread(){
			public void run() {
				rob.show();
			}
		};
		t2.start();

		System.out.println("Main ended");
	}
}

//----------------------------------------------------------

	// what is thread-safe and non thread-safe in java multithreading?

   In Java multithreading, "thread-safe" refers to code or data structures that can be safely accessed and manipulated 
   by multiple threads concurrently without causing any issues such as data corruption, race conditions, or 
   unexpected behavior. On the other hand, "non-thread-safe" refers to code or data structures that are not designed 
   to handle concurrent access from multiple threads and may lead to problems if accessed concurrently.

  Thread-Safe:
	- Thread-safe code ensures that shared data structures or resources are accessed in a synchronized manner 
	  to prevent concurrent modification issues.
	- Thread-safe classes often use synchronization mechanisms such as locks, mutexes, or atomic operations to 
	  ensure mutual exclusion.
	- Examples of thread-safe classes in Java include StringBuffer.

  Non-Thread-Safe:
	- Non-thread-safe code or data structures do not provide mechanisms to handle concurrent access safely.
	- Accessing non-thread-safe code concurrently may lead to race conditions, data corruption, or inconsistent 
	  behavior.
	- Examples of non-thread-safe classes in Java include ArrayList and HashMap. These classes are not synchronized, 
	  so concurrent access without external synchronization can lead to issues.


//------------------------------------------------------------------------------------------------------------------

	// Using Synchronized block (Object level Synchronozation)

	Synchronized block in Java is another way of managing the execution of threads. It is mainly used to perform 
	synchronization on a certain block of code or statements inside the method.

	Synchronizing a block of code is more powerful than synchronized method. For example, suppose there are 30 lines 
	of code in a method, but we want to synchronize only 5 lines of code. In this case, we should use a synchronized 
	block.

	If we place all the codes of the method in the synchronized block, it will work the same as the synchronized 
	method.

	lets see the example below, in which there are two different instruction groups(blocks) enclosed witin scope
	of synchronized keyword. It requres an object of any type, which is considered as a lock. and all 
	such synchronized blocks will be restricted to paralled execution, having a same lock.

class Resource
{
	private String []data1 = {"hello", "Good day", "to", "all", "of you","wish", "you ", "all the", "best"};
	private String []data2 = {"THIS", "IS", "THE", "ANOTHER", "MESSAGE","DISPLAYED", "USING ", "DIFFERENT", "METHOD"};
	Object lock = new Object();
	 public void show() {
		System.out.println("The Data show() is: ");
		
		synchronized(lock) {
			for( int i=0 ; i<data1.length ; i++ ) {
				try{ Thread.sleep(600); } catch(Exception e){}
				System.out.println(data1[i]);
			}
		}
		System.out.println("End of show() ");
	}	
	public void display() {
		System.out.println("The Data display() is: ");

		synchronized(lock) {
			for( int i=0 ; i<data2.length ; i++ ) {
				try{ Thread.sleep(600); } catch(Exception e){}
				System.out.println(data2[i]);
			}
		}
		System.out.println("End of display() ");
	}
}
class DemoSyncMethod
{
	public static void main(String[] args) 
	{
		Resource rob = new Resource();

		// Thread 1
		Thread t1 = new Thread(){
			public void run() {
				rob.show();
			}
		};
		t1.start();

		// Thread 2
		Thread t2 = new Thread(){
			public void run() {
				rob.display();
			}
		};
		t2.start();

	}
}

	* Note: when two different objects are there used as a lock, the we will see the 
	        parallel execution.(like unsynchronized)

//-----------------------------------------------------------------------------------------------------------------

	
	- Static synchronization (class level synchronization)
	------------------------------------------------------

	Static synchronization in Java involves synchronizing access to a shared resource using a static keyword. When 
	a method is declared as static synchronized, only one thread can execute that method at a time for the entire 
	class, not just for the object instance.

			    ob1				    ob2	
		t1 -------> [ print() ]		t11 -------> [ print()  ]
			      ^				       ^
			      |				       |
			     t2                               t22

	In the example below, there are two different objects of type ShowArray, and each will be accessed using a pair
	of threads in synchronized manner. But as the synchronization is at instance(object) level, a single thread from
	each pair will execute at a time.


			    ob1				    ob2	
		t1 -------> [      ] ====== print()====== [   ] <------- t11
			      ^	    (common to all objects)    ^
			      |				       |
			     t2                               t22

class Resource
{
	private static String []data = {"hello", "Good day", "to", "all", "of you","wish", "you ", "all the", "best"};
	
	synchronized static public void show() {
		System.out.println("The Data is: ");
		for( int i=0 ; i<data.length ; i++ ) {
			try{ Thread.sleep(600); } catch(Exception e){}
			System.out.println(Thread.currentThread().getName()+" - "+data[i]);
		}
	}
}
class StaticSyncMethod
{
	public static void main(String[] args) 
	{
		System.out.println("Main started");

		Resource rob1 = new Resource();
		Resource rob2 = new Resource();

		// Thread 1
		Thread t1 = new Thread(){
			public void run() {
				rob1.show();
			}
		};
		t1.setName("One");
		t1.start();

		// Thread 2
		Thread t2 = new Thread(){
			public void run() {
				rob1.show();
			}
		};
		t2.setName("Two");
		t2.start();

		//-----------------------------------

		// Thread 3
		Thread t3 = new Thread(){
			public void run() {
				rob2.show();
			}
		};
		t3.setName("Three");
		t3.start();

		// Thread 4
		Thread t4 = new Thread(){
			public void run() {
				rob2.show();
			}
		};
		t4.setName("Four");
		t4.start();

		System.out.println("Main ended");
	}
}

//------------------------------------------------------------------

	
	- Inter thread communication (wait(), notify() notifyAll() ): Another way of achiving synchronization.

	You might have noticed Object class has three final method called wait(), notify() and notifyAll(). 
	These methods are used for inter thread communication. Java 5 has introduced executor framework which takes 
	care of inter thread communication for you and internally uses wait(), notify() and notifyAll()
	but you still require basic understanding of these methods and how inter thread communication works in 
	java using wait(), notify() and notifyAll().

 	- What are wait(), notify() and notifyAll() methods?
	 ----------------------------------------------
	wait(), notify() and notifyAll() methods are used to allow threads to communicate to each other via accessing 
	common object or in other terms, Object can be considered a medium for inter thread communication via these 
	methods. These methods need to be called from synchronized context, otherwise it will throw 
	java.lang.IllegalMonitorStateException.

 	- Some background on synchronized block :
 	-------------------------------------------
		- Only one thread can enter at a time in synchronized block.
		- A thread required lock on the object to enter in synchronized block.
		- If Thread A want to enter in synchronized block then Thread A has to wait for Thread B to release it.

	Lets see wait(), notify() and notifyAll() methods:

	- wait(): When you call wait method on the object then it tell threads to give up the lock and go to sleep state 
		unless and until some other thread enters in same monitor and calls notify() or notifyAll() methods on it.

	- notify(): When you call notify method on the object, it wakes one of thread waiting for that object. 
	            So if multiple threads are waiting for an object, it will wake of one of them. Now you must be 
		    wondering which one it will wake up. It actually depends on OS implementation.

	- notifyAll(): notifyAll will wake up all threads waiting on that object unlike notify which wakes up only one of them.
		       Which one will wake up first depends on thread priority and OS implementation.


 // lets see, how wait() and notify() works in synchronized environment


import java.util.Random;
class Cart extends Thread
{
	double bill=0.0;
	public double getBill(){return bill;}
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			try{Thread.sleep(400);}catch(Exception e){}
				System.out.println("Waiting....."+i);
		}
		synchronized(this)
		{
			for(int i=0;i<5;i++)
			{
			
				try{Thread.sleep(400);}catch(Exception e){}
				int price=new Random().nextInt(200);
				System.out.println("Item "+(i+1)+" Price: "+price);
				bill=bill+price;
			}
			this.notify();
		}
	}
}
class ShoppingMain 
{
	public static void main(String[] args) 
	{
		Cart c1=new Cart();
		c1.start();
		
		synchronized(c1)
		{
			for(int i=0;i<20;i++)
			{
				try{Thread.sleep(400);}catch(Exception e){}
					System.out.println("Main()....."+i);
				if(i==10)
				{
					try{c1.wait();}catch(Exception e){}
				}
			}
		}

		System.out.println("Total Bill: "+c1.getBill());
	}
}

//----------------------------------------------------------------------------------------------

	//  By eliminating delays

import java.util.Random;
class Cart extends Thread
{
	double bill=0.0;
	public double getBill(){return bill;}
	public void run()
	{
		synchronized(this)
		{
			for(int i=0;i<5;i++)
			{
			
				try{Thread.sleep(400);}catch(Exception e){}
				int price=new Random().nextInt(200);
				System.out.println("Item "+(i+1)+" Price: "+price);
				bill=bill+price;
			}
			this.notify();
		}
	}
}
class ShoppingMain1
{
	public static void main(String[] args) 
	{
		Cart c1=new Cart();
		c1.start();
		
		synchronized(c1)
		{
			try{c1.wait();}catch(Exception e){}
		}

		System.out.println("Total Bill: "+c1.getBill());
	}
}

//-------------------------------------------------------------------------------

	// Same program using the common lock for synchronized block in different classes


import java.util.Random;
class Cart extends Thread
{
	Object lock;
	double bill=0.0;
	public Cart( Object lock) {
		this.lock = lock;
	}
	public double getBill(){return bill;}
	
	public void run()
	{
		for(int i=0;i<5;i++)
		{
			try{Thread.sleep(400);}catch(Exception e){}
				System.out.println("Waiting....."+i);
		}
		synchronized(lock)
		{
			for(int i=0;i<5;i++)
			{
			
				try{Thread.sleep(400);}catch(Exception e){}
				int price=new Random().nextInt(200);
				System.out.println("Item "+(i+1)+" Price: "+price);
				bill=bill+price;
			}
			lock.notify();
		}
	}
}
class TaskCaller extends Thread
{
	Object lock;
	Cart c1;
	public TaskCaller(Object lock, Cart c1) {
		this.lock = lock;
		this.c1 = c1;
	}
	public void run() {
		synchronized(lock)
		{
			for(int i=0;i<20;i++)
			{
				try{Thread.sleep(400);}catch(Exception e){}
					System.out.println("Main()....."+i);
				if(i==10)
				{
					try{lock.wait();}catch(Exception e){}
				}
			}
		}
		System.out.println("Total Bill: "+c1.getBill());
	}
}
class ShoppingMainLock
{
	public static void main(String[] args) 
	{
		Object lock = new Object();

		Cart c1=new Cart(lock);
		c1.start();

		TaskCaller t1 = new TaskCaller(lock, c1);
		t1.start();
		
		
	}
}
//--------------------------------------------------------------------------------------------------

	// Lets write another program

class Resource
{
	public void sayHi(){
		System.out.println("Hi...!!");
	}
	public void sayHello(){
		System.out.println("Hello...!!");
	}
}

class MainExampleResource
{
	public static void main(String []args)
	{
		Resource rob = new Resource();

		Thread t1 = new Thread(){
			public void run(){
				for(int i=0 ; i<7 ; i++){
					rob.sayHi();
					try{Thread.sleep(500);}catch(Exception e){}
				}
			}
		};

		Thread t2 = new Thread(){
			public void run(){
				for(int i=0 ; i<7 ; i++){
					rob.sayHello();
					try{Thread.sleep(500);}catch(Exception e){}
				}
			}
		};
	}
}

//---------------------------------------------------------------------------

	// In above program we dont have the control over the thread execution, to gaing the control
	// we need to make the shared resource synchronized, and to gain the greater control, we need 
	// to use wait() and notify() as shown below. 

	// here only Synchronization, will gives the guranty that one thread will access the resource 
	// at a time, but will not gives the confirmation that they will execute alternatively.

class Message
{
	boolean respond=false;
	synchronized void displayHi()
	{
		if(!respond)
		{
			try{ wait(); } catch(Exception e){}
		}
		System.out.println("Hi");
		respond=false;
		notify();
	}
	synchronized void displayHello()
	{
		if(respond)
		{
			try{ wait(); } catch(Exception e){}	
		}
		System.out.println("Hello");
		respond=true;
		notify();
	}
}

class SynchroDemo1
{
	public static void main(String []args)
	{
		Message ob=new Message();

		Thread t1 = new Thread(){
			public void run() {
				while(true) {
					ob.displayHi();
					try{Thread.sleep(300);}catch(Exception e){}
				}
			}
		};
		t1.start();

		Thread t2 = new Thread(){
			public void run() {
				while(true) {
					ob.displayHello();		
					try{Thread.sleep(700);}catch(Exception e){}
				}
			}
		};
		t2.start();
	}
}
//--------------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------------

	/// // Producer-Consumer Problem (Using wait() notify() )  - block synchronization implementation

	The Producer-Consumer Problem (sometimes called the Bounded-Buffer Problem) is a classic example of a 
	multi-threaded synchronization problem.

	The problem describes two threads, the Producer and the Consumer, and they are sharing a common, fixed-size 
	resource.

	The Producer produces an item, puts that item into the resource(increases value by 1), and keeps repeating this 
	process. On the other hand, the Consumer is consuming the item from the shared resource(decreases value by 1), 
	one item at a time.

class Resource
{
	int value;
	{value = 0;}
	public int getValue(){return value;}
	public void produce() {
		value++;
		System.out.println("Produced - Value: "+value);
	}
	public void consume() {
		value--;
		System.out.println("Consumed - Value: "+value);
	}
}
class Producer extends Thread
{
	Resource rob;
	public Producer(Resource rob) {
		this.rob = rob;
	}
	public void run() {
		synchronized(rob) {
			for(int i=0 ; i<15 ; i++) {
				if(rob.getValue()==1)
				{
					try{ rob.wait(); } catch(Exception e){}
				}
				try{Thread.sleep(300);}catch(Exception e){}
				rob.produce();
				rob.notify();
			}
		}
	}
}
class Consumer extends Thread
{
	Resource rob;
	public Consumer(Resource rob) {
		this.rob = rob;
	}
	public void run() {
		synchronized(rob) {
			for(int i=0 ; i<15 ; i++) {
				if(rob.getValue()==0)
				{
					try{ rob.wait(); } catch(Exception e){}
				}
				try{Thread.sleep(300);}catch(Exception e){}
				rob.consume();
				rob.notify();
			}
		}
	}
}
class ProducerConsumerExample
{
	public static void main(String[] args) 
	{
		Resource rob = new Resource();

		Producer p = new Producer(rob);
		Consumer c = new Consumer(rob);

		p.start();
		c.start();
	}
}

//---------------------------------------------------------------------------------------------------------

	// Above program using Anonymous Class

class Resource
{
	int value;
	{value = 0;}
	public int getValue(){return value;}
	public void produce() {
		value++;
		System.out.println("Produced - Value: "+value);
	}
	public void consume() {
		value--;
		System.out.println("Consumed - Value: "+value);
	}
}

class ProducerConsumerExample
{
	public static void main(String[] args) 
	{
		Resource rob = new Resource();

		// Producer
		Thread p = new Thread(){
			public void run() {
				synchronized(rob) {
					for(int i=0 ; i<15 ; i++) {
						if(rob.getValue()==1)
						{
							try{ rob.wait(); } catch(Exception e){}
						}
						try{Thread.sleep(300);}catch(Exception e){}
						rob.produce();
						rob.notify();
					}
				}
			}
		};

		// Consumer
		Thread c = new Thread(){
			public void run() {
				synchronized(rob) {
					for(int i=0 ; i<15 ; i++) {
						if(rob.getValue()==0)
						{
							try{ rob.wait(); } catch(Exception e){}
						}
						try{Thread.sleep(300);}catch(Exception e){}
						rob.consume();
						rob.notify();
					}
				}
			}
		};

		p.start();
		c.start();
	}
}

//----------------------------------------------------------------------------------------------------

	// The Deadlock in synchronization -  Reader-Writer Problem.
	
	A special type of error that you need to avoid that relates specifically to multitasking is deadlock,
	which occurs when two threads have a circular dependency on a pair of synchronized objects.

	Lets see the the famous problems in multi-threading and is referred to as the Reader-Writer Problem.

	There are two threads Reader and Writer both share a common object “message”.

	- Reader reads the message when it is not empty otherwise, it will wait for the Writer to write the message.

	- On the other hand, Writer writes the message when it is empty else it waits for Reader to read the message 
	  and mark the message empty.

	Now let’s create two threads Writer and Reader and one shared object for both the thread that is Message object.

import java.util.Random;
class Message 
{
	String message;
    	boolean empty = true; 

    	//Method used by reader
    	public synchronized String read() 
	{
        	while(empty) 		// if message is empty then keep looping.
		{
			System.out.println("Waiting for data write..!! so able to read");			
			try {Thread.sleep(2000);} catch (InterruptedException e) {}
		}
        	empty = true; 		// Reader reads the message and marks empty as true.
        	return message; 	//Reader reads the message.
    	}

    	//Method used by writer
    	public synchronized void write(String message) 
	{
        	while(!empty) 			//if message is not empty then keep looping.
		{
			System.out.println("Waiting for data read..!! so able to write");
			try {Thread.sleep(2000);} catch (InterruptedException e) {}
		}
        	this.message = message;		//Writer writes the message.
        	empty = false;			//Now make empty as false.
   	 }
}
class Writer implements Runnable 
{
	private Message message;
    	public Writer(Message message) 
	{
        	this.message = message;
    	}
    	public void run() 
	{
        	String messages[] = {
                "Johnny, Johnny, Yes Papa",
                "Eating sugar? No, Papa!",
                "Telling lies? No, Papa!",
                "Open your mouth, Ha! Ha! Ha!"
        	};

        	Random random = new Random();
        	for (int i = 0; i < messages.length; i++) 
		{
            		message.write(messages[i]);
            		try {Thread.sleep(random.nextInt(2000));} catch (InterruptedException e) {}
        	}
        	message.write("Finished!");
    	}
}

class Reader implements Runnable 
{
    	private Message message;
    	public Reader(Message message)
	{
        	this.message = message;
    	}
    	public void run() 
	{
        	Random random = new Random();
        	for (String latestMessage = message.read(); !"Finished!".equals(latestMessage); latestMessage = message.read()) 
		{
            		System.out.println(latestMessage);            
            		try {Thread.sleep(random.nextInt(2000));} catch (InterruptedException e) {}
        	}
   	}
}
public class MainReaderWriter 
{
	public static void main(String[] args) 
	{
        	//Shared message object between Reader and Writer threads.
        	Message message = new Message();

        	Thread writerThread = new Thread(new Writer(message));
        	Thread readerThread = new Thread(new Reader(message));

        	writerThread.start();
        	readerThread.start();
    }
}


-------------- Output on Run --------------
Johnny, Johnny, Yes Papa
Eating sugar? No, Papa!
Waiting for data read..!! so able to write
Waiting for data read..!! so able to write
Waiting for data read..!! so able to write
Waiting for data read..!! so able to write
Waiting for data read..!! so able to write

or any other ... or may be expected ... each time different output

Basically, by looking at the output above, you might wonder why aren’t the rest of the messages printed.
Now, the Simple Answer Is “DEADLOCK”.

Let me take the first output and explain to you why this deadlock occurred.

	- When we started the threads through the main() method from the Main class, both the threads 
	  called the run() method.
	- Note that both threads are sharing a common message object. Now the Reader thread called the 
	  synchronized read() method and hence acquired the lock of the message object.
	- As initially the boolean empty flag was set to true, the Reader thread keeps executing while looping infinitely.
	- Also, the Writer thread won’t be able to execute the write() method as the lock of the message object is 
	  already acquired by the Reader thread.

	Hence we don’t see any output on the console in the first output. Similarly, you can also try to trace 
	the second output.

	If you have noticed, none of the threads can do their required tasks, and they are waiting infinitely. 
	This scenario is called DEADLOCK.

	The solution to overcome the deadlock is very simple. We just have to introduce an acquire and release mechanism
	for monitor/intrinsic lock in the read() and write()synchronized methods which are causing deadlock. This problem
	is solved by using wait() and notify() and notifyAll().

	Let's see the example

import java.util.Random;
class Message 
{
    String message;
    boolean empty = true;

    //Method used by reader
    public synchronized String read() {
        while (empty) {
            try {
                wait();
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName() + "Interrupted.");
            }
        }
        empty = true;//Reader reads the message and marks empty as true.
        notifyAll();
        return message;//Reader reads the message.
    }

    //Method used by writer
    public synchronized void write(String message) {
        while (!empty) {
            try {
                wait();
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName() + "Interrupted.");
            }
        }
        this.message = message;//Writer writes the message.
        empty = false;//Now make empty as false.
        notifyAll();
    }
}
class Writer implements Runnable 
{
    private Message message;

    public Writer(Message message) 
	{
        this.message = message;
    }

    public void run() 
	{
        String messages[] = {
                "Johnny, Johnny, Yes Papa",
                "Eating sugar? No, Papa!",
                "Telling lies? No, Papa!",
                "Open your mouth, Ha! Ha! Ha!"
        };

        Random random = new Random();

        for (int i = 0; i < messages.length; i++) 
		{
            message.write(messages[i]);
            try 
			{
                Thread.sleep(random.nextInt(2000));
            } 
			catch (InterruptedException e) 
			{
                System.out.println("Writer Thread Interrupted!!!");
            }
        }
        message.write("Finished!");
    }
}

class Reader implements Runnable 
{
    private Message message;

    public Reader(Message message) {
        this.message = message;
    }
    public void run() {
        Random random = new Random();
        for (String latestMessage = message.read(); !"Finished!".equals(latestMessage); latestMessage = message.read()) 
	{
            System.out.println(latestMessage);
            try {Thread.sleep(random.nextInt(2000));} catch (InterruptedException e) 
	    {
                System.out.println("Reader Thread Interrupted!!!");
            }
        }
    }
}
public class MainReaderWriter 
{
    public static void main(String[] args) 
	{
        //Shared message object between Reader and Writer threads.
        Message message = new Message();

        Thread writerThread = new Thread(new Writer(message));
        Thread readerThread = new Thread(new Reader(message));

        writerThread.start();
        readerThread.start();
    }
}

---------- Output On Run ------------

Johnny, Johnny, Yes Papa
Eating sugar? No, Papa!
Telling lies? No, Papa!
Open your mouth, Ha! Ha! Ha!
Press any key to continue . . .


//--------------------------------------------------------------------------------------------------------------------

Even though this approach solves our problem, there are a few drawbacks of this approach:

	- All the threads that are in a blocked state can’t be interrupted.
	- If multiple threads are waiting for a lock and when the lock is available, the order in which the threads will 
	  get the lock is not guaranteed. Let’s say that the first thread which went into the wait state might be the 
	  last to get the lock to execute its synchronized block.
	- synchronized doesn't support thread scheduling. This can be solved using ReentrantLock. ReentrantLock has 
	  support for a configurable fairness policy, allowing more flexible thread scheduling.
	- We cannot hold the lock across the methods. This means we cannot hold the single monitor lock in one synchronized 
	  method and release it in another synchronized method. This can be done using ReentrantLock.

	i.e.

		private ReentrantLock lock;

		public void method1() {
 		...
  		lock.lock();
  		...
		}
		public void method2() {
  		...
  		lock.unlock();
  		...
		}

//----------------------------------------------------------------------------------------------------------------

	Java Locks:
	------------

	Most of the times, synchronized keyword is the way to go but it has some shortcomings that lead the way to 
	inclusion of Lock API in Java Concurrency package. Java 5 Concurrency API came up with java.util.concurrent.locks
	package with Lock interface and some implementation classes to improve the Object locking mechanism. 
	Some important interfaces and classes in Java Lock API are:

		java.util.concurrent.locks.Lock  (Interface)
			│
			├── ReentrantLock             	(Class - Implements Lock)
			│
			├── ReadWriteLock             	(Interface - Extends Lock functionality)
			|   |
			│   ├── ReentrantReadWriteLock 	(Class - Implements ReadWriteLock)
			│
			└── StampedLock               	(Class - Implements lock mechanism with stamps)
	

	Lock: This is the base interface for Lock API. It provides all the features of synchronized keyword with 
	additional ways to create different Conditions for locking, providing timeout for thread to wait for lock. 
	Some of the important methods are, lock() to acquire the lock, unlock() to release the lock, tryLock() to wait 
	for lock for a certain period of time, newCondition() to create the Condition etc.

	Condition: Condition objects are similar to Object wait-notify model with additional feature to create different 
	sets of wait. A Condition object is always created by Lock object. Some of the important methods are await() 
	that is similar to wait() and signal(), signalAll() that is similar to notify() and notifyAll() methods.

	ReadWriteLock: It contains a pair of associated locks, one for read-only operations and another one for writing. 
	The read lock may be held simultaneously by multiple reader threads as long as there are no writer threads. 
	The write lock is exclusive.

	ReentrantLock: This is the most widely used implementation class of Lock interface. This class implements the 
	Lock interface in similar way as synchronized keyword. Apart from Lock interface implementation, ReentrantLock 
	contains some utility methods to get the thread holding the lock, threads waiting to acquire the lock etc. 
	synchronized block are reentrant in nature i.e if a thread has lock on the monitor object and if another 
	synchronized block requires to have the lock on the same monitor object then thread can enter that code block. 
	I think this is the reason for the class name to be ReentrantLock. 

	The StampedLock class is a part of the java.util.concurrent.locks package, introduced in Java 8. It is a 
	modern locking mechanism designed to improve performance in scenarios with frequent reads and occasional 
	writes.



	Here are some of the commonly used methods of the ReentrantLock class:

 	- lock(): Acquires the lock. If the lock is not available, the current thread will wait until the lock becomes 
		  available.
 
	- unlock(): Releases the lock. It's important to ensure that unlock() is always called in a finally block 
		    to ensure the lock is released even if an exception occurs.

 	- tryLock(): Attempts to acquire the lock without waiting. Returns true if the lock was acquired successfully, 
		     false otherwise.

 	- tryLock(long time, TimeUnit unit): Attempts to acquire the lock within the specified time period. 
					     Returns true if the lock was acquired successfully within the specified 
					     time, false otherwise.

 	- isHeldByCurrentThread(): Returns true if the lock is held by the current thread, false otherwise.

 	- getHoldCount(): Returns the number of times the current thread has acquired the lock. If the lock is not 
			  held by the current thread, it returns 0.

 	- getQueueLength(): Returns an estimate of the number of threads waiting to acquire the lock.

 	- hasQueuedThreads(): Returns true if there are any threads waiting to acquire the lock.

 	- isLocked(): Returns true if the lock is held by any thread, false otherwise.


Let’s understand this feature with a simple example. ( Try to execute with and without comments)


import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Runner
{
	int counter=0;
	ReentrantLock lockob = new ReentrantLock();
	void increament() 
	{
		//lockob.lock();
		try
		{
			for(int i=0;i<10;i++)
			{
				counter++;
				System.out.println(Thread.currentThread().getName()+" - "+counter+" - InWaiting:: "+lockob.getQueueLength());
				try{Thread.sleep(700);}catch(Exception e){}
			}
		}
		catch(Exception e){}
		finally
		{
			//lockob.unlock();
		}
	}
}
class DemoRenterentockex
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();

		Thread t1=new Thread(){
			public void run()
			{
				ob.increament();
			}
		};
		t1.start();

		try{Thread.sleep(2000);}catch(Exception e){}

		Thread t2=new Thread(){
			public void run()
			{
				ob.increament();
			}
		};
		t2.start();

		try{Thread.sleep(2000);}catch(Exception e){}

		Thread t3=new Thread(){
			public void run()
			{
				ob.increament();
			}
		};
		t3.start();
	}
}

//--------------------------------------------------------------------------------------------

	// Using lock() in caller, rather than resource:

	It is allowed to use a lock() within caller, rather than resource, only 
	condition is that,

		- Every call must be within the lock()-unlock().

		- Same lock object must be used for locking and unlocking, if different
		  lock object is used then we will get the parallel execution of threads.

	// Using same lock object in caller

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Runner
{
	int counter=0;
	void increament()
	{
		for(int i=0;i<10;i++)
		{
			counter++;
			System.out.println(Thread.currentThread().getName()+" - "+counter);
			try{Thread.sleep(700);}catch(Exception e){}
		}
	}
}
class DemoRenterentock
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();
		Lock lock=new ReentrantLock();

		Thread t1=new Thread(){
			public void run()
			{
				lock.lock();
				try
				{
					ob.increament();
				}
				catch (Exception e){}
				finally
				{
					lock.unlock();
				}
			}
		};
		t1.start();

		Thread t2=new Thread(){
			public void run()
			{
				lock.lock();
				try
				{
					ob.increament();
				}
				catch (Exception e){}
				finally
				{
					lock.unlock();
				}
			}
		};
		t2.start();
	}
}
-------- Output on Run -----------
Thread-0 - 1
Thread-0 - 2
Thread-0 - 3
Thread-0 - 4
Thread-0 - 5
Thread-0 - 6
Thread-0 - 7
Thread-0 - 8
Thread-0 - 9
Thread-0 - 10
Thread-1 - 11
Thread-1 - 12
Thread-1 - 13
Thread-1 - 14
Thread-1 - 15
Thread-1 - 16
Thread-1 - 17
Thread-1 - 18
Thread-1 - 19
Thread-1 - 20
Press any key to continue . . .

//--------------------------------------------------------------------------------------------


	// Using different lock object in the caller

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Runner
{
	int counter=0;
	void increament()
	{
		for(int i=0;i<10;i++)
		{
			counter++;
			System.out.println(Thread.currentThread().getName()+" - "+counter);
			try{Thread.sleep(700);}catch(Exception e){}
		}
	}
}
class DemoRenterentock
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();
		Lock lock=new ReentrantLock();
		Lock lock1=new ReentrantLock();

		Thread t1=new Thread(){
			public void run()
			{
				lock.lock();
				try
				{
					ob.increament();
				}
				catch (Exception e)	{}
				finally
				{
					lock.unlock();
				}
			}
		};
		t1.start();

		Thread t2=new Thread(){
			public void run()
			{
				lock1.lock();
				try
				{
					ob.increament();
				}
				catch (Exception e)	{}
				finally
				{
					lock1.unlock();
				}
			}
		};
		t2.start();
	}
}
--------------- Output on Run ---------------------

Thread-1 - 2
Thread-0 - 2
Thread-1 - 3
Thread-0 - 4
Thread-1 - 5
Thread-0 - 5
Thread-0 - 6
Thread-1 - 7
Thread-0 - 8
Thread-1 - 9
Thread-0 - 10
Thread-1 - 10
Thread-0 - 12
Thread-1 - 11
Thread-0 - 13
Thread-1 - 13
Thread-0 - 14
Thread-1 - 15
Thread-1 - 16
Thread-0 - 17
Press any key to continue . . .

//------------------------------------------------------------------------------------------------------------------


	- Accessing a different method from shared resource using different threads

	When a resource contains the two methods and both will be accessed by
	different threads, then without using the lock it will executes in the parallel 
	manner but using same lock, it will attend synchronization.


import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
class Runner
{
	int counter=0;
	Lock lock=new ReentrantLock();
	void increament()
	{
		lock.lock();
		try
		{
			for(int i=0;i<10;i++)
			{
				counter++;
				System.out.println("INC - "+Thread.currentThread().getName()+" - "+counter);
				try{Thread.sleep(700);}catch(Exception e){}
			}
		}
		catch(Exception e){}
		finally
		{
			lock.unlock();
		}
	}
	void decreament()
	{
		lock.lock();
		try
		{
			for(int i=0;i<10;i++)
			{
				counter--;
				System.out.println("DEC - "+Thread.currentThread().getName()+" - "+counter);
				try{Thread.sleep(700);}catch(Exception e){}
			}
		}
		catch(Exception e){}
		finally
		{
			lock.unlock();
		}
	}
}
class DemoRenterentock1
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();

		Thread t1=new Thread(){
			public void run()
			{
				ob.increament();
			}
		};
		t1.start();

		Thread t2=new Thread(){
			public void run()
			{
				ob.decreament();
			}
		};
		t2.start();
	}
}
//---------------------------------------------------------------------------------------------------------

	/// producer-consumer using lock again

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Resource {
    private int value;
    private final Lock lock = new ReentrantLock();
    private final Condition notFull = lock.newCondition();
    private final Condition notEmpty = lock.newCondition();

    public Resource() {
        value = 0;
    }

    public int getValue() {
        lock.lock();
        try {
            return value;
        } finally {
            lock.unlock();
        }
    }

    public void incr() {
        lock.lock();
        try {
            while (value == 1) {
                try {
                    notFull.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            value++;
            System.out.println("After Produce Value is: " + value);
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public void decr() {
        lock.lock();
        try {
            while (value == 0) {
                try {
                    notEmpty.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            value--;
            System.out.println("After consume Value is: " + value);
            notFull.signal();
        } finally {
            lock.unlock();
        }
    }
}

class Producer extends Thread {
    Resource res;

    public Producer(Resource res) {
        this.res = res;
        start();
    }

    public void run() {
        while (true) {
            res.incr();
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class Consumer extends Thread {
    Resource res;

    public Consumer(Resource res) {
        this.res = res;
        start();
    }

    public void run() {
        while (true) {
            res.decr();
            try {
                Thread.sleep(800);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class MainPCUsingLock2 {
    public static void main(String[] args) {
        Resource ob = new Resource();

        Producer p = new Producer(ob);
        Consumer c = new Consumer(ob);
    }
}

//------------------------------------------------------------------------------------------------------------------------

// Lets see the another program (Reader - Writer using Locks)

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.Random;

class Message {
    private String message;
    private boolean empty = true;
    private Lock lock = new ReentrantLock();
    private Condition notEmpty = lock.newCondition();
    private Condition notFull = lock.newCondition();

    // Method used by reader
    public String read() throws InterruptedException {
        lock.lock();
        try {
            while (empty) {
                notEmpty.await(); // Wait until a message is available
            }
            empty = true; // Reader reads the message and marks empty as true
            notFull.signalAll(); // Signal that space is available for writing
            return message; //Reader reads the message
        } finally {
            lock.unlock();
        }
    }

    // Method used by writer
    public void write(String message) throws InterruptedException {
        lock.lock();
        try {
            while (!empty) {
                notFull.await(); // Wait until the message has been read
            }
            this.message = message; // Writer writes the message
            empty = false; // Now make empty as false
            notEmpty.signalAll(); // Signal that a new message is available for reading
        } finally {
            lock.unlock();
        }
    }
}

class Writer implements Runnable {
    private Message message;

    public Writer(Message message) {
        this.message = message;
    }

    public void run() {
        String messages[] = {
            "Johnny, Johnny, Yes Papa",
            "Eating sugar? No, Papa!",
            "Telling lies? No, Papa!",
            "Open your mouth, Ha! Ha! Ha!"
        };

        Random random = new Random();

        for (int i = 0; i < messages.length; i++) {
            try {
                message.write(messages[i]);
                Thread.sleep(random.nextInt(2000)); // Simulate some time taken to write a message
            } catch (InterruptedException e) {
                System.out.println("Writer Thread Interrupted!!!");
            }
        }

        try {
            message.write("Finished!");
        } catch (InterruptedException e) {
            System.out.println("Writer Thread Interrupted!!!");
        }
    }
}

class Reader implements Runnable {
    private Message message;

    public Reader(Message message) {
        this.message = message;
    }

    public void run() {
        Random random = new Random();
        try {
            for (String latestMessage = message.read(); !"Finished!".equals(latestMessage); latestMessage = message.read()) {
                System.out.println(latestMessage); // Print the message
                Thread.sleep(random.nextInt(2000)); // Simulate some time taken to read a message
            }
        } catch (InterruptedException e) {
            System.out.println("Reader Thread Interrupted!!!");
        }
    }
}

public class MainReaderWriter1 {
    public static void main(String[] args) {

        // Shared message object between Reader and Writer threads
        Message message = new Message();

        // Create and start writer and reader threads
        Thread writerThread1 = new Thread(new Writer(message));
        Thread readerThread1 = new Thread(new Reader(message));

        Thread writerThread2 = new Thread(new Writer(message));
        Thread readerThread2 = new Thread(new Reader(message));

        writerThread1.start();
        readerThread1.start();

        writerThread2.start();
        readerThread2.start();
    }
}

Java Lock vs synchronized

	Based on above details and program, we can easily conclude following differences between Java Lock 
	and synchronization.

	- Java Lock API provides more visibility and options for locking, unlike synchronized where a thread 
	  might end up waiting indefinitely for the lock, we can use tryLock() to make sure thread waits for 
	  specific time only.

	- Synchronization code is much cleaner and easy to maintain whereas with Lock we are forced to have 
	  try-finally block to make sure Lock is released even if some exception is thrown between lock() and unlock() 
	  method calls.

	- synchronization blocks or methods can cover only one method whereas we can acquire the lock in one method 
	  and release it in another method with Lock API.

	- synchronized keyword doesn’t provide fairness whereas we can set fairness to true while creating 
	  ReentrantLock object so that longest waiting thread gets the lock first.

	- We can create different conditions for Lock and different thread can await() for different conditions.

//--------------------------------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------------------------------------------

	
// Executors in java: 
// ------------------

	// In the threading also you are defining the procedures, which are executed
	// and will gives you the desired output, as given by the programs that we
	// have seen before the multithreading. Only difference is that all the code
	// groups will execute in the parallel manner.

	There are different ways of defining the task(procedures)

		- define it with the run method of class extending the Thread or implementing
		  the runnable interface. Both are made to execute in a parallel manner.

		- define a task as a part of normal class and call it from the run method.

 // Suppose we have to find the total of number from 1 to 10, we can write it 
 // as a method in a simple class, and call using its object. but if you want to call
 // it multiple time and want to execute in the parallel manner the thread is a 
 // correct option coz in case of normal method there may be a multipe calls but
 // it will be executed in a sequence.

 Lets try with a single thread which will gives you a clear idea of how to define
 a task, within a thread.

class ExecuteTask extends Thread
{
	public void run()
	{
		int tot=0;
		for(int i=0;i<=10;i++)
		{
			tot=tot+i;
			System.out.println("i=: "+i);
			try{Thread.sleep(700);}catch(Exception e){}
		}
		System.out.println("\n Total is: "+tot);
	}
}
class StartingTheTaskEx
{
	public static void main(String[] args) 
	{
		ExecuteTask me1=new ExecuteTask ();
		me1.start();
	}
}

//--------------------------

Can be written in a different way where Task and Thread are defined in seperate classes. (seperations of cocerns)

class Task
{
	int tot=0;
	public void calcSum() {
		for(int i=0;i<=10;i++)
		{
			tot=tot+i;
			System.out.println("i=: "+i);
			try{Thread.sleep(700);}catch(Exception e){}
		}
		System.out.println("\n Total is: "+tot);
	}
}
class TaskExecuter extends Thread
{
	Task tob;
	public TaskExecuter(Task tob) {
		this.tob = tob;
	}
	public void run()
	{
		tob.calcSum();
	}
}
class StartingTheTaskEx1
{
	public static void main(String[] args) 
	{
		Task tob = new Task();
		TaskExecuter me1=new TaskExecuter (tob);
		me1.start();
	}
}

//----------------------------------------------------------------

	// Now Lets modify the the above program and execute the task of adding number
	// from different which is executed by same thread and therefore it is called
	// Executer therad, (In out case SumExecuter)


class MyTask
{
	int start,end;
	public MyTask(int start, int end)
	{
		this.start=start;
		this.end=end;
	}
	void findTotal()
	{
		int tot=0;
		for(int i=start;i<=end;i++)
		{
			tot=tot+i;
			try{Thread.sleep(1000);}catch(Exception e){}
			System.out.println("Processing..."+Thread.currentThread().getName());
		}
		System.out.println("\n Total is: "+tot);;
	}
}
class SumExecutor extends Thread
{
	MyTask task;
	public SumExecutor(MyTask task)
	{
		this.task=task;
		start();
	}
	public void run()
	{
		task.findTotal();
	}
}
class StartingTheTaskEample
{
	public static void main(String[] args) 
	{
		MyTask task1=new MyTask(2,7);
		SumExecutor me1=new SumExecutor(task1);

		MyTask task2=new MyTask(1,5);
		SumExecutor me2=new SumExecutor(task2);

		MyTask task3=new MyTask(5,10);
		SumExecutor me3=new SumExecutor(task3);;
	}
}

//---------------------------------------------------------------------------------

	// Note carefully that if we want to execute all theads in a synchronized
	// manner then we have to go for either synchronized keyword or lock.

	// but we are facing the difficulty while using it for the thread management
	// (i.e. resource allocation, thread pooling, thread Control etc...)

	so we need one standard aritecture to handle it and that is provided in java 5,
	called executor.

	In the java mutithreading, we can divide the entire work in two different steps, 
	- first is defining a task and 
	- second the thread management which includes thread creation, pooling, and lifecycle management etc.

	The task being done by a new thread, as defined by its Runnable object, and the thread itself, 
	as defined by a Thread object. This works well for small applications, but in large-scale applications,
 	it makes sense to separate thread management and creation from the rest of the application. Objects 
	that encapsulate these facilities are known as executors.

	This high-level concurrency attended by using concurrency API in the java.util.concurrent package 
	that provides utility classes commonly useful in concurrent programming such as executors, threads 
	pool management, scheduled tasks execution, the Fork/Join framework(new in JDK 7), concurrent 
	collections, etc.

	In Java, an Executor is an interface in the java.util.concurrent package that provides a way to 
	decouple task submission from the mechanics of how each task will be run, including details like 
	thread use, scheduling, etc. It's essentially a framework for executing tasks asynchronously.

	Here's a detailed breakdown of how Executor works:

	- Decoupling Task Submission: Instead of directly creating threads to execute tasks, you submit 
	  tasks to an executor. This decouples the task submission from the execution mechanism. This 
	  decoupling is beneficial because it allows the executor framework to manage the execution details, 
	  such as thread creation, pooling, and lifecycle management.

	- Executor Interface: The Executor interface declares a single method void execute(Runnable command). 
	  This method accepts a Runnable object, which represents a task that can be executed asynchronously.

	  [Synchronous Execution: A task is synchronous if the caller thread waits for the task to complete before 
	    proceeding. The calling thread is blocked until the task finishes. Example: Traditional method calls, 
	    single-threaded programs.

	    Asynchronous Execution: A task is asynchronous if it runs in the background, allowing the caller thread 
	    to continue execution without waiting. The calling thread does not wait for the task to finish. 
	    Example: Multi-threading, Executors.
	  ]

	- ExecutorService: The ExecutorService interface extends Executor and provides additional methods to 
	  manage the lifecycle of the executor, such as shutting it down, waiting for tasks to complete, etc. 
	  It also defines methods for submitting tasks that can return a Future object representing the 
	  result of the computation.

	- ThreadPoolExecutor: This is one of the most commonly used implementations of the ExecutorService 
	  interface. It manages a pool of worker threads and a queue of tasks waiting to be executed. When 
	  a task is submitted to a ThreadPoolExecutor, it is executed either by an existing thread in the 
	  pool or by creating a new one, depending on the current state of the pool.

	- Executor Execution Policies: Executors can have different policies for executing tasks, such as 
	  fixed-size thread pools, cached thread pools, single-threaded executors, etc. These policies 
	  determines how tasks are executed based on factors like thread availability, task priority, 
	  and queueing strategy.

	- Task Execution: When a task is submitted to an executor, it is typically added to a queue. The 
	  executor then picks up tasks from the queue and executes them using one or more threads from its 
	  thread pool. The exact mechanism of task execution depends on the type of executor and its 
	  configuration.

	- Exception Handling: Executors provide mechanisms for handling exceptions that occur during task 
	  execution. 
	  For example, Future objects returned by some executor methods can be used to retrieve the result 
	  of a task and handle any exceptions that occurred during its execution.


	Understanding Thread Pool in Java
	-----------------------------------

	In terms of performance, creating a new thread is an expensive operation because it requires the 
	operating system allocates resources needed for the thread. Therefore, in practice thread pool is 
	used for large-scale applications that launch a lot of short-lived threads in order to utilize 
	resources efficiently and increase performance.

	Instead of creating new threads when new tasks arrive, a thread pool keeps a number of idle threads 
	that are ready for executing tasks as needed. After a thread completes execution of a task, it does 
	not die. Instead it remains idle in the pool waiting to be chosen for executing new tasks.

	You can limit a definite number of concurrent threads in the pool, which is useful to prevent overload.
	If all threads are busily executing tasks, new tasks are placed in a queue, waiting for a thread 
	becomes available.

	The Java Concurrency API supports the following types of thread pools:

		- Cached thread pool: keeps a number of alive threads and creates new ones as needed.

		- Fixed thread pool: limits the maximum number of concurrent threads. Additional tasks are 
				     waiting in a queue.

		- Single-threaded pool: keeps only one thread executing one task at a time.

		- Fork/Join pool: a special thread pool that uses the Fork/Join framework to take advantages of 
			     	  multiple processors to perform heavy work faster by breaking the work into smaller 
				  pieces recursively.

	That’s basically how thread pool works. In practice, thread pool is used widely in web servers where a thread pool is 
	used to serve client’s requests. Thread pool is also used in database applications where a pool of threads maintaining 
	open connections with the database.

	Implementing a thread pool is a complex task, but you don’t have to do it yourself. As the Java Concurrency API allows 
	you to easily create and use thread pools without worrying about the details


	Understanding Executors in Java
	An Executor is an object that is responsible for threads management and execution of Runnable tasks submitted 
	from the client code. It decouples the details of thread creation, scheduling, etc from the task submission 
	so you can focus on developing the task’s business logic without caring about the thread management details.


	The Java Concurrency API defines the following 3 base interfaces for executors:

		- Executor: is the super type of all executors. It defines only one method execute(Runnable).

		- ExecutorService: is an Executor that allows tracking progress of value-returning tasks (Callable) via 
		  Future object, and manages the termination of threads. Its key methods include submit() and shutdown().

		- ScheduledExecutorService: is an ExecutorService that can schedule tasks to execute after a given delay, 
		  or to execute periodically. Its key methods are schedule(), scheduleAtFixedRate() and scheduleWithFixedDelay().
		  
	You can create an executor by using one of several factory methods provided by the 
	Executors utility class.

	Executor (Interface)
	│
	├── ExecutorService (Interface)
	│   ├── AbstractExecutorService (Class)
	│   │   ├── ThreadPoolExecutor (Class)
	│   │   ├── ScheduledThreadPoolExecutor (Class)
	│   │   └── ForkJoinPool (Class)
	│   │
	│   ├── ScheduledExecutorService (Interface)
	│   │   └── ScheduledThreadPoolExecutor (Class)
	│   │
	│   ├── ForkJoinPool (Class)
	│   ├── ThreadPoolExecutor (Class)
	│   ├── ScheduledThreadPoolExecutor (Class)
	│   ├── DelegatedExecutorService (Class)
	│   ├── FinalizableDelegatedExecutorService (Class)
	│   ├── Executors (Utility Class)
	│
	└── ExecutorCompletionService (Class)


	Knowing the Executors class:

	In Java, the Executors class is a part of the java.util.concurrent package and serves as a factory 
	and utility class for creating and managing instances of ExecutorService, which provides a way to 
	manage asynchronous tasks.

	This class supports the following kinds of methods:
	- Methods that create and return an ExecutorService set up with commonly useful configuration settings.
	- Methods that create and return a ScheduledExecutorService set up with commonly useful 
	  configuration settings.
	- Methods that create and return a "wrapped" ExecutorService, that disables reconfiguration by making 
	  implementation-specific methods inaccessible.
	- Methods that create and return a ThreadFactory that sets newly created threads to a known state.
	- Methods that create and return a Callable out of other closure-like forms, so they can be used in 
	  execution methods requiring Callable.

	 Here are some commonly used methods provided by the java.util.concurrent.Executors class:

	- newFixedThreadPool(int nThreads):Creates a thread pool that reuses a fixed number of threads.

	- newCachedThreadPool():Creates a thread pool that creates new threads as needed but reuses existing 
		ones when they are available.

	- newSingleThreadExecutor(): Creates a single-threaded executor that uses a single worker thread 
		operating off an unbounded queue.

	- newScheduledThreadPool(int corePoolSize): Creates a thread pool that can schedule commands to 
		run after a given delay or to execute periodically.

	- newSingleThreadScheduledExecutor():Creates a single-threaded executor that can schedule commands 
		to run after a given delay or to execute periodically.

	- newWorkStealingPool():Creates a thread pool that maintains enough threads to support the given 
		parallelism level and may use multiple queues to reduce contention.

	- newFixedThreadPool(int nThreads, ThreadFactory threadFactory):Creates a thread pool that reuses a 
		fixed number of threads, using a provided ThreadFactory to create new threads.

	- newSingleThreadExecutor(ThreadFactory threadFactory): Creates a single-threaded executor that uses 
		a single worker thread operating off an unbounded queue, using a provided ThreadFactory 
		to create new threads.

	- newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory):Creates a thread pool that can 
		schedule commands to run after a given delay or to execute periodically, using a provided 
		ThreadFactory to create new threads.

	- newSingleThreadScheduledExecutor(ThreadFactory threadFactory):Creates a single-threaded executor 
		that can schedule commands to run after a given delay or to execute periodically, using a 
		provided ThreadFactory to create new threads.

	Simple Executor and ExecutorService Examples:
	----------------------------------------------
 
/**
 * This program demonstrates how to create a single-threaded executor
 * to execute a Runnable task.
 */
 /*

// single task 

import java.util.concurrent.*;
public class SimpleExecutorExample {
 
    public static void main(String[] args) {
        ExecutorService pool = Executors.newSingleThreadExecutor();
 
        Runnable task = new Runnable() {
            public void run() {
		for(int i=0;i<10;i++) {
			System.out.println(Thread.currentThread().getName()+" - "+i);
			try{Thread.sleep(800);}catch(Exception e){}
		}
            }
        }; 
        pool.execute(task);
        pool.shutdown();
    }
}

//----------------------------------------------------------------------------------------------------------------------

/// Multiple tasks

import java.util.concurrent.*;
public class SimpleExecutorExample {
 
    public static void main(String[] args) {
          ExecutorService pool = Executors.newSingleThreadExecutor();	
        // ExecutorService pool = Executors.newCachedThreadPool();
		// check the output, uncommenting above and commenting exsisting 
 
        Runnable task = new Runnable() {
            public void run() {
				for(int i=0;i<10;i++)
				{
					System.out.println(Thread.currentThread().getName()+" - "+i);
					try{Thread.sleep(800);}catch(Exception e){}
				}
            }
        }; 
        pool.execute(task);
 
        Runnable task1 = new Runnable() {
            public void run() {
				for(int i=0;i<10;i++)
				{
					System.out.println(Thread.currentThread().getName()+" - "+i);
					try{Thread.sleep(800);}catch(Exception e){}
				}
            }
        }; 
        pool.execute(task1);
 
        pool.shutdown();
    }
}	

//----------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------

	Java Callable and Future
	--------------------------

	Java Callable and Future are used a lot in multithreaded programming. we learned a lot about java threads but 
	sometimes we wish that a thread could return some value that we can use. Java 5 introduced java.util.concurrent.
	Callable interface in concurrency package that is similar to Runnable interface but it can return any Object 
	and able to throw Exception.

	The ExecutorServiceinterface defines a method that allows us to execute such kind of value-returning tasks:
	Future is an interface introduced in Java 5 that represents the result of an asynchronous computation. It allows 
	you to start a task, continue with other work, and later retrieve the result when it's ready.

     	<T> Future<T> submit(Callable<T> task)

	Here, the type parameter T is the return type of the task. You submit a task that implements the Callable

import java.util.concurrent.*;
 
/**
 * This program demonstrates how to create a single-threaded executor
 * to execute a Callable task.
 */
public class SimpleExecutorServiceExample {
 
    public static void main(String[] args) {

        ExecutorService pool = Executors.newSingleThreadExecutor();	
	
        Callable<Integer> task = new Callable<Integer>() {
            public Integer call() {
				int i=0, tot=0;
                try {
                    //task
					for(i=0;i<=10;i++)
					{
						tot=tot+i;
						Thread.sleep(1000);
						System.out.println("result = " + tot);
					}
                } catch (InterruptedException ex) {
                    ex.printStackTrace();
                }
 
                return tot;
            }
        };
 
        Future<Integer> result = pool.submit(task);
 
        try {
 
            Integer returnValue = result.get();
 
            System.out.println("Final result = " + returnValue);
 
        } catch (InterruptedException | ExecutionException ex) {
            ex.printStackTrace();
        }
 
        pool.shutdown();
    }
}

//-------------------------------

	CompletableFuture is an enhancement to the Future concept, introduced in Java 8. It allows you to 
	create more complex asynchronous workflows, making it easier to chain multiple asynchronous tasks.


//------------------------------------------------------------------------------------------------------------------------

	// Java Cached Thread Pool Executor Example
	
	The following example shows you how to create a cached thread pool to execute some tasks concurrently. 
	Given the following class:

/**
 * This class represents a coutdown clock.
 */
import java.util.concurrent.*;
class CountDownClock extends Thread {
    private String clockName;
 
    public CountDownClock(String clockName) {
        this.clockName = clockName;
    }
 
    public void run() {
        String threadName = Thread.currentThread().getName();
 
        for (int i = 5; i >= 0; i--) {
 
            System.out.printf("%s -> %s: %d\n", threadName, clockName, i);
 
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }
} 
/**
 * This program demonstrates how to execute multiple tasks
 * with different kinds of executors.
 */
public class MultipleTasksExecutorExample {
 
    public static void main(String[] args) {
 
        ExecutorService pool = Executors.newCachedThreadPool();
 
        pool.execute(new CountDownClock("A"));
        pool.execute(new CountDownClock("B"));
        pool.execute(new CountDownClock("C"));
        pool.execute(new CountDownClock("D"));
        pool.execute(new CountDownClock("E"));
 
        pool.shutdown();
 
    }
}

//-------------------------------------------------------------------------------------------------------------

Fixed Thread Pool Executor Example
----------------------------------

/**
 * This class represents a coutdown clock.
 */
import java.util.concurrent.*;
class CountDownClock extends Thread {
    private String clockName;
 
    public CountDownClock(String clockName) {
        this.clockName = clockName;
    }
 
    public void run() {
        String threadName = Thread.currentThread().getName();
 
        for (int i = 5; i >= 0; i--) {
 
            System.out.printf("%s -> %s: %d\n", threadName, clockName, i);
 
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }
} 
/**
 * This program demonstrates how to execute multiple tasks
 * with different kinds of executors.
 */
public class FixedeTasksExecutorExample {
 
    public static void main(String[] args) {
 
        ExecutorService pool = Executors.newFixedThreadPool(2);
 
        pool.execute(new CountDownClock("A"));
        pool.execute(new CountDownClock("B"));
        pool.execute(new CountDownClock("C"));
        pool.execute(new CountDownClock("D"));
        pool.execute(new CountDownClock("E"));
 
        pool.shutdown();
 
    }
}

//----------------------------------------------------------------------------------------------------------------------

Single-threaded Pool Executor Example
--------------------------------------

/**
 * This class represents a coutdown clock.
 */
import java.util.concurrent.*;
class CountDownClock extends Thread {
    private String clockName;
 
    public CountDownClock(String clockName) {
        this.clockName = clockName;
    }
 
    public void run() {
        String threadName = Thread.currentThread().getName();
 
        for (int i = 5; i >= 0; i--) {
 
            System.out.printf("%s -> %s: %d\n", threadName, clockName, i);
 
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
        }
    }
} 
/**
 * This program demonstrates how to execute multiple tasks
 * with different kinds of executors.
 */
public class SingleTasksExecutorExample {
 
    public static void main(String[] args) {
 
        ExecutorService pool = Executors.newSingleThreadExecutor();
 
        pool.execute(new CountDownClock("A"));
        pool.execute(new CountDownClock("B"));
        pool.execute(new CountDownClock("C"));
        pool.execute(new CountDownClock("D"));
 
        pool.shutdown();
 
    }
}


//--------------------------------------------------------------------------------------------------------------------------

	Custom Thread Pool Executor
	-----------------------------

	In case you want to have more control over the behaviors of a thread pool, you can create a thread pool executor 
	directly from the ThreadPoolExecutorclass instead of the factory methods of the Executors utility class.

	For example, the ThreadPoolExecutor has a general purpose constructor as follows:

	public ThreadPoolExecutor(int corePoolSize,
                  int maximumPoolSize,
                  long keepAliveTime,
                  TimeUnit unit,
                  BlockingQueue<Runnable> workQueue)

	You can tweak the parameters to suit your need, as long as you really understand what they mean:

	- corePoolSize: the number of threads to keep in the pool.
	- maximumPoolSize: the maximum number of threads to allow in the pool.
	- keepAliveTime: if the pool currently has more than corePoolSize threads, excess threads will be terminated 
			if they have been idle for more than keepAliveTime.
	- unit: the time unit for the keepAliveTime argument. Can be NANOSECONDS, MILLISECONDS, SECONDS, MINUTES, HOURS and DAYS.
	- workQueue: the queue used for holding tasks before they are executed. Default choices are SynchronousQueue 
		     for multi-threaded pools and LinkedBlockingQueue for single-threaded pools.

	Let’s see an example. The following code creates a cached thread pool that keeps minimum of 10 threads and allow 
	maximum of 1,000 threads, and idle threads are kept in the pool for 120 seconds:

	int corePoolSize = 10;
	int maxPoolSize = 1000;
	int keepAliveTime = 120;
	BlockingQueue<Runnable> workQueue = new SynchronousQueue<Runnable>();
 
	ThreadPoolExecutor pool = new ThreadPoolExecutor(corePoolSize, maxPoolSize, keepAliveTime, TimeUnit.SECONDS, workQueue);
	pool.execute(new RunnableTask());

//------------------------------------------------------------

	Fork/Join is a framework (new in JDK 7) for taking advantage of multiple processors.
	---------------------------------------------------------------------------------------

	The Fork/Join framework was indeed introduced in Java 7 as part of the java.util.concurrent package. 
	It's designed to make it easier to write parallelizable algorithms by decomposing them into smaller tasks 
	that can be executed concurrently, taking advantage of multiple processors or cores.

	Here's a brief overview of the Fork/Join framework:

	o- Divide and Conquer: The Fork/Join framework follows the divide-and-conquer paradigm. It breaks down a 
	   large task into smaller subtasks, which are executed independently in parallel. Once the subtasks are 
           completed, their results are combined to produce the final result of the original task.

	o- Work-Stealing Algorithm: Fork/Join employs a work-stealing algorithm to achieve load balancing among worker 
	   threads. Each worker thread maintains its own deque (double-ended queue) of tasks. When a thread finishes 
	   executing its tasks, it can "steal" tasks from the deque of another thread that is busy or has more tasks 
	   queued.

	o- Main Components:
	 - ForkJoinPool: The central component of the Fork/Join framework. It manages a pool of worker threads 
	   and distributes tasks among them.
	 - ForkJoinTask: Represents a task that can be executed asynchronously in the Fork/Join pool. It's an abstract 
	   class that can be subclassed to define specific tasks.
	 - RecursiveAction and RecursiveTask: Subclasses of ForkJoinTask. RecursiveAction is used for tasks that don't 
	   return a result, while RecursiveTask is used for tasks that produce a result.

	o- Parallelism and Concurrency: The Fork/Join framework allows developers to write parallel algorithms easily, 
	   taking advantage of the parallelism offered by modern multi-core processors. By decomposing tasks into 
	   smaller units of work and executing them concurrently, it can significantly improve the performance of 
	   certain types of computations.


import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

public class ArraySumExample extends RecursiveTask<Long> {
    private static final int THRESHOLD = 1000;
    private int[] array;
    private int start;
    private int end;

    public ArraySumExample(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            // Compute sum sequentially for small arrays
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        } else {
            // Divide the array into smaller subarrays
            int mid = (start + end) / 2;
            ArraySumExample leftTask = new ArraySumExample(array, start, mid);
            ArraySumExample rightTask = new ArraySumExample(array, mid, end);

            // Fork the left and right subtasks
            leftTask.fork();
            long rightResult = rightTask.compute();

            // Join the results of the left and right subtasks
            long leftResult = leftTask.join();

            // Combine the results
            return leftResult + rightResult;
        }
    }

    public static void main(String[] args) {
        int[] array = new int[10000];
        // Initialize array with random values
        for (int i = 0; i < array.length; i++) {
            array[i] = (int) (Math.random() * 100);
        }

        // Create a ForkJoinPool
        ForkJoinPool pool = new ForkJoinPool();

        // Create a task to compute the sum of the array
        ArraySumExample task = new ArraySumExample(array, 0, array.length);

        // Execute the task in the pool
        long result = pool.invoke(task);

        // Print the result
        System.out.println("Sum of the array: " + result);
    }
}

//---------------------------------------------------------------------


import java.util.concurrent.Semaphore;

class Resource {
    private int value = 0;

    // Semaphores
    private final Semaphore emptySlots = new Semaphore(1); // Allow 1 production
    private final Semaphore filledSlots = new Semaphore(0); // Block consumption until produced
    private final Semaphore mutex = new Semaphore(1); // Ensure mutual exclusion

    public int getValue() {
        return value;
    }

    public void produce() throws InterruptedException {
        emptySlots.acquire(); // Wait if already produced
        mutex.acquire(); // Lock resource

        value++;
        System.out.println("Produced - Value: " + value);

        mutex.release(); // Unlock resource
        filledSlots.release(); // Signal consumer that item is available
    }

    public void consume() throws InterruptedException {
        filledSlots.acquire(); // Wait if no item is available
        mutex.acquire(); // Lock resource

        value--;
        System.out.println("Consumed - Value: " + value);

        mutex.release(); // Unlock resource
        emptySlots.release(); // Signal producer that space is available
    }
}

public class ProducerConsumerExample11 {
    public static void main(String[] args) {
        Resource rob = new Resource();

        // Producer Thread
        Thread producer = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                try {
                    Thread.sleep(300); // Simulate production time
                    rob.produce();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // Consumer Thread
        Thread consumer = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                try {
                    Thread.sleep(300); // Simulate consumption time
                    rob.consume();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        producer.start();
        consumer.start();
    }
}

//---------------------------------------------------------------------

	Semaphore in java   
	-----------------
	(Semaphore: Dictionary meaning - an apparatus for conveying information by means of visual signals)

	Semaphore in Java (Concurrency API)
	A Semaphore in Java is a thread synchronization mechanism used to control access to shared resources 
	by multiple threads. It is part of the java.util.concurrent package.

	What is a Semaphore?
	- Semaphore maintains a set of permits.
	- A thread must acquire a permit before accessing a resource.
	- If no permits are available, the thread waits until one is released.
	- When a thread is done, it releases the permit, allowing another thread to proceed.	

	Types of Semaphore in Java
	- Counting Semaphore – Allows multiple permits (e.g., limit access to threads at a time).
	- Binary Semaphore (like a mutex) – Allows only one thread at a time (like synchronized).

import java.util.concurrent.Semaphore;
class Resource
{
	int []x = {11,22,33,44,55,66,77,88,99};	
	// Semaphore semaphore = new Semaphore(1);
	// Semaphore semaphore = new Semaphore(2);
	 Semaphore semaphore = new Semaphore(3);
	 Semaphore semaphore = new Semaphore(3,true);
	public void show() {
		try
		{
			semaphore.acquire();
			for(int i=0;i<10;i++)
			{
				System.out.println(Thread.currentThread().getName()+" - "+i);
				try{Thread.sleep(800);}catch(Exception e){}
			}
		}
		catch (Exception e) {}
		finally {
			System.out.println(Thread.currentThread().getName() + " released permit.");
			semaphore.release();
		}
	}
}
class DemoSemophare
{
	public static void main(String[] args) 
	{
		Resource res = new Resource();		
		for(int i=0 ; i<5 ; i++) {
			new Thread(){
				public void run() {
					res.show();
				}
			}.start();
		}
	}
}


//---------------------------------------------

Here's your Producer-Consumer example rewritten using Semaphores instead of wait() and notify().
import java.util.concurrent.Semaphore;

class Resource {
    private int value = 0;

    // Semaphores
    private final Semaphore emptySlots = new Semaphore(1); // Allow 1 production
    private final Semaphore filledSlots = new Semaphore(0); // Block consumption until produced
    private final Semaphore mutex = new Semaphore(1); // Ensure mutual exclusion

    public int getValue() {
        return value;
    }

    public void produce() throws InterruptedException {
        emptySlots.acquire(); // Wait if already produced
        mutex.acquire(); // Lock resource

        value++;
        System.out.println("Produced - Value: " + value);

        mutex.release(); // Unlock resource
        filledSlots.release(); // Signal consumer that item is available
    }

    public void consume() throws InterruptedException {
        filledSlots.acquire(); // Wait if no item is available
        mutex.acquire(); // Lock resource

        value--;
        System.out.println("Consumed - Value: " + value);

        mutex.release(); // Unlock resource
        emptySlots.release(); // Signal producer that space is available
    }
}

public class ProducerConsumerExample11 {
    public static void main(String[] args) {
        Resource rob = new Resource();

        // Producer Thread
        Thread producer = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                try {
                    Thread.sleep(300); // Simulate production time
                    rob.produce();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // Consumer Thread
        Thread consumer = new Thread(() -> {
            for (int i = 0; i < 15; i++) {
                try {
                    Thread.sleep(300); // Simulate consumption time
                    rob.consume();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        producer.start();
        consumer.start();
    }
}

//-------------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------------

	- Daemon Thread
       ------------------

	What is Daemon Thread in Java?
	Daemon thread in Java is a low-priority thread that performs background operations such as garbage collection, 
	finalizer, Action Listeners, Signal dispatches, etc.

	Daemon thread in Java is also a service provider thread that helps the user thread. Its life is at the mercy of user 
	threads; when all user threads expire, JVM immediately terminates this thread.

	In simple words, we can say that it provides services to user threads for background-supporting tasks. Daemon thread 
	in Java has no role in life other than to serve user threads.

	 Properties of Daemon Thread in Java
	- It's a thread with the possible lowest priority
	- They won't be able to stop the JVM from quitting once all of the user threads have completed their tasks.
	- When all user threads have completed their execution, the JVM terminates Daemon Thread.
	- If JVM finds a running daemon thread, it terminates the thread and, after that, shutdown it.
	- The JVM is unconcerned about whether the Daemon thread is active or not.
	- The nature of a demon is passed down from parent to child. That is, if the parent is a Daemon, the child will 
	  be a Daemon as well, and if the parent is a non-daemon, the child will be a non-daemon as well.

Methods for Daemon Thread in Java by Thread Class

 - public void setDaemon(boolean status)	
	This method marks whether the current thread as a daemon thread or a user thread.

 - public final boolean isDaemon()	
	This method is used to determine whether or not the current thread is a daemon. If the thread is Daemon, it returns true. 
	Otherwise, false is returned.

import java.util.Random;
class WorkerThread extends Thread
{
	public WorkerThread()
	{
		start();
	}
	public void run()
	{
		for(int i=0;i<10;i++)
		{
			System.out.println(i+" - "+Thread.currentThread().getName()+" isDaemon: "+Thread.currentThread().isDaemon());
			try{Thread.sleep(new Random().nextInt(1000));}catch(Exception e){}
		}
		System.out.println(Thread.currentThread().getName()+" - Ended");
	}
}
class Runner extends Thread
{
	public void run()
	{
		while(true)
		{
			
			try{Thread.sleep(new Random().nextInt(2000));}catch(Exception e){}
			System.out.println("Ob is Running: "+this.isAlive());
		}			
	}
}
class DaemonThreadExample
{
	public static void main(String[] args) 
	{
		Runner ob=new Runner();
		ob.setDaemon(true);
		ob.start();
		System.out.println("Ob is Running: "+ob.isAlive());

		Thread []tar=new Thread[4];
		for(int i=0;i<tar.length;i++)
		{
			tar[i]=new WorkerThread();
		}

		System.out.println("Ob is Running: "+ob.isAlive());
		System.out.println("Main Ended");
	}
}

//-------------------------------------------------------


Daemon Thread vs User Thread

learn more about the distinctions between Daemon and User threads:

	Daemon Threads					User Threads (Non-daemon)

	- Low Priority threads				- High priority threads
	- The JVM does not wait for its execution 	- The JVM waits till the execution is finished.
	  to complete.
	- Life is dependent on user threads		- Life is independent
	- Daemon threads are created by JVM		- An application creates its own user threads.
	- provides service to the user thread 		- Used for foreground tasks.
	  which runs in the background


//---------------------------------------------------------------------------------------------------------------------

	// Runtime class in java 

	The Runtime class in Java is a part of the java.lang package and represents the runtime environment 
	of the Java application. It allows the application to interact with the JVM (Java Virtual Machine) 
	in various ways, such as executing processes, interacting with the garbage collector, and accessing 
	information about the system.

	When to Use the Runtime Class?
	- Monitoring system resources like memory and processor availability.
	- Running system commands or launching external processes.
	- Registering shutdown hooks for cleanup before application termination.
	- Accessing system-level information for performance optimization.

//Executing a System Command
public class ExecuteCommandExample {
    public static void main(String[] args) {
        try {
            // Get the runtime instance
            Runtime runtime = Runtime.getRuntime();

            // Execute a system command (example: open Notepad in Windows)
            Process process = runtime.exec("notepad");

            // Wait for the process to complete
            process.waitFor();

            System.out.println("Notepad exited.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//Getting Runtime Information

public class RuntimeInfoExample {
    public static void main(String[] args) {
        // Get the runtime instance
        Runtime runtime = Runtime.getRuntime();

        // Print memory details
        System.out.println("Total Memory: " + runtime.totalMemory());
        System.out.println("Free Memory: " + runtime.freeMemory());
        System.out.println("Max Memory: " + runtime.maxMemory());

        // Print available processors
        System.out.println("Available Processors: " + runtime.availableProcessors());
    }
}

//------------------------------
// Code Example: Shutdown Using Runtime Class

import java.io.IOException;

public class ShutdownComputer {
    public static void main(String[] args) {
        // Get the runtime instance
        Runtime runtime = Runtime.getRuntime();

        try {
            // Check the operating system
            String os = System.getProperty("os.name").toLowerCase();

            if (os.contains("win")) {
                // Windows shutdown command
                runtime.exec("shutdown -s -t 0");
            } else if (os.contains("mac")) {
                // macOS shutdown command
                runtime.exec("shutdown -h now");
            } else if (os.contains("nix") || os.contains("nux") || os.contains("aix")) {
                // Linux/Unix shutdown command
                runtime.exec("shutdown -h now");
            } else {
                System.out.println("Unsupported operating system: " + os);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
//----------------------------------------------------------------------------

	Java Shutdown Hook: 

	A Java Shutdown Hook is a feature that allows you to execute custom cleanup code when a Java Virtual 
	Machine (JVM) is shutting down. The shutdown hook is a thread that you can register with the JVM to 
	perform tasks such as closing resources, saving application state, or logging information before the 
	application exits.

	How Shutdown Hook Works
	When the JVM shuts down, either normally (e.g., program exit) or abnormally (e.g., by a user interrupt
	like Ctrl+C), it executes all registered shutdown hooks. However, these hooks will not run in certain 
	situations like:

	- The JVM is forcefully terminated using System.exit() with no hooks registered.
	- The JVM is killed using OS commands like kill -9.

public class ShutdownHookExample {
    public static void main(String[] args) {

        // Registering a shutdown hook
        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Shutdown Hook is running...");
                // Perform cleanup operations here
            }
        }));

        System.out.println("Application is running...");
        
        // Simulate some operation
        try {
            Thread.sleep(5000); // Let the program run for 5 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Application is exiting...");
    }
}

///===============================================================================================================================
///===============================================================================================================================
///===============================================================================================================================

/// Using Java Library Classes: 


	/// java.lang.Object:
	------------------

	In Java, java.lang.Object is the root class of all classes. Every class in Java is a direct or indirect subclass 
	of Object. It's located in the java.lang package, which is automatically imported into every Java program, 
	o you don't need to explicitly import it.

	constructor: 
	 - Object() : Default Constructor.

	The Object class defines several important methods that are available to all Java objects. 
	Some of the most commonly used methods defined in Object are:

	- toString(): Returns a string representation of the object. By default, this method returns the class 
	  name followed by the "@" symbol and the hash code of the object.

	- equals(Object obj): Indicates whether some other object is "equal to" this one. The default implementation 
	  in Object compares object references.

	- hashCode(): Returns a hash code value for the object. The default implementation returns the internal 
	  memory address of the object in hexadecimal form.

	- getClass(): Returns the runtime class of this object. This method returns an instance of the Class class 
	  that provides information about the object's class.

	- notify(), notifyAll(), and wait(): These methods are used for inter-thread communication and synchronization.


	// creating an object of Object class.

class ObjectDemoEx
{
	public static void main(String[] args) 
	{
		Object ob=new Object();
		System.out.println(" Ob Prints: "+ob);
		System.out.println(" tostring Prints: "+ob.toString());
		System.out.println(" hashcode Prints: "+ob.hashCode());
		System.out.println(" getclass Prints: "+ob.getClass());

		String str=new String("hello");
		System.out.println(" equals str Prints: "+ob.equals(str));
		
		Object ob1=new Object();
		System.out.println(" equal another Object Prints: "+ob.equals(ob1));

		Object ob3 = ob;
		System.out.println(" equals same reference Prints: "+ob.equals(ob3));
	}
}


	A hash code is an integer value that is associated with each object in Java. 
	Its main purpose is to facilitate hashing in hash tables, which are used by 
	data structures like HashMap.



	// generally it is the string representation of an object, bydefault its starts with class namethen @ and then 
	// hashcode of object, but it is expected that, override that method in child class to represent the object in 
	// its equivalent object as as you want or as needed.

	// When you print object directly the bydefault toString method is invoked.

class ObjectDemo 
{
	public static void main(String[] args) 
	{
		Object ob=new Object();
		System.out.println(" Ob Prints: "+ob);
		System.out.println(" Ob Prints: "+ob.toString());
	}
}

// which will gives same output.

//---------------------------------------------------------

	// Overriding the toString method: AS any class having the java.lang.Object as parent. we are allowed to 
	   override the toString method.

class MyClass
{
	String info;
}
class ObjectDemoExample
{
	public static void main(String[] args) 
	{
		MyClass ob=new MyClass();
		System.out.println("Object Information: "+ob);
	}
}
	
-------output on run ---------
 Ob Prints: java.lang.Object@372f7a8d
Press any key to continue . . .


class MyClass
{
	String info;
	public String toString()
	{
		return "Printing object inforamtion";
	}
}
class ObjectDemoExample
{
	public static void main(String[] args) 
	{
		MyClass ob=new MyClass();
		System.out.println("Object Information: "+ob);
	}
}
-------output on run ---------
Object Information: Printing object inforamtion
Press any key to continue . . .

//----------------------------------------------------------------------------	

class MyClass extends Thread
{
	Thread t;
	public MyClass()
	{
		super("Thread - 0");
		t=this;
	}
	String info;
	public String toString()
	{
		t=Thread.currentThread();
		info= "["+t.getName()+", "+t.getPriority()+", "+t.getThreadGroup()+"]";
		return info;
	}
}
class ObjectDemoExample
{
	public static void main(String[] args) 
	{
		MyClass ob=new MyClass();
		System.out.println("Object Information: "+ob);
	}
}

//--------------------------------------------------
class MyException extends Exception
{
	String exp_info;
	public MyException(String t)
	{
		exp_info=t;
	}
	public String toString()
	{
		return exp_info;
	}
}

class ObjectDemoExample
{
	public static void main(String[] args) 
	{
		MyException ob=new MyException("Exception inforamtion");
		System.out.println("Object Information: "+ob);
	}
}

//=========================================================================================================

	// Wrapper Classes in Java: 

	- It is actually group of classes, used to represent the data type in its equivalent object form.
	- They are known as wrapper classes, coz individual class represents, i.e. wraps up, one data
	  type within it.
	
		e.g.: just like the classes that we have defined..!!

		class MyIntArray		class MyInt		class MyString
		{				{			{
			int x[];			int no;			char []data;	
			....				.....		 	.....
		} 				}			}

	- Here in java we are unable to pass the the values of builtin type by reference. coz we dont 
	  have ampersand operator or here in java creating alise using &, is not allowed. But as the 
	  object gains the dynamic memory space, it is possible to values of builtin by reference, when
	  they are represented in its equivalent object from.

	- List of data type and provided classes

		----------------------------------------------
		data type			Wrapper class
		----------------------------------------------
		char				Character
		byte				Byte
		short				Short
		int				Integer
		long				Long
		float				Float
		double				Double
		boolean				Boolean
		----------------------------------------------
	 Note that,
			byte b;	   // is a variable
			Byte b;    // is a object

	- Hierarchical diagram of Wrapper classes

	Object
	│
	├─── Number
	│    ├─── Byte
	│    ├─── Short
	│    ├─── Integer
	│    ├─── Long
	│    ├─── Float
	│    └─── Double
	├─── Boolean
	└─── Character


	- Wrapper classes provide useful methods and properties that are not available with primitive data types. 
	- Using Wrapper classes Autoboxing and Unboxing become very easy.
	- They facilitate converting primitive data types into objects and vice versa. 
	- Wrapper classes allow for null values. Primitive data types cannot be null, but their corresponding wrapper classes can.
	  This is beneficial when you need to represent the absence of a value.
	- They simplify casting between different types. 
	- They enable the use of primitive data types in collections and other classes that only work with objects.
	- wrapper classes in Java, provides instances which are immutable. Once created, the value cannot be changed.

//----------------------------------------------------------------

- java.lang.Number Class:
--------------------------
	class Declaration: 
		- public abstract class Number extends Object implements Serializable

	(Serialization in Java refers to the process of converting an object into a byte stream, 
	 which can be easily stored in a file or sent over the network. This byte stream can then be 
	 reconstructed back into an object whenever needed.)

	Constructor: 
		- Number(): 

	methods: 	
	- byte byteValue(): method returning the value of the specified number as a byte.
	- double doubleValue(): Abstract method returning the value of the specified number as a double.
	- float floatValue(): Abstract method returning the value of the specified number as a float.
	- int intValue(): Abstract method returning the value of the specified number as an integer.
	- long longValue(): Abstract method returning the value of the specified number as a long.
	- short shortValue(): method returning the value of the specified number as a short.

	*Note: All these methods are present in all classes used to represent Numeric values.

- java.lang.Byte class:
-------------------------
	The java.lang.Byte class is a wrapper class for the primitive data type byte. It provides methods 
	to parse, convert, and manipulate byte values. 

	Fields:
	- public static final byte MIN_VALUE: The minimum value that a byte can have: -128.
	- public static final byte MAX_VALUE: The maximum value that a byte can have: 127.
	- public static final Class<Byte> TYPE: The Class object representing the primitive type byte.
	- public static int BYTES: The number of bytes used to represent a byte value in two's complement binary form.
	- public static int SIZE: The number of bits used to represent a byte value in two's complement binary form.

	Constructors:
	- public Byte(byte value): Constructs a newly allocated Byte object that represents the specified byte value.
	- public Byte(String s) throws NumberFormatException: Constructs a newly allocated Byte object that represents 
		the byte value indicated by the String parameter. The string is converted to a byte value as if by the 
		byte.parseByte method.

	Methods:
	- public byte byteValue(): Returns the value of this Byte object as a byte primitive.
	- public int compareTo(Byte anotherByte): Compares two Byte objects numerically.
	- public double doubleValue(): Returns the value of this Byte object as a double primitive.
	- public boolean equals(Object obj): Compares this object to the specified object. The result is true if and 
		only if the argument is not null and is a Byte object that contains the same byte value as this object.
		(will checks the references are same or not.)
	- public float floatValue(): Returns the value of this Byte object as a float primitive.
	- public int hashCode(): Returns a hash code for this Byte object.
	- public int intValue(): Returns the value of this Byte object as an int primitive.
	- public long longValue(): Returns the value of this Byte object as a long primitive.
	- public static byte parseByte(String s) throws NumberFormatException: Parses the string argument as a 
		signed decimal byte.
	- public short shortValue(): Returns the value of this Byte object as a short primitive.
	- public String toString(): Returns a string representation of this Byte object in base 10.
	- static String	toString(byte b): Returns a new String object representing the specified byte.
	- public static Byte valueOf(byte b): Returns a Byte instance representing the specified byte value.
	- public static Byte valueOf(String s) throws NumberFormatException: Returns a Byte object holding the 
		value of the specified String.
	- public static Byte valueOf(String s, int radix) throws NumberFormatException: Returns a Byte object holding the 
		value extracted from the specified String when parsed with the radix given by the second argument.


class ByteWrapperDemo 
{
	public static void main(String[] args) 
	{
		// Byte class fields
		System.out.println("Min Value: "+Byte.MIN_VALUE);
		System.out.println("Min Value: "+Byte.MAX_VALUE);
		System.out.println("Representing primitive type: "+Byte.TYPE);		
		System.out.println("Space Needed in bytes: "+Byte.BYTES);		
		System.out.println("Space Needed in bits: "+Byte.SIZE);

		// Using Byte class constructors
		Byte ob1=new Byte((byte)10);  		
		byte b=10;
		Byte ob2=new Byte(b);      
		Byte ob3=new Byte("123");     
		
		// Converting the value to different primitive type
		System.out.println("byte value: "+ob1.byteValue());
		System.out.println("short value: "+ob1.shortValue());
		System.out.println("int value: "+ob1.intValue());
		System.out.println("long value: "+ob1.longValue());
		float ft=ob1.floatValue();
		System.out.println("float value: "+ft);
		double db=ob1.doubleValue();
		System.out.println("double value: "+db);

		// using public int compareTo(Byte anotherByte)
		// this method returns numeric ans of ob1-ob2/ob3, it is non-zero when
		// objects having different value and zero when objects having same value.
		int t=ob1.compareTo(ob3);
		System.out.println("return value t: "+t);
		t=ob1.compareTo(ob2);
		System.out.println("return value t: "+t);

		// using public boolean equals(Object obj):
		boolean ans=ob1.equals(ob2);
		System.out.println("return value ans: "+ans);
		// equals give true when both reference refering towards samelocation
		// here in this case ans is true coz as the ob1 and ob2 having same value
		// while creating object, in same vaue is there in memory the that location
		// is refered by new reference.
		// if we change the value of ob1 or ob2, then it will gives false.

		// Note: compareTo() compares the numeric values of object and equals()
		//	     compares the references of both objects, means both objects are
		//		 refering towards same ocation or not.

		ans=ob1.equals(ob3);
		System.out.println("return value ans: "+ans);


		// Using Parsing
		String num="120";
		byte n=Byte.parseByte(num);
		System.out.println("byte n: "+n);

		// using toString()
		byte val1=56;
		String s=Byte.toString(val1);		
		System.out.println("String s: "+s);

		String s1=ob3.toString();
		System.out.println("String s1: "+s1);

		// using valueOf()

		byte val2=15;
		Byte ob4=Byte.valueOf(val2);
		System.out.println("ob4 is: "+ob4); // ob4.toString() called internally

		String s2="45";
		Byte ob5=Byte.valueOf(s2);
		System.out.println("ob5 is: "+ob5);
	}
}

//----------------------------------------------------------------------------------------------
 
- java.lang.Short class:
-------------------------
	The java.lang.Short class is a wrapper class for the primitive data type short. It provides methods to parse, convert, 
	and manipulate short values. 

	Fields:
	- public static final short MIN_VALUE: The minimum value that a short can have: -32768.
	- public static final short MAX_VALUE: The maximum value that a short can have: 32767.
	- public static final Class<Short> TYPE: The Class object representing the primitive type short.
	- static int BYTES: The number of bytes used to represent a short value in two's complement binary form.
	- static int SIZE: The number of bits used to represent a short value in two's complement binary form.

	Constructors:
	- public Short(short value): Constructs a newly allocated Short object that represents the specified short value.
	- public Short(String s) throws NumberFormatException: Constructs a newly allocated Short object that represents 
		the short value indicated by the String parameter. The string is converted to a short value as if by the 
		short.parseShort method.

	Methods:
	- public byte byteValue()
	- public int compareTo(Short anotherShort)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public float floatValue()
	- public int hashCode()
	- public int intValue()
	- public long longValue()
	- public static short parseShort(String s) throws NumberFormatException
	- public static short parseShort(String s, int radix) throws NumberFormatException
	- public short shortValue()
	- public String toString()
	- public static Short valueOf(short s)
	- public static Short valueOf(String s) throws NumberFormatException
	- public static Short valueOf(String s, int radix) throws NumberFormatException


class ShortDemo 
{
	public static void main(String[] args) 
	{
		String nms="1111";
		short no=Short.parseShort(nms,2);
		System.out.println("No: "+no);
	}
}

//----------------------------------------------

java.lang.Integer class:
-------------------------

	Fields:
	- public static final int MIN_VALUE
	- public static final int MAX_VALUE
	- public static final Class<Integer> TYPE
	- static int BYTES
	- static int SIZE

	Constructors:
	- public Integer(int value)
	- public Integer(String s) throws NumberFormatException

	Methods:
	- public byte byteValue()
	- public int compareTo(Integer anotherInteger)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public float floatValue()
	- public int hashCode()
	- public int intValue()
	- public long longValue()
	- public static int parseInt(String s) throws NumberFormatException
	- public static int parseInt(String s, int radix) throws NumberFormatException
	- public short shortValue()
	- public String toString()
	- public static Integer valueOf(int i)
	- public static Integer valueOf(String s) throws NumberFormatException
	- public static Integer valueOf(String s, int radix) throws NumberFormatException

	

//----------------------------------------------------------------------------------------------

java.lang.Long class:
----------------------

	Fields:
	- public static final long MIN_VALUE
	- public static final long MAX_VALUE
	- public static final Class<Long> TYPE

	Constructors:
	- public Long(long value)
	- public Long(String s) throws NumberFormatException

	Methods:
	- public byte byteValue()
	- public int compareTo(Long anotherLong)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public float floatValue()
	- public int hashCode()
	- public int intValue()
	- public long longValue()
	- public static long parseLong(String s) throws NumberFormatException
	- public static long parseLong(String s, int radix) throws NumberFormatException
	- public short shortValue()
	- public String toString()
	- public static Long valueOf(long l)
	- public static Long valueOf(String s) throws NumberFormatException
	- public static Long valueOf(String s, int radix) throws NumberFormatException


//----------------------------------------------------------------------------------------------


java.lang.Float class:
----------------------

	Fields:
	- public static final float POSITIVE_INFINITY: Represents positive infinity.
	- public static final float NEGATIVE_INFINITY: Represents negative infinity.
	- public static final float NaN: Represents "not a number" (NaN).
	- public static final float MAX_VALUE: The maximum positive finite value of type float.
	- public static final float MIN_NORMAL: The smallest positive nonzero value of type float.
	- public static final float MIN_VALUE: The smallest positive value of type float.
	- public static final int MAX_EXPONENT: The maximum exponent a finite float variable may have.
	- public static final int MIN_EXPONENT: The minimum exponent a normalized float variable may have.
	- public static final int SIZE: The number of bits used to represent a float value.
	- public static final int BYTES: The number of bytes used to represent a float value.
	- public static final Class<Float> TYPE: The Class object that represents the primitive type float

	Constructors:
	- public Float(double value)
	- public Float(float value)
	- public Float(String s) throws NumberFormatException

	Methods:
	- public byte byteValue()
	- public int compareTo(Float anotherFloat)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public int hashCode()
	- public int intValue()
	- public boolean isInfinite()
	- public boolean isNaN()
	- public long longValue()
	- public static float parseFloat(String s) throws NumberFormatException
	- public short shortValue()
	- public String toString()
	- boolean isInfinite()
	- static boolean isInfinite(float v)
	- boolean isNaN()
	- static boolean isNaN(float v)
	- static float	max(float a, float b)
	- static float	min(float a, float b)
	- static float	sum(float a, float b)
	- static String	toHexString(float f)
	- public static String toString(float f)
	- public static Float valueOf(float f)
	- public static Float valueOf(String s) throws NumberFormatException

class FractionaWrapperExampe 
{
	public static void main(String[] args) 
	{
		int x=10, y=0;
		//System.out.println("x/y: "+(x/y)); 
		//Exception in thread "main" java.lang.ArithmeticException: / by zero

		float a=12.4f,b=0.0f;
		System.out.println("a/b: "+(a/b)); // a/b: Infinity

		float p=-132.4f,q=0.0f;
		System.out.println("p/q: "+(p/q)); // p/q: -Infinity

		System.out.println(0.0 / 0.0);	  //zero divided by zero //NaN
        	System.out.println(Math.sqrt(-1)); //take sqrt of negative number //NaN
        	System.out.println(10.0 % 0);      //taking mod by zero //NaN

		float v1=56.34f, v2=67.23f,vmax=0.0f,vmin=0.0f;
		vmax=Float.max(v1,v2);
		vmin=Float.min(v1,v2);
		System.out.println("Min Value: "+vmin+"\t Max Value: "+vmax);
		System.out.println("v1+v2= "+Float.sum(v1,v2));

		v1=15F;
		System.out.println("Hex of v1: "+Float.toHexString(v1));		
	}
}

//--------------------------------------------------------------------------

java.lang.Double class:
------------------------

	Fields:
	- public static final double POSITIVE_INFINITY
	- public static final double NEGATIVE_INFINITY
	- public static final double NaN
	- public static final double MAX_VALUE
	- public static final double MIN_NORMAL
	- public static final double MIN_VALUE
	- public static final int MAX_EXPONENT
	- public static final int MIN_EXPONENT
	- public static final int SIZE
	- public static final int BYTES
	- public static final Class<Double> TYPE

	Constructors:
	- public Double(double value)
	- public Double(String s) throws NumberFormatException

	Methods:
	- public byte byteValue()
	- public int compareTo(Double anotherDouble)
	- public double doubleValue()
	- public boolean equals(Object obj)
	- public float floatValue()
	- public int hashCode()
	- public int intValue()
	- public boolean isInfinite()
	- public boolean isNaN()
	- public long longValue()
	- public static double parseDouble(String s) throws NumberFormatException
	- public short shortValue()
	- public String toString()	
	- static float	max(float a, float b)
	- static float	min(float a, float b)
	- static float	sum(float a, float b)
	- static String	toHexString(float f)
	- public static String toString(double d)
	- public static Double valueOf(double d)
	- public static Double valueOf(String s) throws NumberFormatException


 - boxing, autoboxing and unboxing in java
----------------------------------------------

	In Java, boxing, autoboxing, and unboxing are concepts related to the conversion between primitive data types and
	their corresponding wrapper classes.

	- Boxing: Boxing is the process of converting a primitive data type into its equivalent wrapper class object manually. 
		This conversion is done explicitly by calling the constructor of the wrapper class or by using static 
		factory methods.

	- Autoboxing: Autoboxing is the automatic conversion of primitive data types into their corresponding wrapper 
		class objects. It occurs when a primitive data type is used in a context where an object of its wrapper 
		class is expected. it will automatically converting primitive types to their wrapper classes when needed.

	- Unboxing: Unboxing is the process of converting a wrapper class object back to its corresponding primitive data 
		type manually. This conversion is done explicitly by calling methods provided by the wrapper class, such as 
		intValue() for Integer or it will happen automatically when an object directy assigned to primitive type variable.

class TestExample 
{
	public static void main(String[] args) 
	{
		double d=45.34;
		Double obj=new Double(d); // Boxing
		double val=obj.doubleValue(); // Unboxing
		System.out.println("Double value: "+val);
		//-------------------------------------------
		Integer ob=10;	// Autoboxing
		System.out.println(ob); // Unboxing

		int x=ob;	// Unboxing
		System.out.println(x);
	}
}

//--------------------------------------------------------------------------

java.lang.Boolean class:
-------------------------

	Fields:
	- public static final Boolean TRUE: Represents the true value of the boolean type.
	- public static final Boolean FALSE: Represents the false value of the boolean type.

	Constructors:
	- public Boolean(boolean value): Constructs a newly allocated Boolean object that represents the specified 
		boolean value. This constructor creates a Boolean object initialized with the specified boolean value.

	- public Boolean(String s) throws IllegalArgumentException: Constructs a newly allocated Boolean object that represents 
		the value true if the string argument is not null and is equal, ignoring case, to the string "true". Otherwise, 
		it represents the value false.

	- static Class<Boolean>	TYPE: The Class object representing the primitive type boolean.

	Methods:
	- public boolean booleanValue()
	- public int compareTo(Boolean b)
	- public boolean equals(Object obj)
	- public int hashCode()
	- public static Boolean valueOf(boolean b)
	- public static Boolean valueOf(String s)
	- public String toString()
	- static int hashCode(boolean value)
	- static boolean logicalAnd(boolean a, boolean b)
	- static boolean logicalOr(boolean a, boolean b)
	- static boolean logicalXor(boolean a, boolean b)
	- static boolean getBoolean(String name)

class BooleanWrapperExample 
{
	public static void main(String[] args) 
	{
		Boolean b1=new Boolean(true);
		Boolean b2=new Boolean("false");        
		System.out.println("b1: "+b1+"\t b2: "+b2);

		// logical AND
		System.out.println(Boolean.logicalAnd(b1,b2));
		System.out.println(Boolean.logicalAnd(false,true));
		System.out.println(Boolean.logicalAnd(b1,true));
		System.out.println(Boolean.logicalAnd(false,b2));
		System.out.println("--------------------------------------");

		// logical OR
		System.out.println(Boolean.logicalOr(b1,b2));
		System.out.println(Boolean.logicalOr(false,true));
		System.out.println(Boolean.logicalOr(b1,true));
		System.out.println(Boolean.logicalOr(false,b2));
		System.out.println("--------------------------------------");

		// logical XOR
		System.out.println(Boolean.logicalXor(b1,b2));
		System.out.println(Boolean.logicalXor(false,true));
		System.out.println(Boolean.logicalXor(b1,true));
		System.out.println(Boolean.logicalXor(false,b2));
		System.out.println("--------------------------------------");
	}
}

//-------------------------------------------------------------------------------------------------------------------------

java.lang.Character class:
----------------------------

	Fields:
	- public static final char MIN_VALUE
	- public static final char MAX_VALUE
	- public static final int MIN_RADIX
	- public static final int MAX_RADIX
	- public static final Class<Character> TYPE

	Constructors:
	- public Character(char value)

	Methods:
	- static int charCount(int codePoint)
	- public char charValue()
	- static int compare(char x, char y)
	- public int compareTo(Character anotherCharacter)
	- public boolean equals(Object obj)
	- public int hashCode()
	- static boolean isAlphabetic(int codePoint)
	- public static boolean isDigit(char ch)
	- public static boolean isLetter(char ch)
	- public static boolean isLetterOrDigit(char ch)
	- public static boolean isLowerCase(char ch)
	- public static boolean isUpperCase(char ch)
	- public static char toLowerCase(char ch)
	- public static char toUpperCase(char ch)
	- public static String toString(char c)
	- public static Character valueOf(char c)
	- public static Character valueOf(String s)

public class CharacterMethodsDemo 
{
    public static void main(String[] args) 
    {
        // Character methods demonstration
        char ch = 'A';

        // isLetter
        System.out.println("isLetter('A'): " + Character.isLetter(ch));

        // isDigit
        System.out.println("isDigit('5'): " + Character.isDigit(ch));

        // isWhitespace
        System.out.println("isWhitespace(' '): " + Character.isWhitespace(' '));

        // isUpperCase
        System.out.println("isUpperCase('A'): " + Character.isUpperCase(ch));

        // isLowerCase
        System.out.println("isLowerCase('a'): " + Character.isLowerCase(ch));

        // toUpperCase
        System.out.println("toUpperCase('a'): " + Character.toUpperCase('a'));

        // toLowerCase
        System.out.println("toLowerCase('A'): " + Character.toLowerCase('A'));

        // getNumericValue
        System.out.println("getNumericValue('5'): " + Character.getNumericValue('5'));

        // compare
        System.out.println("compare('A', 'B'): " + Character.compare('A', 'B'));

        // toString
        System.out.println("toString('C'): " + Character.toString('C'));
    }
}

//------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------

java.util.Arrays Class:
------------------------

	The Arrays class in Java provides various utility methods for working with arrays. It is part of the java.util package. 
	This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a 
	static factory that allows arrays to be viewed as lists.
	
	Some of the commonly used methods are:

	- Sorting Arrays:
		- public static void sort(int[] array): Sorts the specified array of integers into ascending numerical order.
		- public static void sort(Object[] array): Sorts the specified array of objects into ascending order, according 
			to the natural ordering of its elements. The range to be sorted extends from the index fromIndex(inclusive) 
			to the index toIndex(exclusive).
		- static void	parallelSort(int[] a): Sorts the specified array into ascending numerical order.

	- Searching Arrays:
		- public static int binarySearch(int[] array, int key): Searches the specified array of integers for the 
			specified value using the binary search algorithm. Returns index of the search key, if it is contained 
			in the array; otherwise returns, (-(insertion point) - 1).
		- public static int binarySearch(Object[] array, Object key): Searches the specified array of objects for 
			the specified object using the binary search algorithm.

	- Converting Arrays to Strings:
		- public static String toString(int[] array): Returns a string representation of the contents of the 
		  specified array.

	- Filling Arrays:
		- public static void fill(int[] array, int value): Assigns the specified int value to each element of the 
			specified array of integers.
		- static void	fill(int[] a, int fromIndex, int toIndex, int val): Assigns the specified int value to each 
			element of the specified range of the specified array of ints.

	- Copying Arrays:
		- public static int[] copyOf(int[] original, int newLength): Copies the specified array, truncating or padding 
			with zeros (if necessary) so the copy has the specified length.
		- static int[]	copyOfRange(int[] original, int from, int to): Copies the specified range of the specified array 
			into a new array.

	- Comparing Arrays:
		- public static boolean equals(int[] a, int[] b): Returns true if the two specified arrays of integers are 
			equal to one another.


Example:

import java.util.Arrays;
class DemoArrays 
{
	public static void main(String[] args) 
	{
		int []a = {23,56,78,89,4,76,22,43};
		System.out.println("Array is: "+a.toString()); // will prints Hashcode

		// Traditional Ways - Using for
		System.out.println("\n Arrays Elements are: ");
		for(int i=0 ;i<a.length;i++) {
			System.out.print("  "+a[i]);
		}

		// using foreach
		System.out.println("\n Arrays Elements are: ");
		for(int val : a) {
			System.out.print("  "+val);
		}

		//Sorting
		Arrays.sort(a);
		System.out.println("\n sorted Array: ");
		for(int val : a) {
			System.out.print("  "+val);
		}

		// searching
		int num = 78;
		int pos = Arrays.binarySearch(a, num);
		System.out.println("\n Element is present at: "+ pos);

		int []a1 = Arrays.copyOf(a,a.length);
		System.out.println("\n a1 copied Array: ");
		for(int val : a1) {
			System.out.print("  "+val);
		}

		int []a2 = Arrays.copyOf(a,10); // fill additional positions with 0
		//int []a2 = Arrays.copyOf(a,5); // copies elements from start and truncate some elements from last
		System.out.println("\n a2 copied Array: ");
		for(int val : a2) {
			System.out.print("  "+val);
		}

		int []a3 = Arrays.copyOfRange(a,2,5); // starting from 2(including) and upto 5(excluding)
		System.out.println("\n a3 copied-range Array: ");
		for(int val : a3) {
			System.out.print("  "+val);
		}
		//fill - 
		Arrays.fill(a2,1); // filled all array elements
		Arrays.fill(a3,1,2,111);	// filled including position 1 till 2(excluding) 	
		System.out.println("After fill x array is: "+Arrays.toString(a2));
		System.out.println("After fill range y array is: "+Arrays.toString(a3));
		// here Arrays.toString(a2) is static imple. of toString() in Arrays class, Not from array object(a.toString())

		//equals
		int []k={1,1,1,1,1,1,1,1,1,1};
		boolean b2=Arrays.equals(k,a2);
		System.out.println("x equals k: "+b2); //  true 
		// contents of both are same, ans as the data in constant pool both refers to same location 

		b2=Arrays.equals(a1,a); // true -> contents are same(as above)
		System.out.println("a1 equals a: "+b2);

		int[] a11 = a.clone();
		b2=Arrays.equals(a11,a); // true -> contents are same(as above) even if clone()
		System.out.println("a11 equals a: "+b2);

	}
}


//--------------------------------------------------------------------------------------------------------------

// Shallow Copy, Deep Copy in Java:
-------------------------------------

 // While using equals() we get confused, to clear all in depth, you must the the concept of shallow copy and Deep copy.

 - Shallow Copy :
	When we do a copy of some entity to create two or more than two entities such that changes in one entity are reflected in 
	the other entities as well, then we can say we have done a shallow copy. In shallow copy, new memory allocation never 
	happens for the other entities, and the only reference is copied to the other entities.
	We will get the same result, when we assign one reference variable to other of same type.

	Sample ob1=new Sample(100); ------|
					  |--- In both cases the reference variables ob1 and ob2 pointing towards same location.
	Sample ob2=ob1; ------------------|    and changing value of one will be reflected in other, so it is Shallow copy.


 - Deep Copy:
	When we do a copy of some entity to create two or more than two entities such that changes in one entity are not reflected 
	in the other entities, then we can say we have done a deep copy. In the deep copy, a new memory allocation happens for the
	other entities, and reference is not copied to the other entities. Each entity has its own independent reference.

	e.g.
	Test t=new Test(10);  --|
			        |---- In both cases the reference variables t and ob are not pointing towards same location.
	Test ob= new Test(10) --|     and changing value of one will not be reflected in other, so it is deep copy.

 - Lazy Copy: 
	A lazy copy can be defined as a combination of both shallow copy and deep copy. At start it is a shallow copy but when
	needed individual exesistence is created.
	
	e.g. when we declare 1st array. and if we declare another array with same values and same size the initially, shallow copy 
	     is created(both references refering towards same location), and when you modify the value of any 1 location from any
	     array they will gains individual exsistence in the memory.(deep copy) and therefore it is known as Lazy copies.


import java.util.Arrays;
class Sample 
{
	private int num;
	public Sample()
	{
		num=1;
	}
	public Sample(int num)
	{
		this.num=num;
	}
	public void set(int num)
	{
		this.num=num;
	}
	public void show()
	{
		System.out.println("value of num: "+num);
	}
}
class ShallowExample
{
	public static void main(String []args)
	{
		// shallow copies
		Sample ob1=new Sample();
		Sample ob2=ob1;
		ob1.set(1000);
		ob2.show();		
		System.out.println("ob1 equals ob2: "+ob1.equals(ob2));
		System.out.println("------------------------------------------");
		// As the change in ob1 is reflected in ob2 these are shallow copies.		
		//---------------------------

		// deep copies
		Sample s1=new Sample(100);	
		Sample s2=new Sample(100);
		System.out.println("s1 equals s2: "+s1.equals(s2));
		s1.set(45);
		s1.show();
		s2.show();
		System.out.println("s1 equals s2: "+s1.equals(s2));
		System.out.println("------------------------------------------");
	
		// In this case both s1 and s2 are deep copies, coz change in s1 will
		// not be reflected in s2.
		//---------------------------

		// Lazy copies
		int []x={11,22,33,44};
		int []y={11,22,33,44};
		
		System.out.println("After value insert x array is: "+Arrays.toString(x));
		System.out.println("x equals y: "+Arrays.equals(x,y));

		y[2]=100;
		System.out.println("x equals y: "+Arrays.equals(x,y));
		// in the initial state both are refering towards same location (as equals()
		// gives true) so it is shallow copy initially. but when we modify one array
		// i.e. the change in y is not reflected in x these are not shallow copy, 
		// and after change equals gives false, means afterwards it will changed to
		// deep copy. and therefore it is known as Lazy copies.
	}
}

//---------------------------------------------------------------------------------------------------------------------------

java.lang.String
-------------------

	The String is a class from java.lang package, used to repesent the character array in its equivalent object form.
	By default every string represented within "<>" considered as a string object. Once the String is created we are 
	unable to modify the contents. means the string object is immutable.	


	Constructors:
	- public String(): Constructs a new empty String.
	- public String(byte[] bytes): Constructs a new String by decoding the specified array of bytes using the 
		platform's default charset.
	- public String(byte[] bytes, Charset charset): Constructs a new String by decoding the specified array 
		of bytes using the specified charset.
	- public String(byte[] bytes, int offset, int length): Constructs a new String by decoding the specified subarray 
		of bytes using the platform's default charset.
	- public String(byte[] bytes, int offset, int length, Charset charset): Constructs a new String by decoding the 
		specified subarray of bytes using the specified charset.
	- public String(char[] value): Allocates a new String so that it represents the sequence of characters currently 
		contained in the character array argument.
	- public String(char[] value, int offset, int count): Allocates a new String that contains characters from a subarray 
		of the character array argument.
	- String(String original): Initializes a newly created String object so that it represents the same sequence of 
		characters as the argument; in other words, the newly created string is a copy of the argument string.
	- String(StringBuffer buffer): Allocates a new string that contains the sequence of characters currently contained 
		in the string buffer argument.
	- String(StringBuilder builder): Allocates a new string that contains the sequence of characters currently contained 
		in the string builder argument.

	Methods:

	Length and Character Access:
	- int length(): Returns the length of this string.
	- char charAt(int index): Returns the char value at the specified index.
	- boolean isEmpty(): Returns true if, and only if, length() is 0.

	Substring Extraction:
	- String substring(int beginIndex): Returns a new string that is a substring of this string.
	- String substring(int beginIndex, int endIndex): Returns a new string that is a substring of this string.

	Concatenation:
	- String concat(String str): Concatenates the specified string to the end of this string.
	- String join(CharSequence delimiter, CharSequence... elements): Returns a new string composed of the elements 
		joined together with the specified delimiter.

	Search and Replace:
	- boolean contains(CharSequence s): Returns true if and only if this string contains the specified sequence of 
		char values.
	- boolean startsWith(String prefix): Tests if this string starts with the specified prefix.
	- boolean endsWith(String suffix): Tests if this string ends with the specified suffix.
	- int indexOf(int ch): Returns the index within this string of the first occurrence of the specified character.
	- int indexOf(String str): Returns the index within this string of the first occurrence of the specified substring.
	- int lastIndexOf(int ch): Returns the index within this string of the last occurrence of the specified character.
	- int lastIndexOf(String str): Returns the index within this string of the last occurrence of the specified substring.
	- String replace(char oldChar, char newChar): Returns a new string resulting from replacing all occurrences of oldChar
		in this  string with newChar.
	- String replace(CharSequence target, CharSequence replacement): Replaces each substring of this string that matches 
		the literal target sequence with the specified literal replacement sequence.

	Modification Operations:
	- String toLowerCase(): Converts all of the characters in this String to lowercase.
	- String toUpperCase(): Converts all of the characters in this String to uppercase.
	- String trim(): Returns a copy of the string, with leading and trailing whitespace omitted.

	Comparison Operations:
	- boolean equals(Object anObject): Compares this string to the specified object.
	- boolean equalsIgnoreCase(String anotherString): Compares this String to another String, ignoring case considerations.
	- int compareTo(String anotherString): Compares two strings lexicographically.

	Regular Expression Matching:
	- boolean matches(String regex): Tells whether or not this string matches the given regular expression.
	- String[] split(String regex): Splits this string around matches of the given regular expression.

	String Conversion:
	- byte[] getBytes(): Encodes this String into a sequence of bytes using the platform's default charset.
	- byte[] getBytes(Charset charset): Encodes this String into a sequence of bytes using the given charset.
	- char[] toCharArray(): Converts this string to a new character array.


	// Creating the strings

class StringExample
{
	public static void main(String []args)
	{
		String s1="hello", s2="hello", s3="good day";

		// Note that eventhough java doesnot allow operator overloading, the + operator internally overloaded
		// to join two or more strings.

		String s="i said: "+s2+" to you,"+s3+" was the second statement";
		System.out.println("The s is: "+s);
	}
}
//----------------------------------------------------------------

// Using String class Constructors

class StringExample1
{
	public static void main(String []args)
	{
		// creating the using direct assignment
		String s1="hello", s2="hello", s3="good day";

		// Note that eventhough java doesnot allow operator overloading, the + operator internally overloaded
		// to join two or more strings.
		String s="i said: "+s2+" to you,"+s3+" was the second statement";
		System.out.println("The s is: "+s);
		//------------------------
		boolean b=s1.equals(s2);
		System.out.println("s1 equals s2 is: "+b);
		b=s1.equals(s3);
		System.out.println("s1 equals s3 is: "+b);
		// when two same string literals are used to create the string objects
		// then it wil creates the shallow copies.
		//-----------------------------
		int len="good day".length();
		System.out.println("length is: "+len);
		// which will proves the string literal are objects.

		String str1=new String();
		System.out.println("str1 is: "+str1);
		//------------------------------------------------
		byte []bvals={65,66,67,68,69,70,71,72};
		String str2=new String(bvals);
		System.out.println("str2 is: "+str2);

		String str3=new String(bvals,2,5); // starting from pos 2(including), and 5 character after it
		System.out.println("str2 is: "+str3);
		//----------------------------------------------
		char []ch={'h','o','w',' ','a','r','e',' ','y','o','u'};
		String str4=new String(ch);
		System.out.println("str4 is: "+str4);

		String str5=new String(s3);
		System.out.println("str5 is: "+str5);
	}
}

//-----------------------------------------------------------------------------------------------

	// Using charAt() and length()

class StringExample1 
{
	public static void main(String[] args) 
	{
		String s1="hello good day";
		int len=s1.length();
		System.out.println("length of s1: "+len);

		String s2="";
		System.out.println("length of s2: "+s2.length());

	//	String s3; // error: variable s3 might not have been initialized
	//	System.out.println("length of s3: "+s3.length());

		// using charAt()
		System.out.print("String s1 is: ");
		for(int i=0 ; i<s1.length();i++)
		{
			System.out.println(s1.charAt(i));
		}
		System.out.println();
	}
}
//---------------------------------------------------------------------

	// using some other methods

import java.util.Arrays;
class StringExample2 
{
	public static void main(String[] args) 
	{
		String s1="hello good day to all";

		String s2=s1.substring(2);
		System.out.println("s2: "+s2);

		String s3=s1.substring(6, 13);
		System.out.println("s3: "+s3);

		String s4=s1.concat(" All the best");
		System.out.println("s4: "+s4);

		
		System.out.println("All the best".contains("e"));
		System.out.println(s1.contains("ll"));

		
		System.out.println("----------------------------------------------");
		System.out.println("All the best".startsWith("e"));
		System.out.println("All the best".startsWith("A"));
		System.out.println("All the best".startsWith("All"));

		System.out.println(s1.endsWith("l"));
		System.out.println(s1.endsWith("all"));
		System.out.println(s1.endsWith("to"));

		
		System.out.println("----------------------------------------------");
		System.out.println(s1.indexOf("o"));
		System.out.println(s1.lastIndexOf("o"));
		System.out.println(s1.indexOf("ll"));
		System.out.println(s1.lastIndexOf("ll"));

		System.out.println("----------------------------------------------");
		String s5=s1.replace('o','#');
		System.out.println("s5: "+s5);
		s5=s1.replace("ll","LL");
		System.out.println("s5: "+s5);
		
		System.out.println("----------------------------------------------");
		String s6=s1.toUpperCase();
		System.out.println("s6: "+s6);
		System.out.println("How ARE yoU".toLowerCase());
		String s7="      java programming      ";
		System.out.println("Length of String: "+s7.length());
		s7=s7.trim();		
		System.out.println("Length of String: "+s7.length());

		System.out.println("----------------------------------------------");
		String s8="good";
		String s9="good";
		String s10="day";
		System.out.println("s8 equals s9: "+s8.equals(s9));
		System.out.println("s8 equals s10: "+s8.equals(s10));
		System.out.println("s8 Compare to s9: "+s8.compareTo(s9));
		System.out.println("s8 Compare to s10: "+s8.compareTo(s10));

		System.out.println("----------------------------------------------");
		byte []b=s1.getBytes();
		System.out.println("bytes of s1: "+Arrays.toString(b));

	}
}

//------------------------------------------------------------------------------------------------------//------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------

java.lang.StringBuffer
-----------------------
	A thread-safe, mutable sequence of characters. A string buffer is like a String, but can be modified. At any point in 
	time it contains some particular sequence of characters, but the length and content of the sequence can be changed 
	through certain method calls.

	The principal operations on a StringBuffer are the append and insert methods, which are overloaded so as to accept 
	data of any type.

	Constructors:
	- public StringBuffer(): Constructs an empty StringBuffer with the initial capacity of 16 characters.
	- public StringBuffer(int capacity): Constructs an empty StringBuffer with the specified initial capacity.
	- public StringBuffer(String str): Constructs a StringBuffer with the specified initial value.

	Methods:

	Append Operations:
	- StringBuffer append(Object obj): Appends the string representation of the specified object to this StringBuffer.
	- StringBuffer append(String str): Appends the specified string to this StringBuffer.
	- StringBuffer append(StringBuffer sb): Appends the specified StringBuffer to this StringBuffer.
	- StringBuffer append(CharSequence s): Appends the specified character sequence to this StringBuffer.
	- StringBuffer append(CharSequence s, int start, int end): Appends a subsequence of the specified character sequence 
		to this StringBuffer.
	- StringBuffer append(char[] str): Appends the string representation of the specified character array to this StringBuffer.
	- StringBuffer append(char[] str, int offset, int len): Appends a subarray of the specified character array to 
		this StringBuffer.
	- StringBuffer append(boolean b): Appends the string representation of the specified boolean value to this StringBuffer.
	- StringBuffer append(char c): Appends the specified character to this StringBuffer.
	- StringBuffer append(int i): Appends the string representation of the specified integer to this StringBuffer.
	- StringBuffer append(long lng): Appends the string representation of the specified long to this StringBuffer.
	- StringBuffer append(float f): Appends the string representation of the specified float to this StringBuffer.
	- StringBuffer append(double d): Appends the string representation of the specified double to this StringBuffer.

	Insert Operations:
	- StringBuffer insert(int offset, Object obj): Inserts the string representation of the specified object into 
		this StringBuffer.
	- StringBuffer insert(int offset, String str): Inserts the specified string into this StringBuffer.
	- StringBuffer insert(int offset, char[] str): Inserts the string representation of the specified character array 
		into this StringBuffer.
	- StringBuffer insert(int offset, CharSequence s): Inserts the specified character sequence into this StringBuffer.
	- StringBuffer insert(int offset, CharSequence s, int start, int end): Inserts a subsequence of the specified 
		character sequence into this StringBuffer.
	- StringBuffer insert(int offset, boolean b): Inserts the string representation of the specified boolean value 
		into this StringBuffer.
	- StringBuffer insert(int offset, char c): Inserts the specified character into this StringBuffer.
	- StringBuffer insert(int offset, int i): Inserts the string representation of the specified integer into this StringBuffer.
	- StringBuffer insert(int offset, long l): Inserts the string representation of the specified long into this StringBuffer.
	- StringBuffer insert(int offset, float f): Inserts the string representation of the specified float into this StringBuffer.
	- StringBuffer insert(int offset, double d): Inserts the string representation of the specified double into this StringBuffer.

	Other Operations:
	- void setLength(int newLength): Sets the length of this StringBuffer.
	- int capacity(): Returns the current capacity of this StringBuffer.
	- void ensureCapacity(int minimumCapacity): Ensures that the capacity of the buffer is at least equal to the 
		specified minimum capacity.
	- void trimToSize(): Attempts to reduce storage used for the character sequence.

	String Conversion:
	- char charAt(int index): Returns the character at the specified index.
	- int length(): Returns the length (character count) of this StringBuffer.
	- String substring(int start): Returns a new String that contains a subsequence of characters currently contained 
		in this StringBuffer.
	- String substring(int start, int end): Returns a new String that contains a subsequence of characters currently 
		contained in this StringBuffer.

	Modification Operations:
	- void setCharAt(int index, char ch): Sets the character at the specified index to the specified character.
	- StringBuffer	deleteCharAt(int index): Removes the char at the specified position in this sequence.
	- StringBuffer	delete(int start, int end): Removes the characters in a substring of this sequence.
	- StringBuffer replace(int start, int end, String str): Replaces the characters in a substring of this sequence 
		with characters in the specified String.
	- StringBuffer reverse(): Causes this character sequence to be replaced by the reverse of the sequence.	
	- void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin): Copies characters from this sequence into the 
		destination character array.

//-------------------------------------------------------------------------------------------------------------------------------

	// Using StringBuffer constructors and capacity() 

class StringBufferExample1 
{
	public static void main(String[] args) 
	{
		StringBuffer s1=new StringBuffer();
		System.out.println("Capacity of s1: "+s1.capacity());

		StringBuffer s2=new StringBuffer(5);
		System.out.println("Capacity of s2: "+s2.capacity());

		s1.append("hello all, how are you");
		System.out.println("Capacity of s1: "+s1.capacity());

		StringBuffer s3=new StringBuffer("hello");
		System.out.println("Data of S3: "+s3);
		System.out.println("Capacity of s3: "+s3.capacity());
	}
}


class StringBufferExample1 
{
	public static void main(String[] args) 
	{
		StringBuffer s=new StringBuffer("hello");
		System.out.println("Data of S: "+s);

		s.append(" How are you");
		System.out.println("Data of S: "+s);

		String str=" all";
		s.append(str);
		System.out.println("Data of S: "+s);

		StringBuffer sb=new StringBuffer(" of you ");
		s.append(sb);
		System.out.println("Data of S: "+s);

		char []ch={'a','l','l',' ','t','h','e',' ','b','e','s','t'};
		s.append(ch);
		System.out.println("Data of S: "+s);
		s.append(ch,7,5);
		System.out.println("Data of S: "+s);
		s.append('A');
		System.out.println("Data of S: "+s);
		s.append(123);
		System.out.println("Data of S: "+s);

		//-------------------------------------------------

		s.insert(37,"All the ");
		System.out.println("Data of S: "+s);
		s.setCharAt(0,'H');
		s.setCharAt(10,'A');
		System.out.println("Data of S: "+s);
		System.out.println("default Capacity of s: "+s.capacity());
		s.trimToSize();
		System.out.println("After trim - Capacity of s: "+s.capacity());
		System.out.println("Data of S: "+s);

		s.setLength(40);
		System.out.println("Data of S: "+s);
		s.setLength(75);
		System.out.println("Data of S: "+s);
		System.out.println("Now Capacity of s: "+s.capacity());
		s.trimToSize();
		System.out.println("Now After trim - Capacity of s: "+s.capacity());

		StringBuffer s1=s.delete(6,18);
		System.out.println("Data of S1: "+s1);

		char []c=new char[100];
		s.getChars(2,10,c,0);
		String t=new String(c);
		System.out.println("gained characters: "+t);

		StringBuffer src=new StringBuffer("How are you");
		StringBuffer s2=src.replace(9,11,"All of you?");
		System.out.println("String src: "+src);
		System.out.println("String s2: "+s2);
		
		StringBuffer s3=src.reverse();
		System.out.println("String s3: "+s3);

	}
}
//----------------------------------------------------------
class StringBufferExample
{
  public static void main(String[] args)
  {
    // create a string buffer
    StringBuffer str = new StringBuffer();

    // add string to string buffer
    str.append("Java");
    str.append(" is");
    str.append(" popular.");
    System.out.println("StringBuffer: " + str);

    // clear the string
    // using delete()
    str.delete(0, str.length());
    System.out.println("Updated StringBuffer: " + str);
  }
}

//-----------------------------------------------------------------------------------------------


public class StringBufferDemo
{
	public static void main(String args[])
	{
		StringBuffer sBuffer1=new StringBuffer("Welcome");
		System.out.println("Original String is ::: " + sBuffer1 + ":: having length " + sBuffer1.length());
		//using append method
		sBuffer1.append(" To Edubca");
		System.out.println("Modified String after append is :: " + sBuffer1 + " :: having length " + sBuffer1.length());
		//using reverse method
		sBuffer1.reverse();
		System.out.println("Modified String after Reverse is :: " + sBuffer1);
	}
}
//-----------------------------------------------------------------
public class StringBufferDemo
{
	public static void main(String args[])
	{
		StringBuffer sBuffer=new StringBuffer ("WelcomeToJava");
		System.out.println("Original String is ::: " + sBuffer + ":: having length " + sBuffer.length());
		//using replace method
		sBuffer.replace(0,9,"This is ");
		System.out.println("Modified String after replace is :: " + sBuffer + " :: having length " + sBuffer.length());
		//using delete method
		sBuffer.delete(0,7);
		System.out.println("Modified String after delete is :: " + sBuffer);
	}
}
//---------------------------------------------------------------------------------------------------------------------------

java.lang.StringBuilder 
-------------------------
	A mutable sequence of characters. This class provides an API compatible with StringBuffer, but with no guarantee of
	synchronization. This class is designed for use as a drop-in replacement for StringBuffer in places where the string 
	buffer was being used by a single thread (as is generally the case). Where possible, it is recommended that this class 
	be used in preference to StringBuffer as it will be faster under most implementations.

	The principal operations on a StringBuilder are the append and insert methods, which are overloaded so as to accept 
	data of any type. Instances of StringBuilder are not safe for use by multiple threads. If such synchronization is 
	required then it is recommended that StringBuffer be used.

	Constructors:
	- public StringBuilder(): Constructs an empty StringBuilder with a default initial capacity.
	- public StringBuilder(int capacity): Constructs a StringBuilder with the specified initial capacity.
	- public StringBuilder(CharSequence seq): Constructs a StringBuilder that contains the same characters as the 
		specified CharSequence.
	- public StringBuilder(String str): Constructs a StringBuilder initialized to the contents of the specified string.

	Methods:
	Append Operations:
	- StringBuilder append(boolean b): Appends the string representation of the specified boolean value.
	- StringBuilder append(char c): Appends the specified character.
	- StringBuilder append(char[] str): Appends the string representation of the specified character array.
	- StringBuilder append(char[] str, int offset, int len): Appends a subarray of the specified character array.
	- StringBuilder append(CharSequence s): Appends the specified character sequence.
	- StringBuilder append(CharSequence s, int start, int end): Appends a subsequence of the specified character sequence.
	- StringBuilder append(double d): Appends the string representation of the specified double value.
	- StringBuilder append(float f): Appends the string representation of the specified float value.
	- StringBuilder append(int i): Appends the string representation of the specified integer value.
	- StringBuilder append(long l): Appends the string representation of the specified long value.
	- StringBuilder append(Object obj): Appends the string representation of the specified object.

	Insert Operations:
	- StringBuilder insert(int offset, boolean b): Inserts the string representation of the specified boolean value.
	- StringBuilder insert(int offset, char c): Inserts the specified character.
	- StringBuilder insert(int offset, char[] str): Inserts the string representation of the specified character array.
	- StringBuilder insert(int offset, char[] str, int offset, int len): Inserts a subarray of the specified character array.
	- StringBuilder insert(int offset, CharSequence s): Inserts the specified character sequence.
	- StringBuilder insert(int offset, CharSequence s, int start, int end): Inserts a subsequence of the specified 
		character sequence.
	- StringBuilder insert(int offset, double d): Inserts the string representation of the specified double value.
	- StringBuilder insert(int offset, float f): Inserts the string representation of the specified float value.
	- StringBuilder insert(int offset, int i): Inserts the string representation of the specified integer value.
	- StringBuilder insert(int offset, long l): Inserts the string representation of the specified long value.
	- StringBuilder insert(int offset, Object obj): Inserts the string representation of the specified object.

	String Conversion:
	- int length(): Returns the length (character count) of the sequence of characters currently in the StringBuilder.
	- StringBuilder setLength(int newLength): Sets the length of the character sequence.
	- String toString(): Returns a string representing the data in this StringBuilder.

	Modification Operations:
	- void setCharAt(int index, char ch): Sets the character at the specified index to the specified character.

	Other Operations:
	- void ensureCapacity(int minimumCapacity): Ensures that the capacity is at least equal to the specified minimum.
	- int capacity(): Returns the current capacity of the StringBuilder.


public class StringBuilderDemo 
{
    public static void main(String[] args) 
    {
        // Create a StringBuilder object
        StringBuilder sb = new StringBuilder("Hello");

        // Append text
        sb.append(" World");
        System.out.println("After appending: " + sb);

        // Insert text at a specific position
        sb.insert(5, ", ");
        System.out.println("After inserting: " + sb);

        // Delete characters
        sb.delete(5, 8);
        System.out.println("After deleting: " + sb);

        // Reverse the StringBuilder
        sb.reverse();
        System.out.println("After reversing: " + sb);

        // Get the length of the StringBuilder
        System.out.println("Length of StringBuilder: " + sb.length());

        // Get capacity of the StringBuilder
        System.out.println("Capacity of StringBuilder: " + sb.capacity());

        // Replace text
        sb.replace(0, 5, "Hey");
        System.out.println("After replacing: " + sb);

        // Set length of the StringBuilder
        sb.setLength(3);
        System.out.println("After setting length: " + sb);

        // Convert StringBuilder to String
        String str = sb.toString();
        System.out.println("Converted to String: " + str);
    }
}

//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------

	// Functional Interface in Java

	A Functional Interface in Java is an interface that contains exactly one abstract method. 
	These interfaces are essential for using lambda expressions and functional programming concepts 
	introduced in Java 8.


	1. What is a Functional Interface?
	A functional interface is an interface that has only one abstract method but can have multiple 
	default or static methods.

	It is primarily used for defining a target type for lambda expressions.
	Java provides a special annotation @FunctionalInterface to enforce this constraint at compile time.


	@FunctionalInterface
	interface MyFunctionalInterface {
    		void doSomething();  // Only one abstract method
	}


	2. Why Functional Interfaces?
	Functional interfaces allow us to write concise, readable, and efficient code by leveraging 
	lambda expressions instead of anonymous classes.

	// Initially 

interface MyInterface {
   	void show();
}

class Demo implements MyInterface {		
	public void show() {
		System.out.println("Hello, class implementing Interface!");
	}
}
public class TestFI {
	public static void main(String[] args) {		
		Demo ob = new Demo();		
		ob.show();
	}
}


//----------------------------------------------------------------------------------------

	Before Java 8 (Using Anonymous Classes):

interface MyInterface {
   void show();
}

public class TestFI {
	public static void main(String[] args) {		
		MyInterface ob = new MyInterface(){ // Anonymous Class	
			public void show() {
				System.out.println("Hello, Anonymous class implementing Interface!");
			}
		};
		ob.show();
	}
}


Can be further modified using functions interface as

	- remove Anonymous Class implementation, i.e. new <interface_name()> 
	- {} of class implemntation
	- As it is functional interface, there is only one method to call, 
  	  so remove the <visibility> <ret_type> <method_name>, keep() add -> after it 
	  and keep {} of method with method body

interface MyInterface {
   	void show();
}
public class TestFI {
	public static void main(String[] args) {		
		MyInterface ob = () -> {
				System.out.println("Hello, Anonymous class implementing Interface!");
			}
		;
		ob.show();
	}
}

 // again remove {} of method body, and ; after the instruction. Then 

interface MyInterface {
   	void show();
}
public class TestFI {
	public static void main(String[] args) {		
		MyInterface ob = () -> System.out.println("Hello, Anonymous class implementing Interface!");
		ob.show();
	}
}

//-----------------------------------------------------------------------------------------

	// With arguments

interface AddOperation
{
	void add(int a, int b); // must write variable name, name a and b can be changed in impl.
}
class DemoFIwithArguments
{
	public static void main(String[] args) 
	{
		AddOperation ob = (int x, int y) -> System.out.println("Addition: "+ (x+y) );
		ob.add(10,20);
	}
}

//----------

	In the expression, AddOperation ob = (int x, int y) -> System.out.println("Addition: "+ (x+y) );
		in (int x, int y), only int is a option and as functional interface, only one is there.
	so presence of data types become optional.

lets rewrite,

interface AddOperation
{
	void add(int a,int b); // must write variable name, name a and b can be changed in impl.
}
class DemoFIwithArguments
{
	public static void main(String[] args) 
	{
		AddOperation ob = (x,y) -> System.out.println("Addition: "+ (x+y) );
		ob.add(10,20);
	}
}

//-----------------------------------------------------------------------------------------

	// with return


interface MathCube
{
	int getCube(int no);
}
class DemoFiWithReturn
{
	public static void main(String[] args) 
	{
		MathCube ob = (n) ->  n*n*n; // return statement taken as per the function prototype from interface
		int ans = ob.getCube(3);

		System.out.println("Answer is: "+ans);
	}
}
//---------------------------------------------------------------------

	// Multiple Statements in Lambda Expression

	when implementing a Functional Interface using a lambda expression, you can include multiple 
	statements in the function body by enclosing them within curly braces {}.

interface PrimeCalculator
{
	void isPrime(int no);
}
class DemoFIWithMultiState
{
	public static void main(String[] args) 
	{
		PrimeCalculator ob = (n) -> {
			
			int d=2, flg=0;
			while(d<=(n/2)){
				if(n%d==0){
					flg=1;
					break;
				}
				d++;
			}
			if(flg==1)
				System.out.println("Number is not prime");
			else 				
				System.out.println("Number is prime");
		};

		ob.isPrime(5);
	}
}
//-----------------------------------
// Same Program with return

@FunctionalInterface  // ----> generates the compiletime error when two or more abstract methods are there.
interface PrimeCalculator
{
	boolean isPrime(int no);
}
class DemoFIWithMultiState
{
	public static void main(String[] args) 
	{
		PrimeCalculator ob = (n) -> {
			
			int d=2;
			boolean flg=true;

			while(d<=(n/2)){
				if(n%d==0){
					flg=false;
					break;
				}
				d++;
			}
			return flg;
		};

		if(ob.isPrime(51))
			System.out.println("Number is prime");
		else 				
			System.out.println("Number is not prime");
	}
}

//--------------------------------------------------------------

	Advantages of Functional Interfaces:

	✔️ Less Boilerplate Code
	✔️ Improved Readability
	✔️ Efficient Execution


//---------------------------------------------------------------------

Introduction to java.util.function Package in Java

	The java.util.function package was introduced in Java 8 as part of the functional 
	programming paradigm. It provides a set of built-in functional interfaces that help in 
	writing cleaner and more readable lambda expressions and method references.


	Built-in Functional Interfaces (java.util.function Package)

	java.util.function
	│
	├── Function<T, R>
	│   ├── UnaryOperator<T> (extends Function<T, T>)
	│
	├── BiFunction<T, U, R>
	│   ├── BinaryOperator<T> (extends BiFunction<T, T, T>)
	│
	├── Predicate<T>
	│   └── BiPredicate<T, U>
	│
	├── Consumer<T>
	│   └── BiConsumer<T, U>
	│
	├── Supplier<T>
	│
	├── Operator Interfaces
	│   ├── UnaryOperator<T> (extends Function<T, T>)
	│   └── BinaryOperator<T> (extends BiFunction<T, T, T>)
	│
	└── Specialized Variants for Primitives
	    ├── IntFunction<R>, LongFunction<R>, DoubleFunction<R>
	    ├── IntPredicate, LongPredicate, DoublePredicate
	    ├── IntConsumer, LongConsumer, DoubleConsumer
	    ├── IntSupplier, LongSupplier, DoubleSupplier
	    ├── IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator
	    └── IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator



	The package provides several predefined functional interfaces categorized as follows:

	Functional Interface		Method Signature		Description

	Consumer<T>			void accept(T t)	Takes input but does not return a result.
	Supplier<T>			T get()			Takes no input but returns a value.
	Function<T, R>			R apply(T t)		Takes input and returns a result.
	Predicate<T>			boolean test(T t)	Evaluates a condition and returns true or false.
	UnaryOperator<T>		T apply(T t)		A special Function<T, T> where input and output types are the same.
	BinaryOperator<T>		T apply(T t1, T t2)	A special BiFunction<T, T, T> that operates on two inputs of the same type.



	// Using the Consumer: Consumer<T> (T → void)
		Performs an operation on an input without returning a result.

	Example: Printing a Message

import java.util.function.Consumer;
public class ConsumerExample {
    public static void main(String[] args) {
        Consumer<String> printMessage = message -> System.out.println("Message: " + message);
        printMessage.accept("Hello, Java!");
    }
}


	// Example displaying the array elements

import java.util.function.Consumer;
class DemoConsumer
{
	public static void main(String[] args) 
	{
		Integer []ar = {11,22,33,44,55};
		Consumer<Integer> ob = n -> System.out.println(" "+n);

		for(int val : ar)
			ob.accept(val);
	}
}

//----------------------------------------------
	// Passing Integer array

import java.util.function.Consumer;
import java.util.Arrays;
class DemoConsumer
{
	public static void main(String[] args) 
	{
		Integer []ar = {11,22,33,44,55};
		Consumer<Integer[]> ob = n -> System.out.print(" "+Arrays.toString(n));
		ob.accept(ar);
	}
}

//-----------------------------------------------

 // passing int array: 

import java.util.function.Consumer;
import java.util.Arrays;
class DemoConsumer
{
	public static void main(String[] args) 
	{
		int []ar = {11,22,33,44,55};
		Consumer<int[]> ob = n -> System.out.print(" "+Arrays.toString(n));
		ob.accept(ar);
	}
}

//-----------------------------------------------------------------------------------------------------

	// Supplier<T> (() → T): Returns a result without taking any input.

	Example: Generating a Random Number


import java.util.function.Supplier;

public class SupplierExample {
    public static void main(String[] args) {
        Supplier<Double> randomSupplier = () -> Math.random();

        System.out.println("Random Value: " + randomSupplier.get());
    }
}


//-------------------------------------------------------------------------------------------------

	// Function<T, R> (T → R): Takes an input and returns a transformed output.

import java.util.function.Function;
public class FunctionExample {
    public static void main(String[] args) {
        Function<Integer, String> intToString = num -> "Number: " + num;
        System.out.println(intToString.apply(10));
    }
}

//----------------

	// Find length using Function

import java.util.function.Function;
class FindLength
{
	public static void main(String[] args) 
	{
		Function<String, Integer> ob = (s) -> s.length();
		System.out.println(ob.apply("Hello World!"));
	}
}

//--------------------------

	// using the BiFunction<T, U, R>

 you can use the Function interface from the java.util.function package to create a lambda expression. 
However, the Function<T, R> interface takes a single argument of type T and returns a result of type R. 
Since we need to add two numbers, it's more appropriate to use the BiFunction<T, U, R> interface, 
which accepts two arguments.

import java.util.function.BiFunction;

public class AdditionUsingLambda {
    public static void main(String[] args) {
        // Lambda expression to add two numbers
        BiFunction<Integer, Double, Double> add = (a, b) -> a + b;

        // Test the lambda expression
        double result = add.apply(10, 2.5);
        System.out.println("The sum is: " + result);
    }
}


// If there are more than two arguments the Functions will not provide direct class. then use

	- Custom Interface and class
	- Nest the Function and BiFunction
	- Use another data Structures like Map
	- passing custom object

	lets see last option

	// passing custom object: create the custom class to encapsulate all the numbers(arguments) and 
	      			  pass to Function in form of object.

import java.util.function.Function;

class Data {
    int a, b, c;
    Data(int a, int b, int c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}

public class FunctionWithWrapper {
    public static void main(String[] args) {
        Function<Data, Integer> sum = data -> data.a + data.b + data.c;
        System.out.println(sum.apply(new Data(5, 10, 15)));  // Output: 30
    }
}


//---------------------------------------------------------------------------------------

	// UnaryOperator and BinaryOperator in java.util.function

	Both UnaryOperator and BinaryOperator are specialized forms of the Function and BiFunction interfaces. 
	They are designed to operate on the same type of operands and return the same type.


	// UnaryOperator<T>: A functional interface that takes one argument and returns a result of the same type.


import java.util.function.Function;
import java.util.function.UnaryOperator;
  
public class UnaryOperatorFunctionExample{
    public static void main(String args[]){
        UnaryOperator<Integer> not = a -> a ^ 1;
        System.out.println(not.apply(0));
    }
}

	// BinaryOperator<T>: A functional interface that takes two arguments of the same type and returns a 
			      result of the same type.


import java.util.function.Function;
import java.util.function.BinaryOperator;
  
public class BinaryOperatorFunctionExample{
    public static void main(String args[]){
        BinaryOperator<Integer> and = (a,b) -> a & b;
        System.out.println(and.apply(13, 3));
    }
}


//-----------------------------------------------------------

  - Predicate<T>:
	The Predicate<T> interface in Java represents a predicate(a statement, action), which is a boolean-valued 
	function of one argument. It's commonly used when you need to test a condition or filter elements based on 
	some criteria.

	public interface Predicate<T>{
    		boolean test(T t)
	}

Example

import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        // Creating a Predicate to check if a number is even
        Predicate<Integer> isEven = new IsEvenPredicate();

        // Testing the Predicate with some numbers
        System.out.println("Is 4 even? " + isEven.test(4));   // true
        System.out.println("Is 7 even? " + isEven.test(7));   // false
    }
}

class IsEvenPredicate implements Predicate<Integer> {
    public boolean test(Integer number) {
        return number % 2 == 0;
    }
}

	// Same can be written in functional style as, i.e. using lambda expression

import java.util.function.Predicate;
public class PredicateExample {
    public static void main(String[] args) {
        // Creating a Predicate to check if a number is even
        Predicate<Integer> isEven = (number) -> number % 2 == 0;

        // Testing the Predicate with some numbers
        System.out.println("Is 4 even? " + isEven.test(4));   // true
        System.out.println("Is 7 even? " + isEven.test(7));   // false
    }
}

//==============================================================================================================
//================================================================================================================================
//================================================================================================================================

	Java Collection Framework: 
	===========================

	Getting started with Collection Framework: Basically, if you want to represent the bunch of elements as a single unit then 
	the collection is used. 
	
	If we want to store the data in the memory, we have different options. Let’s see
	- If we want to store the single data element then we declare the simple variables, Such as 

		int a=10;	double b=45.3486;
	
	These variables allow you to store the single data element.

	- If we want to store the more elements the array is the perfect choice.

		i.e.  	int []ar=new int[10];

	Array will allow us to store fix number of elements having same type, the elements may of any built-in type or may be of 
	any object type also. Suppose if class Student is defined in the program, the we can use array to store the group of 
	students as 

	Student s=new Student [10];
 
	Where S1, S2, .........S10 are the objects of student class.


	- The problem with is that, array collect the elements having same type together. But what is the option if you want to
	  collect the elements of different type. The option is java is using Object class from Java.  

		i.e.	Object []arr=new Object[5];

	- The problem with array of elements having type Object is
		- It having fix in size, means it is not a growable in nature
		- It will create the data structure which is not with readymade methods.
		- Not Array using Object class but other arrays are homogeneous in nature.

	The solution to all these problems is the collection of classes and interfaces which will provides the internal data 
	structure which will grow and shrink according to need and are with some predefined or readymade methods, 
	known as Java Collection Framework. 

	The Java Collections Framework is a powerful built-in library that provides a unified approach to storing and manipulating
	groups of objects. 

	It offers a variety of benefits for Java programmers:

	- Reduced effort:  The framework provides pre-built implementations of common data structures like ArrayLists, LinkedLists, 
	and HashSets, saving you time and effort compared to writing your own from scratch.

	- Improved performance: The implementations in the Collections Framework are well-optimized for efficiency, ensuring your 
	code runs smoothly.

	- Consistent behavior:  Collections that implement the same interface (like List or Set) share a common set of methods, 
	making it easier to learn and use.

	- Reusability: The framework promotes code reuse by allowing you to work with different collections in a similar way.


          java.lang.Object(C)
            │
          java.lang.Iteriable(I)
            │
            └─ java.util.Collection(I)
               │
               ├─── java.util.List(I)
               │    ├── java.util.ArrayList(C)
               │    ├── java.util.LinkedList(C)
               │    └── java.util.Vector(C)
               │         └── java.util.Stack(C)
               │
               ├─── java.util.Queue(I)
               │    ├── java.util.Deque(I)
               │    │    ├── java.util.ArrayDeque(C)
               │    │    └── java.util.LinkedList(C)
               │    └── java.util.PriorityQueue(C)
               │
               └─── java.util.Set(I)
                    ├── java.util.HashSet(C)
                    │    └── java.util.LinkedHashSet(C)
                    └── java.util.TreeSet(C)
     
               java.util.Map
                    ├── java.util.HashMap(C)
                    │    └── java.util.LinkedHashMap(C)  
             	    ├── java.util.SortedMap(I)
             	    │    └── java.util.TreeMap(C)
          	    ├── java.util.WeakHashMap(C)
                    ├── java.util.HashTable(C)
                    └── java.util.IdentityHashMap(C)



	Description of each class and interface in the Java Collections Framework hierarchy:
	-----------------------------------------------------------------------------------------

	- java.lang.Object (C): The root class for all Java classes. All other classes in Java inherit directly or 
	  indirectly from this class.


	- java.util.Collection (I): The root interface in the collection hierarchy. It represents a group of objects 
	  known as elements.


	- java.util.List (I): An ordered collection that allows duplicate elements.

	- java.util.ArrayList (C): Resizable-array implementation of the List interface. It's a dynamic array that can 
	  grow or shrink as needed.

	- java.util.LinkedList (C): Doubly-linked list implementation of the List interface. It provides sequential 
	  access and efficient insertion/deletion operations.

	- java.util.Vector (C): A legacy class similar to ArrayList but synchronized. It's rarely used in modern Java 
	  development.

	- java.util.Stack (C): A subclass of Vector that represents a last-in, first-out (LIFO) stack of objects.


	
	- java.util.Queue (I): A collection designed for holding elements prior to processing. Queues typically 
	  order elements in a FIFO (first-in-first-out) manner.

	- java.util.Deque (I): A linear collection that supports element insertion and removal at both ends. Stands for 
	  "Double Ended Queue".

	- java.util.ArrayDeque (C): Resizable-array implementation of the Deque interface. It provides more efficient 
	  insertion and removal operations than LinkedList in most cases.

	- java.util.PriorityQueue (C): An unbounded priority queue based on a priority heap. The elements are ordered 
	  according to their natural ordering or by a specified comparator.



	- java.util.Set (I): A collection that contains no duplicate elements.

	- java.util.HashSet (C): Implementation of the Set interface based on a hash table. It does not guarantee the 
	  order of its elements.

	- java.util.LinkedHashSet (C): A hash table and linked list implementation of the Set interface, with predictable 
	  iteration order.

	- java.util.TreeSet (C): A NavigableSet implementation based on a TreeMap. It orders its elements using their 
	  natural ordering or a comparator.



	- java.util.Map (I): An object that maps keys to values. A map cannot contain duplicate keys; each key can map 
	  to at most one value.

	- java.util.HashMap (C): Hash table-based implementation of the Map interface. It provides constant-time 
	  performance for basic operations (add, remove, get) on average.

	- java.util.LinkedHashMap (C): Hash table and linked list implementation of the Map interface. It maintains the 
	  insertion order of elements.

	- java.util.SortedMap (I): A map that maintains its mappings in ascending order, sorted according to the keys 
	  natural ordering or a custom comparator.

	- java.util.TreeMap (C): Red-black tree-based implementation of the SortedMap interface. It maintains the keys 
	  in sorted order.

	- java.util.WeakHashMap (C): An implementation of the Map interface with weak keys. Entries in the WeakHashMap 
	  will be automatically removed when they are no longer reachable from the program.

	- java.util.HashTable (C): A legacy class similar to HashMap but synchronized. It's not commonly used in modern 
	  Java development due to its synchronization overhead.

	- java.util.IdentityHashMap (C): An implementation of the Map interface based on reference-equality in place of 
	  object-equality. It's useful when object-equality semantics are not desired.

//----------------------------------------------------------------------------------------------------------------

	1. List
	- Definition: Ordered collection that allows duplicates.
	- Duplicates Allowed? Yes.
	- Ordering: Maintains insertion order (e.g., ArrayList, LinkedList).
	- Null Values Allowed? Yes.
	- Implementation Classes: ArrayList, LinkedList, Vector, Stack.
	- Performance: Fast random access in ArrayList (O(1)), slower in LinkedList (O(n)).
	- Thread Safety: Vector is synchronized; others require Collections.synchronizedList().
	- Best Use Case: When maintaining order and allowing duplicates is required.

	2. Queue
	- Definition: Collection that processes elements in FIFO/LIFO or priority order.
	- Duplicates Allowed? Yes (depends on implementation).
	- Ordering: FIFO (LinkedList, ArrayDeque), LIFO (Deque), Priority-based (PriorityQueue).
	- Null Values Allowed? No in PriorityQueue, Yes in LinkedList.
	- Implementation Classes: PriorityQueue, ArrayDeque, LinkedList.
	- Performance: PriorityQueue efficiently retrieves elements based on priority.
	- Thread Safety: Not thread-safe by default.
	- Best Use Case: When elements need to be processed in a specific order.

	3. Set
	- Definition: Unordered collection that does not allow duplicate elements.
	- Duplicates Allowed? No.
	- Ordering: No guarantee (HashSet), Maintains insertion order (LinkedHashSet), Sorted order (TreeSet).
	- Null Values Allowed? Yes in HashSet, LinkedHashSet; No in TreeSet.
	- Implementation Classes: HashSet, TreeSet, LinkedHashSet.
	- Performance: HashSet is fast for search (O(1)), TreeSet has slower lookup (O(log n)).
	- Thread Safety: Not thread-safe by default.
	- Best Use Case: When only unique elements are needed.

	4. Map
	- Definition: Key-value pair collection where keys are unique, but values can be duplicate.
	- Duplicates Allowed? Keys: No; Values: Yes
	- Ordering: No guarantee (HashMap), Maintains insertion order (LinkedHashMap), Sorted order (TreeMap).
	- Null Values Allowed? One null key allowed in HashMap, LinkedHashMap; No null key in TreeMap; Multiple null values allowed.
	- Implementation Classes: HashMap, TreeMap, LinkedHashMap, Hashtable.
	- Performance: HashMap provides fast lookups (O(1)), TreeMap is slower (O(log n)).
	- Thread Safety: Hashtable is synchronized, ConcurrentHashMap is thread-safe.
	- Best Use Case: When key-value associations are required.

//----------------------------------------------------------------------------------------------------------------

Iterable interface
====================

In Java, the Iterable interface is a fundamental part of the Java Collections Framework. It provides a way to 
iterate over the elements of a collection, such as ArrayList, LinkedList, HashSet, etc., in a uniform and consistent 
manner. By implementing the Iterable interface, a class indicates that it can be iterated over using the enhanced 
for loop (for-each loop) or by explicitly obtaining an iterator.

import java.util.Iterator;
// Define a custom iterable class
class MyIterable implements Iterable<String> 
{
    private String[] data;
    public MyIterable(String[] data) 
    {
        this.data = data;
    }
    // Implement the iterator() method required by Iterable interface
    @Override
    public Iterator<String> iterator() 
    {
        return new Iterator<String>() {
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < data.length;
            }

            @Override
            public String next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }
                return data[index++];
            }
        };
    }
}

public class MyIterableExample 
{
    public static void main(String[] args) 
    {
        // Create an instance of the iterable class
        MyIterable myIterable = new MyIterable(new String[]{"Hello", "World", "Iterable"});

        // Iterate over the elements using a for-each loop
        for (String item : myIterable) 
	{
            System.out.println(item);
        }
    }
}
//----------------------------------------------------------------------------------------------------------------------

	// what is comparator and Comparable 

	In Java, Comparator and Comparable are two interfaces used for sorting objects. They allow you to define 
	custom sorting logic.

	1. Comparable (java.lang.Comparable)
	- Used to define natural ordering of objects.
	- The class that needs to be sorted implements Comparable<T>.
	- It overrides the compareTo(T obj) method.
	- It allows sorting based on one attribute only.
	- Modifies the class itself to provide sorting logic.



import java.util.*;
class Student implements Comparable<Student> {
    int rollNumber;
    String name;

    public Student(int rollNumber, String name) {
        this.rollNumber = rollNumber;
        this.name = name;
    }

    @Override
    public int compareTo(Student other) {
        return this.rollNumber - other.rollNumber; // Ascending order
    }
}

// Usage
public class DemoComparable {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(3, "Sagar"));
        students.add(new Student(1, "Sourabh"));
        students.add(new Student(2, "Kiran"));

        Collections.sort(students); // Uses compareTo()

        for (Student s : students) {
            System.out.println(s.rollNumber + " - " + s.name);
        }
    }
}


	2. Comparator (java.util.Comparator)
	- Used to define custom ordering externally without modifying the class.
	- You create a separate class or use a lambda expression to implement Comparator<T>.
	- It overrides the compare(T obj1, T obj2) method.
	- It allows multiple sorting criteria (e.g., sorting by name or roll number).


import java.util.*;

class Student {
    int rollNumber;
    String name;

    public Student(int rollNumber, String name) {
        this.rollNumber = rollNumber;
        this.name = name;
    }
}

// Comparator to sort students by name
class NameComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name); // Alphabetical order
    }
}

// Usage
public class DemoComparator {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(3, "Sagar"));
        students.add(new Student(1, "Sourabh"));
        students.add(new Student(2, "Kiran"));

        Collections.sort(students, new NameComparator()); // Uses Comparator

        for (Student s : students) {
            System.out.println(s.rollNumber + " - " + s.name);
        }
    }
}

//---------------------------------------------------------------------------------------------------------

	// java.util.Collection Interface in Java

	The java.util.Collection interface is the root interface of the Java Collections Framework (JCF). 
	It is part of the java.util package and provides a unified way to work with groups of objects.

	1. Overview of Collection Interface
	- Package: java.util
	- Super Interface: Iterable<T> (allows iteration using forEach, iterator())
	- Subinterfaces: List<T>, Queue<T>, Set<T>
	- Implementation Classes: ArrayList, LinkedList, HashSet, TreeSet, PriorityQueue, etc.
	- Purpose: Provides common operations for all collection types, such as addition, removal, checking size, and iteration.


	2.  Methods in Collection Interface

	- boolean add(E e): Adds an element to the collection.
	- boolean remove(Object o): Removes a single instance of the specified element.
	- boolean contains(Object o): Checks if the collection contains the specified element.
	- int size(): Returns the number of elements in the collection.
	- boolean isEmpty(): Checks if the collection is empty.

	- boolean addAll(Collection<? extends E> c): Adds all elements from another collection.
	- boolean removeAll(Collection<?> c):Removes all elements present in another collection.
	- boolean retainAll(Collection<?> c):Retains only elements that are also in another collection.
	- void clear():Removes all elements from the collection.


	- Iterator<E> iterator():Returns an iterator to traverse elements.
	- default void forEach(Consumer<? super E> action): Performs the given action for each element (Java 8+).

	- Object[] toArray(): Converts the collection to an array of Object[].
	- <T> T[] toArray(T[] a): Converts the collection to an array of the specified type.


 //--------------------------------------------------------------------------------------------------

	//     Using Lists:

	java.util.List Interface in Java
	The List interface in Java is part of the Java Collections Framework (JCF) and extends Collection<T>. 
	It represents an ordered collection (also called a sequence) and allows duplicate elements.

	 Characteristics of List Interface
	 - Ordered Collection: Maintains the insertion order of elements.
	 - Allows Duplicates: Multiple elements with the same value are permitted.
	 - Indexed Access: Supports index-based retrieval, insertion, and removal of elements.
	 - Allows Null Values: Can store null values.
	 - Provides ListIterator: Supports both forward and backward traversal using ListIterator.


           java.util.Collection(I)
               │
               ├─── java.util.List(I)
               │    ├── java.util.ArrayList(C)
               │    ├── java.util.LinkedList(C)
               │    └── java.util.Vector(C)
               │         └── java.util.Stack(C)


	Methods: 

	 - void add(int index, E element): Inserts an element at a specific index.
	 - boolean add(E element): Appends the element to the list.
	 - E get(int index): Retrieves the element at a specific index.
	 - E set(int index, E element): Replaces an element at the given index.
	 - E remove(int index): Removes an element at a specific index.
	 - boolean remove(Object o): Removes the first occurrence of the specified element.
	 - int size(): Returns the number of elements.
	 - boolean contains(Object o): Checks if the list contains a specific element.

	 - int indexOf(Object o): Returns the first index of an element, or -1 if not found.
	 - int lastIndexOf(Object o): Returns the last index of an element.
	 - List<E> subList(int fromIndex, int toIndex): Returns a portion of the list.

	 - Iterator<E> iterator(): Returns an iterator to traverse elements forward.
	 - ListIterator<E> listIterator(): Returns a ListIterator for bidirectional traversal.
	 - ListIterator<E> listIterator(int index): Returns a ListIterator starting at the specified index.


//------------------------------------------------------------------------------------------------------------------------------

- java.util.ArrayList class:
-------------------------------

	Resizable-array implementation of the List interface. Implements all optional list operations, and permits 
	all elements,including null. In addition to implementing the List interface, this class provides methods to 
	manipulate the size of the array that is used internally to store the list. 
	(This class is roughly equivalent to Vector, except that it is unsynchronized.)

	Constructor and Description
	----------------------------

	- ArrayList(): Constructs an empty list with an initial capacity of ten.
	
	- ArrayList(Collection<? extends E> c): Constructs a list containing the elements of the specified collection, 
	  in the order they are returned by the collection's iterator.

	- ArrayList(int initialCapacity): Constructs an empty list with the specified initial capacity.


	// Allow store any type of object (not type-safe).

import java.util.*;
class DemoArrayList 
{
	public static void main(String[] args) 
	{
		// A collection may be a group of any type of objects.

		// ref by Collection interface
		Collection c = new ArrayList(); // as Collection is base interface, its reference able to refer ArrayList object
		c.add(11);
		c.add("Hi");
		c.add(34.73);
		System.out.println("Collection C is: "+c);

		// ref by list interface
		List l = new ArrayList(c); // As list acts as a base interface ....
		l.add(true);
		System.out.println("List l is: "+l);

		// ref by ArrayList reference
		ArrayList al = new ArrayList(20);
		al.addAll(l);
		al.add(56.89);
		System.out.println("Arraylist al is: "+al);
	}
}

//----------------------------------------

	// Using generics (<T>) to specify the type of elements.(Type-safe)


// Restricted arraylist of <T>
import java.util.*;
class DemoTList
{
	public static void main(String[] args) 
	{
		ArrayList<String> stringlist = new ArrayList<>();
		stringlist.add("hello");
		//stringlist.add(56);  // error
		stringlist.add("all");
		//stringlist.add(2.3); // error

		System.out.println("String List: "+stringlist);
	}
}


/-------------------------------------------------------------------------------------------------------------

	// Adding/inserting the elements in ArrayList

	- boolean add(E e): Appends the specified element to the end of this list.

	- void add(int index, E element): Inserts the specified element at the specified position in this list.

	- boolean addAll(Collection<? extends E> c): Appends all of the elements in the specified collection to 
	  the end of this list, in the order that they are returned by the specified collection's Iterator.

	- boolean addAll(int index, Collection<? extends E> c): Inserts all of the elements in the specified collection 
	  into this list, starting at the specified position.

	- E set(int index, E element): Replaces the element at the specified position in this list with the 
	  specified element.

import java.util.ArrayList;
public class ArrayListAddInsertExample {

	public static void main(String[] args) {

		ArrayList<String> arraylist=new ArrayList<>(9); 
		arraylist.add("C++");
		arraylist.add("Java");
		arraylist.add(0,"C");
		System.out.println(arraylist); 

		ArrayList<String> al=new ArrayList<>(); 
		al.add("Android");
		al.addAll(arraylist);
		System.out.println(al); 
		
		ArrayList<String> a2=new ArrayList<>(); 
		a2.add("SQL");
		a2.add("NoSQL");
		a2.addAll(1,al);
		System.out.println(a2); 
		
		String str = a2.set(5, "Oracle");
		System.out.println("After removing "+str+" Arrays List is: "+a2);
	}
}


//------------------------------------------------------------

	// Search and remove operations

	- boolean contains(Object o): Returns true if this list contains the specified element.

	- E get(int index): Returns the element at the specified position in this list.

	- int indexOf(Object o): Returns the index of the first occurrence of the specified element in this list, or -1 
		if this list does not contain the element.

	- boolean isEmpty(): Returns true if this list contains no elements.

	- int lastIndexOf(Object o): Returns the index of the last occurrence of the specified element in this list, 
	  or -1 if this list does not contain the element.

	- E remove(int index): Removes the element at the specified position in this list.
	
	- boolean remove(Object o): Removes the first occurrence of the specified element from this list, if it is present.

	- boolean removeAll(Collection<?> c): Removes from this list all of its elements that are contained in the 
	  specified collection.

	- List<E> subList(int fromIndex, int toIndex): Returns a view of the portion of this list between the specified 
	  fromIndex, inclusive, and toIndex, exclusive.

import java.util.ArrayList;
import java.util.List;
public class ArrayListExample {

	public static void main(String[] args) {

		ArrayList<String> arraylist=new ArrayList<>(9); 
		arraylist.add("C++");
		arraylist.add("Python");
		arraylist.add("Java");
		arraylist.add(0,"C");
		System.out.println("Arraylist contains Java: "+arraylist.contains("Java")); 

		ArrayList<String> al=new ArrayList<>(); 
		al.add("Android");
		al.addAll(arraylist);
		System.out.println(al); 
		System.out.println("2nd element in al: "+al.get(2)); 
		
		ArrayList<String> a2=new ArrayList<>(); 
		a2.add("SQL");
		a2.add("NoSQL");
		a2.addAll(1,al);
		System.out.println("a2 contains arraylist: "+a2.containsAll(arraylist)); 		
		a2.set(5, "Oracle");
		System.out.println(a2);
		
		List<String> sl=a2.subList(2, 5);
		System.out.println("Sublist: "+sl);
		
		if(a2.indexOf("Java")!=-1)
		{
			System.out.println("Java present at "+a2.indexOf("Java")+" position");
		}
		else
		{
			System.out.println("Java is not present in the List");
		}
		
		a2.add("C");
		a2.add("Java");
		System.out.println(a2);
		System.out.println("Last index of C in a2: "+a2.lastIndexOf("C"));
		
		a2.remove("C"); // removes first ocr
		System.out.println(a2);
		
		a2.add("Java");
		a2.removeAll(arraylist); // remove all ocr of elm in arraylist from a2
		System.out.println(a2);
	}
}

//-------------------------------

	// List iterating 
		
	- Iterator<E> iterator(): This method returns a basic Iterator object that allows you to iterate through the 
	  elements of the ArrayList in forward order only. It provides methods like hasNext() to check if there's a 
	  next element and next() to retrieve the next element.

	- ListIterator<E> listIterator(): This method returns a more versatile ListIterator object. It allows you to 
	  iterate forward and backward through the ArrayList. Similar to iterator(), it has hasNext(), next(), but 
	  also offers methods like hasPrevious() to check for a previous element and previous() to retrieve the 
	  previous element.

	- ListIterator<E> listIterator(int index): This method provides even more control. It returns a ListIterator 
	  that starts iterating from the specified index position in the ArrayList. The initial call to next() will 
	  return the element at the provided index, and subsequent calls will iterate forward. An initial call 
	  to previous() will return the element at index - 1 (if it exists).

	Using forEach(): 

	- void	forEach(Consumer<? super E> action): Performs the given action for each element of the Iterable until all elements 
		have been processed or the action throws an exception.


 //  Iterating over userdefined class using iterator: It is just to know how collection classes defined
     iterator inside. 

import java.util.Iterator;

// Define a custom iterable class
class Demo implements Iterable<String> 
{
    private String[] data;
    public Demo(String[] data) 
    {
        this.data = data;
    }
    // Implement the iterator() method required by Iterable interface
    @Override
    public Iterator<String> iterator() 
	{
        return new Iterator<String>() {
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < data.length;
            }

            @Override
            public String next() {
                if (!hasNext()) {
                    throw new java.util.NoSuchElementException();
                }
                return data[index++];
            }
        };
    }
}

public class MyIterableExample 
{
    public static void main(String[] args) 
	{
        // Create an instance of the iterable class
        Demo demo = new Demo(new String[]{"Hello", "World", "Iterable"});

        // Iterate over the elements using a for-each loop
        for (String item : demo) 
	{
            System.out.println(item);
        }

	System.out.println("Using iterator: ");
	Iterator<String> ob=demo.iterator();
	while(ob.hasNext())
	{
		System.out.println(ob.next());
	}
    }
}

	// Actually we have use only in case of collection classes as...

import java.util.*;
class IteratingOverCollectionClass
{
	public static void main(String[] args) 
	{
		ArrayList<String> arraylist=new ArrayList<>(9); 
		arraylist.add("C++");
		arraylist.add("Python");
		arraylist.add("Java");
		arraylist.add(0,"C");

		 // Iterate over the elements using a for-each loop
		System.out.println("Using for-each loop: ");
       		for(String str : arraylist) 
		{
            		System.out.println(str);
        	}

		 // Iterate over the elements using iterator
		System.out.println("Using iterator: ");
		Iterator<String> ob = arraylist.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}

		// Iterate over the elements using list-iterator
		System.out.println("Using listiterator:(FWD)");
		ListIterator<String> itr = arraylist.listIterator();
		while(itr.hasNext())
		{
			System.out.println(itr.next());
		}
 
 		System.out.println("Using listiterator:(PRV)");
		// As it starts from 0th location, prv option give values only when you attend non-zero index, otherwise blank
		while(itr.hasPrevious())
		{
			System.out.println(itr.previous());
		}

		// Using forEach with a Lambda Expression
        	System.out.println("Using Lambda Expression:");
        	arraylist.forEach(e -> System.out.println(e));

		// Using forEach with a Method Reference
        	System.out.println("\nUsing Method Reference:");
        	arraylist.forEach(System.out::println);
	}
}

//----------------------------------------------------------------------

	// Using removeIf()

	boolean	removeIf(Predicate<? super E> filter)
	Removes all of the elements of this collection that satisfy the given predicate.

import java.util.ArrayList;
import java.util.function.Predicate;

public class RemoveIfArrayListExample {

    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        numbers.add(11);
        numbers.add(20);
        numbers.add(33);
        numbers.add(40);
        numbers.add(50);
        numbers.add(61);
        numbers.add(70);
        numbers.add(15);
		System.out.println("Numbers: " + numbers);

        // Predicate to check if a number is even
        Predicate<Integer> isEven = number -> number % 2 == 0;

        // Remove all even numbers using removeIf and Predicate
        numbers.removeIf(isEven);
        System.out.println("Numbers after removing even numbers: " + numbers);

        // Another Predicate to check if a number is greater than 30
        Predicate<Integer> greaterThan30 = number -> number > 30;
		numbers.removeIf(greaterThan30);		
        System.out.println("Numbers after removing >30 numbers: " + numbers);
    }
}

//------------------------------------------------------------------------

	- void replaceAll(UnaryOperator<E> operator): Replaces each element of this list with the result of applying
	  the operator to that element.

import java.util.*;
public class ArrayListExampleReplaceAll {
    public static void main(String[] args) {

        // Creating an ArrayList of Integers
        List<Integer> numbers = new ArrayList<>();
        
        // Adding elements to the ArrayList
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        
        // Printing the original ArrayList
        System.out.println("Original ArrayList: " + numbers);
        
        // Replacing each element with its square
        numbers.replaceAll(n -> n * n);
        
        // Printing the modified ArrayList
        System.out.println("Modified ArrayList: " + numbers);
    }
}

//------------------------------------------------------------------------

	- boolean retainAll(Collection<?> c): Retains only the elements in this list that are contained in the specified 
		collection. In other words, it removes all elements from the current collection that are not contained in 
		the specified collection.

package collectionexamples;
import java.util.ArrayList;
import java.util.Collection;

public class RetainAllExample {
    public static void main(String[] args) {
        // Creating two ArrayLists
        ArrayList<String> list1 = new ArrayList<>();
        ArrayList<String> list2 = new ArrayList<>();
        
        // Adding elements to the first ArrayList
        list1.add("apple");
        list1.add("banana");
        list1.add("orange");
        list1.add("grapes");
        
        // Adding elements to the second ArrayList
        list2.add("banana");
        list2.add("orange");
        list2.add("kiwi");
        
        // Printing the original lists
        System.out.println("Original list1: " + list1);
        System.out.println("Original list2: " + list2);
        
        // Retaining only the elements that are common in both lists
        boolean changed = list1.retainAll(list2);
        
        // Printing the modified list1
        System.out.println("Modified list1: " + list1);
        
        // Checking if the list1 has been modified
        System.out.println("List1 has been modified: " + changed);
    }
}

//------------------------------------------------------------------------
	- void sort(Comparator<? super E> c): Sorts this list according to the order induced by the specified Comparator.
	 	This method is used for sorting elements in a list based on a custom comparison logic. 

		- void: This indicates that the method doesn't return any value after execution.
		- sort: This signifies that the method sorts the elements within a list.
		- <E>: This represents the generic type of the elements in the list.
		- Comparator<? super E> c: This parameter is of type Comparator. It defines a custom comparison logic 
		  that determines the sorting order of the elements. The ? super E part allows the comparator to work 
		  with elements that are subtypes of E. This provides flexibility in sorting elements of different but 
		  related types.
		- c: This is a reference to a Comparator object. A comparator defines how to compare two elements of 
		   the list.

	Note: # The sorting is done by the provided method sort() itself, only you have to provide the comparisation
	        logic, that should be provided using Comparator.
	
	      # for that cerate the custum class which implements Comparator<>, and overrides the method
	
			public int compare( <> p1, <> p2) {
        			return <wrapper_class>.compare(p1.get...(), p2.get...());
    			}

	      # This method will be used as comparisation logic by the sort method internally, and sorts the collection
                automatically for you.
	      # After that, you can go for lambda expression for optimization.


import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

// Comparator implementation to sort products based on their prices
class ProductPriceComparator implements Comparator<Product> {
    @Override
    public int compare(Product p1, Product p2) {
        return Double.compare(p1.getPrice(), p2.getPrice());
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        products.sort(new ProductPriceComparator());

        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}

//----------------------------------------------------------------

	// can be written using anonymous implementation

import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        products.sort(new Comparator<Product>(){
			@Override
			public int compare(Product p1, Product p2) {
				return Double.compare(p1.getPrice(), p2.getPrice());
			}
        });

        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}


//----------------------------------------------------------------

	// Can be optimized using -> functions 

import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        products.sort((Product p1, Product p2) -> {
				return Double.compare(p1.getPrice(), p2.getPrice());
			}
        );

        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}


//----------------------------------------------------------------

	// can further optimized as 

import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        products.sort((p1, p2) ->  Double.compare(p1.getPrice(), p2.getPrice()));
			
  
        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}

//---------------------------------------------------------------------

	// You can use Collections class, having sort() method 
	
	- static <T extends Comparable<? super T>> void	sort(List<T> list)
	  Sorts the specified list into ascending order, according to the natural ordering of its elements.

	- static <T> void sort(List<T> list, Comparator<? super T> c)
	  Sorts the specified list according to the order induced by the specified comparator.

 
import java.util.*;

 class Product {
    private String name;
    private double price;
    private int id;

    public Product(int id, String name, double price) {
		this.id = id;
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return id+" - "+name + ":Rs." + price;
    }
}

public class SortProductsExample {
    public static void main(String[] args) {
        // Create a list of products
        List<Product> products = new ArrayList<>();

        products.add(new Product(12,"Laptop", 90999.99));
        products.add(new Product(89,"Smartphone", 64599.99));
        products.add(new Product(2,"Headphones", 1249.99));
        products.add(new Product(34,"Tablet", 8399.99));

        // Output the list before sorting
        /// System.out.println("Before sorting: " + products);
		System.out.println("\n -------------- Before price sorting -------------------");
		Iterator<Product> ob1 = products.iterator();
		while(ob1.hasNext())
		{
			System.out.println(ob1.next());
		}

        // Sort the list based on product price
        //products.sort((p1, p2) ->  Double.compare(p1.getPrice(), p2.getPrice()));
		
		Collections.sort(products, (p1, p2) -> Double.compare(p1.getPrice(), p2.getPrice()));
  
        // Output the list after sorting
        ///System.out.println("After price sorting: " + products);
		System.out.println("\n -------------- After price sorting -------------------");
		Iterator<Product> ob = products.iterator();
		while(ob.hasNext())
		{
			System.out.println(ob.next());
		}
    }
}


//---------------------------------------------------------------------------------------------------


	// Now Using  void sort(Comparator<? super E> c) from Array List to sort Numbers

import java.util.*;
class CollectiosDemo {
	public static void main(String []args)
	{
		ArrayList<Integer> arlst=new ArrayList<Integer>();
		arlst.add(12);
		arlst.add(32);
		arlst.add(142);
		arlst.add(127);
		arlst.add(42);
		arlst.add(16);
		arlst.add(112);
		System.out.println("Entered Arraylist is: "+arlst);

		arlst.sort( (x,y)-> Integer.compare((int)x,(int)y) );
		System.out.println("Entered(ascending) Arraylist is: "+arlst);

		arlst.sort( (x,y)-> Integer.compare((int)y,(int)x) );
		System.out.println("Entered(descending) Arraylist is: "+arlst);

		// Using Collections
		
		Collections.sort(arlst);
		System.out.println("Entered(ascending) Arraylist is: "+arlst);


		// Collections.sort(arlst,	(x,y)-> Integer.compare((int)y,(int)x));
		// for reverse order Collections class provides the prdefined comparator, Collections.reverseOrder()
		Collections.sort(arlst,	Collections.reverseOrder());
		System.out.println("Entered(descending) Arraylist is: "+arlst);
	}
}

//------------------------------------------------------------------------------------------------------------


- Spliterator<E> spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this list.
	
	Fail-Fast vs. Fail-Safe in Java (Short Explanation)

		1. Fail-Fast
		- Throws ConcurrentModificationException if the collection is modified while iterating.
		- Works directly on the original collection.
		- Faster but not thread-safe.
		- Example: ArrayList, HashSet, HashMap (normal iterators).

		2. Fail-Safe
		- Does not throw exceptions if modified during iteration.
		- Iterates over a separate copy (snapshot).
		- Slower but thread-safe.
		- Example: CopyOnWriteArrayList, ConcurrentHashMap

	In Java, a Spliterator is an interface introduced in Java 8 as part of the Stream API(Application Programming Interface). 
	It provides a way to perform parallel traversal over the elements of a source, such as an array, a generator function, etc.
		
	The ArrayList class in Java also implements the Spliterator interface using the .spliterator() method. This method returns a
	Spliterator over the elements in ArrayList. It is considered a better way to iterate over elements as it gives more 
	control over them.

	The .spliterator() method can be combined with a number of other methods:

	- tryAdvance(): This method is used to iterate elements separately in several threads to enable parallel processing.
	- forEachRemaining(): This method is used to iterate elements consecutively in a single thread.
	- trySplit(): This method splits the obtained Spliterator into separate parts to facilitate parallel processing.


package collectionexamples;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Spliterator;

public class UsingsplIterator {

	public static void main(String []args) {
		
		ArrayList<Integer> arlst=new ArrayList<Integer>();
		arlst.add(12);
		arlst.add(32);
		arlst.add(142);
		arlst.add(127);
		arlst.add(42);
		arlst.add(16);
		arlst.add(112);
		System.out.println("Entered Arraylist is: "+arlst);
		
		Iterator<Integer> ob=arlst.iterator();
		System.out.println("Entered Arraylist(using iterator) is: ");
		while(ob.hasNext())
		{
			System.out.print("  "+ob.next());
		}
		
		ob=arlst.iterator();
		System.out.println("\n Entered Arraylist(using foreach) is: ");
		ob.forEachRemaining(element -> System.out.print(" "+element));
		
		//----------------
		
		Spliterator<Integer> sob = arlst.spliterator();
		System.out.println("\n using spiterator tryadvance()-I: ");
		while(sob.tryAdvance(element -> System.out.print(" "+element)));
		
		sob = arlst.spliterator();
		System.out.println("\n using spiterator tryadvance()-II: ");
		while(sob.tryAdvance(System.out::println)); // shorter way of above
		
		//---------------
		
		sob = arlst.spliterator();
		Spliterator<Integer> sob1 = sob.trySplit(); // a part of sob is separated 
		System.out.println("\n Entered Arraylist(split part) is: ");
		if(sob1!=null)
			sob1.forEachRemaining(element -> System.out.print(" "+element)); // separated part display
		
		System.out.println("\n Entered Arraylist(split part) is: ");
		sob.forEachRemaining(element -> System.out.print(" "+element)); // remaining part display
		
	}

}

//------------------------------------------------------------------------
The important points about Java ArrayList class are:

	- Java ArrayList class can contain duplicate elements.
	- Java ArrayList class maintains insertion order.
	- Java ArrayList class is non-synchronized.
	- Java ArrayList allows random access because array works at the index basis.
	- In Java ArrayList class, manipulation is slow because a lot of shifting needs to have occurred if any element is removed 
	  from the array list.
	- You cannot create an ArrayList of primitive types like int, char, etc. You need to use boxed types like Integer, 
	  Character, Boolean, etc.

//---------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------

interface Queue<E>
--------------------

A collection designed for holding elements prior to processing. Besides basic Collection operations, queues provide additional 
insertion, extraction, and inspection operations. Each of these methods exists in two forms: one throws an exception if the 
operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the 
insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert 
operations cannot fail.

Summary of Queue methods

 - Insert: add(e) and offer(e): The offer method inserts an element at end if possible, otherwise returning false. This differs from the
 	   Collection.add method, which can fail to add an element only by throwing an unchecked exception. The offer method is 
	   designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or 
	   "bounded") queues.

 - Remove: remove() and poll(): The remove() and poll() methods remove and return the head of the queue. The remove() and poll() 
	methods differ only in their behavior when the queue is empty: the remove() method throws an exception, while the poll() 
	method returns null.
		
 - Examine: element() and peek(): The element() and peek() methods return, but do not remove, the head of the queue.

 - Methods in Queue Interface

  public abstract boolean add(E);
  public abstract boolean offer(E);
  public abstract E remove();
  public abstract E poll();
  public abstract E element();
  public abstract E peek();

//-----------------------------------------------------------------

interface Deque<E>
--------------------
 - A linear collection that supports element insertion and removal at both ends. The name deque is short 
   for "double ended queue" 

- Methods in Deque Interface

  public abstract void addFirst(E);
  public abstract void addLast(E);
  public abstract boolean offerFirst(E);
  public abstract boolean offerLast(E);
  public abstract E removeFirst();
  public abstract E removeLast();
  public abstract E pollFirst();
  public abstract E pollLast();
  public abstract E getFirst();
  public abstract E getLast();
  public abstract E peekFirst();
  public abstract E peekLast();
  public abstract boolean removeFirstOccurrence(java.lang.Object);
  public abstract boolean removeLastOccurrence(java.lang.Object);
  public abstract boolean add(E);
  public abstract boolean offer(E);
  public abstract E remove();
  public abstract E poll();
  public abstract E element();
  public abstract E peek();
  public abstract boolean addAll(java.util.Collection<? extends E>);
  public abstract void push(E);
  public abstract E pop();
  public abstract boolean remove(java.lang.Object);
  public abstract boolean contains(java.lang.Object);
  public abstract int size();
  public abstract java.util.Iterator<E> iterator();
  public abstract java.util.Iterator<E> descendingIterator();
  public default java.util.Deque<E> reversed();
  public default java.util.SequencedCollection reversed();
}

//-------------------------------------
	
 Using Java.util.LinkedList:
 ---------------------------
 	- Decl: public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, 
	  Cloneable, Serializable

 	- Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, 
	  and permits all elements (including null).


	- Constructors: 

	 - LinkedList(): Constructs an empty list.
 	 - LinkedList(Collection<? extends E> c): Constructs a list containing the elements of the specified collection, 
   	   in the order they are returned by the collection's iterator.

	- LinkedList Methods:

	First we will discuss some of the useful and frequently used Java LinkedList methods. 
	The following methods are inherited from List or Collection interface:

	- int size(): to get the number of elements in the list.
	- boolean isEmpty(): to check if list is empty or not.
	- boolean contains(Object o): Returns true if this list contains the specified element.
	- Iterator iterator(): Returns an iterator over the elements in this list in proper sequence.
	- Object[] toArray(): Returns an array containing all of the elements in this list in proper sequence.
	- boolean add(E e): Appends the specified element to the end of this list.
	- boolean remove(Object o): Removes the first occurrence of the specified element from this list.
	- boolean retainAll(Collection c): Retains only the elements in this list that are contained in the 
	  specified collection.
	- void clear(): Removes all the elements from the list.
	- E get(int index): Returns the element at the specified position in the list.
	- E set(int index, E element): Replaces the element at the specified position in the list with the 
	  specified element.
	- ListIterator listIterator(): Returns a list iterator over the elements in the list.
	- List subList(int fromIndex, int toIndex): Returns a view of the portion of this list between the 
	  specified fromIndex, inclusive, and toIndex, exclusive. The returned list is backed by this list, 
	  so non-structural changes in the returned list are reflected in this list, and vice-versa.

	Java LinkedList Deque Methods
	The following methods are specific to LinkedList class which are inherited from Deque interface:

	- void addFirst(E e): Inserts the specified element at the beginning of this list.
	- void addLast(E e): Inserts the specified element at the end of this list.
	- E getFirst(): Retrieves, but does not remove, the first element of this list. 
	  This method differs from peekFirst only in that it throws an exception if this list is empty.
	- E getLast(): Retrieves, but does not remove, the last element of this list. This method differs 
	  from peekLast only in that it throws an exception if this list is empty.
	- E remvoeFirst(): Removes and returns the first element from this list.
	- E removeLast(): Removes and returns the last element from this list.
	- boolean offerFirst(E e): Inserts the specified element at the front of this list.
	- boolean offerLast(E e): Inserts the specified element at the end of this list.
	- E pollFirst(): Retrieves and removes the first element of this list, or returns null if this list is empty.
	- E pollLast(): Retrieves and removes the last element of this list, or returns null if this list is empty.
	- E peekFirst(): Retrieves, but does not remove, the first element of this list, or returns null if this list 
	  is empty.
	- E peekLast(): Retrieves, but does not remove, the last element of this list, or returns null if this list 
	  is empty.
	- public E pop(): Pops an element from the stack represented by this list. In other words, 
	  removes and returns the first element of this list.

	Java LinkedList Queue Methods
	The following methods are specific to LinkedList class which are inherited from Queue interface:

	- boolean add(E e): Inserts the specified element into this queue if it is possible to do so immediately 
	  without violating capacity restrictions, returning true upon success and throwing an IllegalStateException 
	  if no space is currently available.
	- E element(): Retrieves, but does not remove, the head of this queue.
	- boolean offer(E e): Inserts the specified element into this queue if it is possible to do so 
	  immediately without violating capacity restrictions.
	- E peek(): Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
	- E poll(): Retrieves and removes the head of this queue, or returns null if this queue is empty.
	- E remove(): Retrieves and removes the head of this queue.NoSuchElementException - if this list is empty

import java.util.ArrayList;
import java.util.LinkedList;

public class LinkListExample {

	public static void main(String[] args) {
//		LinkedList<Integer> l1=new LinkedList<>(); // Empty list
//		System.out.println(l1.remove()); // generates an Exception 
//		System.out.println(l1.poll()); // gives null as output
		
		ArrayList<Integer> al=new ArrayList();
		al.add(12);
		al.add(23);
		al.add(90);
		al.add(32);
		al.add(100);
		LinkedList<Integer> l2=new LinkedList<>(al);

		System.out.println("Element at start: "+l2.element());
		System.out.println("Element at start: "+l2.getFirst());
		System.out.println("Element at start: "+l2.peek());
		System.out.println("Element at start: "+l2.peekFirst());
		System.out.println("Element at start: "+l2.poll());
		System.out.println("Element at start: "+l2.pollFirst());
		System.out.println("Element at start: "+l2.pop());
		System.out.println("Element at start: "+l2.remove());
	}

}


//-----------------------------------------------------

	// Iterating in LinkedList using iterator(), listIterator() and spliterator()

package collectionexamples;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Spliterator;
import java.util.function.Consumer;

public class UsingIteratorInLinkedList {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();
        linkedList.add("Apple");
        linkedList.add("Banana");
        linkedList.add("Cherry");
        linkedList.add("Date");
        linkedList.add("Elderberry");

        // Using iterator() to print all elements
        System.out.println("Using iterator:");
        var iterator = linkedList.iterator();
        // The var keyword in Java is a feature introduced in Java 10 as part of the local 
        // variable type inference. It allows the compiler to infer the type of a local variable 
        // based on the type of the initializer. 
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }

        // Using listIterator() to traverse forward and backward, modifying elements
        System.out.println("\nUsing listIterator (forward and backward):");
        ListIterator<String> listIterator = linkedList.listIterator();
        System.out.println("Traversing forward and modifying:");
        while (listIterator.hasNext()) {
            String fruit = listIterator.next();
            if (fruit.equals("Banana")) {
                listIterator.set("Blueberry");
            }
            System.out.println(fruit);
        }

        System.out.println("Traversing backward:");
        while (listIterator.hasPrevious()) {
            System.out.println(listIterator.previous());
        }

        // Using spliterator() to split and process the list
        System.out.println("\n Using spliterator:");
        Spliterator<String> spliterator1 = linkedList.spliterator();
        Spliterator<String> spliterator2 = spliterator1.trySplit();

        // Consumer to process elements
        Consumer<String> consumer = fruit -> System.out.println("Processing: " + fruit);

        // Process first half of the list
        System.out.println("First spliterator:");
        spliterator1.forEachRemaining(consumer);

        // Process second half of the list
        System.out.println("Second spliterator:");
        if (spliterator2 != null) {
            spliterator2.forEachRemaining(consumer);
        } else {
            System.out.println("Spliterator could not split further.");
        }
    }
}

//-----------------------------------------------------

	// use forEach() and toArray()

package collectionexamples;
import java.util.LinkedList;

public class LinkedListDemo {

    public static void main(String[] args) {
        // Create a LinkedList
        LinkedList<String> fruits = new LinkedList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");
        fruits.add("Mango");

        // 1. Print elements using forEach()
        System.out.println("Printing fruits using forEach():");
        fruits.forEach(fruit -> System.out.println(fruit));

        // 2. Modify elements using forEach()
        System.out.println("\nModifying fruits (uppercase) using forEach():");
        fruits.forEach(fruit -> fruits.set(fruits.indexOf(fruit), fruit.toUpperCase()));
        fruits.forEach(fruit -> System.out.println(fruit));

        // 3. Convert LinkedList to Object array using toArray()
        System.out.println("\nConverting fruits to Object array using toArray():");
        Object[] fruitsArray = fruits.toArray();
        for (Object fruit : fruitsArray) {
            System.out.println(fruit);
        }

        // 4. Convert LinkedList to String array using toArray(String[])
        System.out.println("\nConverting fruits to String array using toArray(String[]):");
        String[] fruitsStringArray = fruits.toArray(new String[fruits.size()]);
        for (String fruit : fruitsStringArray) {
            System.out.println(fruit);
        }
    }
}


//-----------------------------------------------------

	// implement Queue operations using LinkedList

package collectionexamples;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class QueueOperations {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            System.out.println("\n Queue Operations Menu:");
            System.out.println("1. Enqueue");
            System.out.println("2. Dequeue");
            System.out.println("3. Peek");
            System.out.println("4. Check if Queue is Empty");
            System.out.println("5. Display Queue");
            System.out.println("6. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume the newline

            switch (choice) {
                case 1:
                    System.out.print("Enter element to enqueue: ");
                    String element = scanner.nextLine();
                    queue.add(element);
                    System.out.println("Enqueued: " + element);
                    break;
                case 2:
                    if (!queue.isEmpty()) {
                        String removedElement = queue.remove();
                        System.out.println("Dequeued: " + removedElement);
                    } else {
                        System.out.println("Queue is empty. Nothing to dequeue.");
                    }
                    break;
                case 3:
                    if (!queue.isEmpty()) {
                        String frontElement = queue.peek();
                        System.out.println("Front element: " + frontElement);
                    } else {
                        System.out.println("Queue is empty. Nothing to peek.");
                    }
                    break;
                case 4:
                    System.out.println("Is the queue empty? " + queue.isEmpty());
                    break;
                case 5:
                    System.out.println("Queue: " + queue);
                    break;
                case 6:
                    running = false;
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }
        scanner.close();
    }
}

//-----------------------------------------------------

	// implement stack operations using LinkedList

package collectionexamples;
import java.util.LinkedList;
import java.util.Scanner;

public class StackOperations {
    public static void main(String[] args) {
        LinkedList<String> stack = new LinkedList<>();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            System.out.println("\nStack Operations Menu:");
            System.out.println("1. Push");
            System.out.println("2. Pop");
            System.out.println("3. Peek");
            System.out.println("4. Check if Stack is Empty");
            System.out.println("5. Display Stack");
            System.out.println("6. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume the newline

            switch (choice) {
                case 1:
                    System.out.print("Enter element to push: ");
                    String element = scanner.nextLine();
                    stack.push(element); // Push element onto the stack
                    System.out.println("Pushed: " + element);
                    break;
                case 2:
                    if (!stack.isEmpty()) {
                        String poppedElement = stack.pop(); // Pop element from the stack
                        System.out.println("Popped: " + poppedElement);
                    } else {
                        System.out.println("Stack is empty. Nothing to pop.");
                    }
                    break;
                case 3:
                    if (!stack.isEmpty()) {
                        String topElement = stack.peek(); // Peek at the top element of the stack
                        System.out.println("Top element: " + topElement);
                    } else {
                        System.out.println("Stack is empty. Nothing to peek.");
                    }
                    break;
                case 4:
                    System.out.println("Is the stack empty? " + stack.isEmpty());
                    break;
                case 5:
                    System.out.println("Stack: " + stack);
                    break;
                case 6:
                    running = false;
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }        
        scanner.close();
    }
}

//-------------------------------------------------------------------------------------

 // implement All linked list operations using LinkedList

package collectionexamples;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Collections;
import java.util.Scanner;

public class LinkedListOperations {
    public static void main(String[] args) {
        LinkedList<Integer> linkedList = new LinkedList<>();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            System.out.println("\nLinkedList Operations Menu:");
            System.out.println("1. Add to the front");
            System.out.println("2. Add to the end");
            System.out.println("3. Add at a specific position");
            System.out.println("4. Remove from the front");
            System.out.println("5. Remove from the end");
            System.out.println("6. Remove by value");
            System.out.println("7. Get first element");
            System.out.println("8. Get last element");
            System.out.println("9. Get element at a specific position");
            System.out.println("10. Update element at a specific position");
            System.out.println("11. Traverse the list forward");
            System.out.println("12. Search by value");
            System.out.println("13. Size of the list");
            System.out.println("14. Check if the list is empty");
            System.out.println("15. Clear the list");
            System.out.println("16. Convert to array");
            System.out.println("17. Sort the list");
            System.out.println("18. Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();
            scanner.nextLine();  // Consume the newline

            switch (choice) {
                case 1:
                    System.out.print("Enter element to add to the front: ");
                    int element1 = scanner.nextInt();
                    linkedList.addFirst(element1);
                    System.out.println("List: " + linkedList);
                    break;
                case 2:
                    System.out.print("Enter element to add to the end: ");
                    int element2 = scanner.nextInt();
                    linkedList.addLast(element2);
                    System.out.println("List: " + linkedList);
                    break;
                case 3:
                    System.out.print("Enter position: ");
                    int position = scanner.nextInt();
                    scanner.nextLine();  // Consume the newline
                    System.out.print("Enter element to add: ");
                    int element3 = scanner.nextInt();
                    linkedList.add(position, element3);
                    System.out.println("List: " + linkedList);
                    break;
                case 4:
                    if (!linkedList.isEmpty()) {
                        linkedList.removeFirst();
                        System.out.println("List: " + linkedList);
                    } else {
                        System.out.println("The list is empty.");
                    }
                    break;
                case 5:
                    if (!linkedList.isEmpty()) {
                        linkedList.removeLast();
                        System.out.println("List: " + linkedList);
                    } else {
                        System.out.println("The list is empty.");
                    }
                    break;
                case 6:
                    System.out.print("Enter element to remove: ");
                    int element4 = scanner.nextInt();
                    if (linkedList.remove(Integer.valueOf(element4))) {
                        System.out.println("Element removed. List: " + linkedList);
                    } else {
                        System.out.println("Element not found in the list.");
                    }
                    break;
                case 7:
                    if (!linkedList.isEmpty()) {
                        System.out.println("First element: " + linkedList.getFirst());
                    } else {
                        System.out.println("The list is empty.");
                    }
                    break;
                case 8:
                    if (!linkedList.isEmpty()) {
                        System.out.println("Last element: " + linkedList.getLast());
                    } else {
                        System.out.println("The list is empty.");
                    }
                    break;
                case 9:
                    System.out.print("Enter position: ");
                    int position2 = scanner.nextInt();
                    if (position2 >= 0 && position2 < linkedList.size()) {
                        System.out.println("Element at position " + position2 + ": " + linkedList.get(position2));
                    } else {
                        System.out.println("Invalid position.");
                    }
                    break;
                case 10:
                    System.out.print("Enter position: ");
                    int position3 = scanner.nextInt();
                    scanner.nextLine();  // Consume the newline
                    if (position3 >= 0 && position3 < linkedList.size()) {
                        System.out.print("Enter new element: ");
                        int newElement = scanner.nextInt();
                        linkedList.set(position3, newElement);
                        System.out.println("List: " + linkedList);
                    } else {
                        System.out.println("Invalid position.");
                    }
                    break;
                case 11:
                    System.out.println("Forward traversal:");
                    ListIterator<Integer> iterator = linkedList.listIterator();
                    while (iterator.hasNext()) {
                        System.out.println(iterator.next());
                    }
                    break;
                case 12:
                    System.out.print("Enter element to search: ");
                    int element5 = scanner.nextInt();
                    boolean contains = linkedList.contains(element5);
                    System.out.println("Contains " + element5 + "? " + contains);
                    break;
                case 13:
                    System.out.println("Size of the list: " + linkedList.size());
                    break;
                case 14:
                    boolean isEmpty = linkedList.isEmpty();
                    System.out.println("Is the list empty? " + isEmpty);
                    break;
                case 15:
                    linkedList.clear();
                    System.out.println("List cleared. Current list: " + linkedList);
                    break;
                case 16:
                    Object[] array = linkedList.toArray();
                    System.out.println("List converted to array: " + java.util.Arrays.toString(array));
                    break;
                case 17:
                    Collections.sort(linkedList);
                    System.out.println("Sorted list: " + linkedList);
                    break;
                case 18:
                    running = false;
                    System.out.println("Exiting...");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
        }

        scanner.close();
    }
}

//------------------------------------------------------------------------------------------------------

	// Attending Thread safety using Collections.synchronizedList() 


	Collections.synchronizedList() in Java is used to create a synchronized wrapper around an 
	existing list, making it thread-safe for modifications.

package collectionexamples;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SynchronizedListExample  {

    public static void main(String[] args) throws InterruptedException {
        // Create an ArrayList
        List<Integer> numbers = new LinkedList<>();

        // Wrap it in a synchronized list
        List<Integer> synchronizedNumbers = Collections.synchronizedList(numbers);

        // Thread 1 keeps adding numbers
        Thread thread1 = new Thread(() -> {
            for (int i = 1; i <= 100; i++) {
                synchronizedNumbers.add(i);
                try {
                    Thread.sleep(200); // Simulate some work
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // Thread 2 keeps printing the list size
        Thread thread2 = new Thread(() -> {
            while (true) {
                System.out.println("List Size: " + synchronizedNumbers.size());
                try {
                    Thread.sleep(100); // Simulate some work
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // Start both threads
        thread1.start();
        thread2.start();

        // Wait for threads to finish (unlikely due to the infinite loop in thread2)
        thread1.join();
        thread2.join();
    }
}

//-----------------------------------------------------

	// Attaending immutability in Collections

	An object is considered immutable if its state cannot change after it is constructed. In Java, you can create immutable 
	lists using various approaches. Immutable lists are lists whose elements cannot be changed, added, or removed after the 
	list is created. 

	1. Using Collections.unmodifiableList():

	This method takes an existing mutable list and returns a wrapper that prevents modifications to the list structure 
	(adding, removing, or replacing elements). However, the elements themselves can still be mutable if they are 
	mutable objects.

package collectionexamples;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

public class UnmodifiableListDemo {

    public static void main(String[] args) {
        // Create a LinkedList
        LinkedList<String> fruits = new LinkedList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

        System.out.println("Original List (LinkedList): ");
        printList(fruits);

        // Create an unmodifiable view using Collections.unmodifiableList()
        List<String> unmodifiableList = Collections.unmodifiableList(fruits);

        System.out.println("\nUnmodifiable List: ");
        printList(unmodifiableList);

        // Trying to modify the unmodifiable list throws an exception
        try {
            unmodifiableList.add("Mango");
            System.out.println("Successfully added Mango (should not happen!)");
        } catch (UnsupportedOperationException e) {
            System.out.println("Adding element to unmodifiable list: " + e);
        }

        // Modifications to the original list are still reflected
        fruits.addFirst("Grape");
        System.out.println("\nAfter modifying original list (LinkedList): ");
        printList(fruits);

        System.out.println("\nUnmodifiable List (after modification): ");
        printList(unmodifiableList);
    }

    private static void printList(List<String> list) {
        for (String fruit : list) {
            System.out.print(fruit + " ");
        }
        System.out.println();
    }
}

//---------

	2. Using Java 9+ List.of() Factory Method:

	Java 9 introduced a factory method List.of() that can be used to create immutable lists. 
	This method is convenient for creating small, fixed-size lists.
		e.g.
			List<String> colors = List.of("Red", "Green", "Blue");

package collectionexamples;
import java.util.LinkedList;
import java.util.List;

public class ListOfDemo {

    public static void main(String[] args) {
        // LinkedList cannot be used directly with List.of()
        // System.out.println(List.of(new LinkedList<>())); // Compilation error

        // Option 1: Convert LinkedList to an array and use List.of()
        LinkedList<String> fruits = new LinkedList<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

        String[] fruitsArray = fruits.toArray(new String[fruits.size()]);
        List<String> immutableList = List.of(fruitsArray);

        System.out.println("Original List (LinkedList): ");
        printList(fruits);

        System.out.println("\nImmutable List (using List.of() with array): ");
        printList(immutableList);

        // Trying to modify the immutable list throws an exception
        try {
            immutableList.add("Mango");
            System.out.println("Successfully added Mango (should not happen!)");
        } catch (UnsupportedOperationException e) {
            System.out.println("Adding element to unmodifiable list: " + e);
        }

        // Modifications to the original list (LinkedList) are not reflected
        fruits.addFirst("Grape");
        System.out.println("\nAfter modifying original list (LinkedList): ");
        printList(fruits);

        System.out.println("\nImmutable List (after modification - not reflected): ");
        printList(immutableList);
    }

    private static void printList(List<String> list) {
        for (String fruit : list) {
            System.out.print(fruit + " ");
        }
        System.out.println();
    }
}

//----------------------------------------------------------------------------------------------------------------------------------

	// Using java.util.Vector: 
	-----------------------

	Vector is a resizable array implementation of the List interface, synchronized for thread safety. 
	It is part of java.util and provides dynamic storage like ArrayList, but with synchronization.

	Constructors of Vector:
	- Vector()	Creates an empty vector with an initial capacity of 10.
	- Vector(int initialCapacity)	Creates a vector with the specified initial capacity.
	- Vector(int initialCapacity, int capacityIncrement)	Creates a vector with specified initial capacity and increment value when resizing.
	- Vector(Collection<? extends E> c)	Creates a vector containing elements from the given collection.

	Methods in Vector:

	- boolean add(E e)	Appends the element to the end of the vector.
	- void add(int index, E element)	Inserts the element at the specified index.
	- boolean addAll(Collection<? extends E> c)	Appends all elements from the given collection.
	- boolean addAll(int index, Collection<? extends E> c)	Inserts all elements from a collection at the specified index.
	- void addElement(E obj)	Adds an element to the vector (legacy method).

	- E get(int index)	Returns the element at the specified index.
	- E firstElement()	Returns the first element in the vector.
	- E lastElement()	Returns the last element in the vector.
	- boolean contains(Object o)	Checks if the vector contains the specified element.
	- int indexOf(Object o)	Returns the index of the first occurrence of the element.
	- int indexOf(Object o, int index)	Returns index of the element starting from a given index.
	- int lastIndexOf(Object o)	Returns the index of the last occurrence of the element.
	- int lastIndexOf(Object o, int index)	Returns the last index before a given position.


	- E remove(int index)	Removes the element at the specified index.
	- boolean remove(Object o)	Removes the first occurrence of the specified object.
	- void removeElementAt(int index)	Removes the element at the specified index (legacy method).
	- void removeElement(Object obj)	Removes the first occurrence of the specified element (legacy method).
	- void removeAllElements()	Removes all elements from the vector.
	- boolean removeAll(Collection<?> c)	Removes all elements from the collection.

	- E set(int index, E element)	Replaces the element at the specified index.
	- void setElementAt(E obj, int index)	Sets the element at the specified index (legacy method).
	- void insertElementAt(E obj, int index)	Inserts an element at the specified index (legacy method).


	- int size()	Returns the number of elements in the vector.
	- boolean isEmpty()	Checks if the vector is empty.
	- void ensureCapacity(int minCapacity)	Ensures minimum capacity.
	- int capacity()	Returns the current capacity of the vector.
	- void trimToSize()	Reduces capacity to match the size of the vector.
	- void setSize(int newSize)	Sets the vector size, truncating or padding with null.


	- Iterator<E> iterator()	Returns an iterator over elements in order.
	- ListIterator<E> listIterator()	Returns a list iterator for bidirectional traversal.
	- ListIterator<E> listIterator(int index)	Returns a list iterator starting from a given index.
	- Enumeration<E> elements()	Returns an enumeration of the vector elements.
	- void forEach(Consumer<? super E> action)	Performs an action for each element.

	- static <T> List<T> synchronizedList(List<T> list)	Returns a synchronized list for thread safety.

	- Object[] toArray()	Converts the vector into an object array.
	- <T> T[] toArray(T[] a)	Converts the vector into a typed array.
	- boolean containsAll(Collection<?> c)	Checks if the vector contains all elements of a collection.
	- boolean retainAll(Collection<?> c)	Retains only elements in the given collection.
	- void clear()	Removes all elements from the vector.
	- Vector<E> clone()	Creates a shallow copy of the vector.
	- Spliterator<E> spliterator()	Returns a spliterator for parallel processing.
	- int hashCode()	Returns the hash code of the vector.
	- boolean equals(Object obj)	Compares this vector with another object


	Difference Between size() and capacity() in Vector
	- size(): Returns the number of elements currently present in the Vector.
	- capacity(): Returns the total allocated storage space in the Vector, 
	  which may be larger than size().

import java.util.Vector;

public class VectorSizeCapacityExample {
    public static void main(String[] args) {
        // Creating a Vector with an initial capacity of 5
        Vector<String> fruits = new Vector<>(5);

        // Displaying initial size and capacity
        System.out.println("Initial Size: " + fruits.size());  // 0
        System.out.println("Initial Capacity: " + fruits.capacity()); // 5

        // Adding elements
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

        // Displaying size and capacity after adding elements
        System.out.println("\nAfter Adding 3 Elements:");
        System.out.println("Size: " + fruits.size());  // 3
        System.out.println("Capacity: " + fruits.capacity()); // Still 5

        // Adding more elements beyond initial capacity
        fruits.add("Mango");
        fruits.add("Grapes");
        fruits.add("Pineapple");  // This triggers capacity expansion

        // Displaying size and capacity after exceeding initial capacity
        System.out.println("\nAfter Adding 6 Elements:");
        System.out.println("Size: " + fruits.size());  // 6
        System.out.println("Capacity: " + fruits.capacity()); // Increased (default doubles to 10)
    }
}

//-----------------------------------------------------------------------------------------------------

	// Different Ways to Iterate Over a Vector in Java


import java.util.Vector;

public class ForLoopExample {
    public static void main(String[] args) {
        Vector<String> fruits = new Vector<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");

	// ndex-based Iteration
        System.out.println("Using for loop:");
        for (int i = 0; i < fruits.size(); i++) {
            System.out.println(fruits.get(i));
        }

	System.out.println("Using for-each loop:");
        for (String fruit : fruits) {
            System.out.println(fruit);
        }

 	System.out.println("Using Iterator:");
        Iterator<String> iterator = fruits.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }

	 System.out.println("Using ListIterator (Forward Direction):");
        ListIterator<String> listIterator = fruits.listIterator();
        while (listIterator.hasNext()) {
            System.out.println(listIterator.next());
        }

        System.out.println("\nUsing ListIterator (Backward Direction):");
        while (listIterator.hasPrevious()) {
            System.out.println(listIterator.previous());
        }

	System.out.println("Using Enumeration:");
        Enumeration<String> enumeration = fruits.elements();
        while (enumeration.hasMoreElements()) {
            System.out.println(enumeration.nextElement());
        }

	System.out.println("Using forEach() with Lambda:");
        fruits.forEach(fruit -> System.out.println(fruit));

	System.out.println("Using Method Reference:");
        fruits.forEach(System.out::println);

    }
}

//---------------------------------------------------------------------------

	// java.util.Stack Overview
	//-------------------------

	Stack is a subclass of Vector that implements a Last-In, First-Out (LIFO) data structure.

	Constructors of Stack
		Stack() – Creates an empty stack with an initial capacity of 10 (inherited from Vector).

	Methods of Stack
	1. Stack-Specific Methods
		E push(E item) – Pushes an element onto the top of the stack.
		E pop() – Removes and returns the top element of the stack.
		E peek() – Returns the top element without removing it.
		boolean empty() – Checks if the stack is empty.
		int search(Object o) – Returns the 1-based position of an element from the top of the stack, or -1 if not found.
	2. Inherited from Vector
		boolean add(E e) – Adds an element at the end.
		void add(int index, E element) – Inserts an element at a specific position.
		boolean addAll(Collection<? extends E> c) – Appends all elements from a collection.
		boolean remove(Object o) – Removes the first occurrence of an element.
		E remove(int index) – Removes the element at a specific index.
		void clear() – Removes all elements from the stack.
		E get(int index) – Retrieves the element at a specific index.
		E set(int index, E element) – Updates the element at a given index.
		int size() – Returns the number of elements in the stack.
		boolean contains(Object o) – Checks if the stack contains a specific element.
		int indexOf(Object o) – Returns the index of the first occurrence of an element.
		int lastIndexOf(Object o) – Returns the last occurrence index of an element.
		Object[] toArray() – Converts the stack to an array.
		Iterator<E> iterator() – Returns an iterator for iterating over the stack.
		ListIterator<E> listIterator() – Returns a list iterator for bidirectional iteration.

	Key Points
	- Stack is synchronized as it extends Vector, making it thread-safe but slower than Deque (ArrayDeque).
	- Preferred alternative: Deque (ArrayDeque) is recommended for better performance in stack operations.


import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        // Creating a Stack
        Stack<Integer> stack = new Stack<>();

        // Pushing elements onto the stack
        stack.push(10);
        stack.push(20);
        stack.push(30);
        System.out.println("Stack after push operations: " + stack);

        // Popping an element from the stack
        int poppedElement = stack.pop();
        System.out.println("Popped element: " + poppedElement);
        System.out.println("Stack after pop operation: " + stack);

        // Peeking the top element of the stack
        int topElement = stack.peek();
        System.out.println("Top element (peek): " + topElement);

        // Checking if the stack is empty
        System.out.println("Is stack empty? " + stack.isEmpty());

        // Searching for an element (returns 1-based index, or -1 if not found)
        int position = stack.search(10);
        System.out.println("Position of 10 in stack: " + position);
    }
}


//----------------------------------------------------------------------------------------------------------------------

	The difference between Collections and Collection in Java is significant:

	1. Collection (java.util.Collection)
	- It is an interface in the java.util package.
	- It is the root interface for most of the Java collections framework (except for Map).
	- It provides methods like add(), remove(), size(), iterator(), etc.
	- Subinterfaces include List, Set, and Queue.

	2. Collections (java.util.Collections)
	- It is a utility class in the java.util package.
	- It provides static methods to operate on collections, such as sorting, searching, synchronizing, and shuffling.
	- Methods include sort(), binarySearch(), reverse(), shuffle(), etc.



//----------------------------------------------------------------------------------------------------------------------------------

The java.util.PriorityQueue class:
----------------------------------

	The java.util.PriorityQueue class in Java is part of the Java Collections Framework and provides the 
	functionality of a priority queue. A priority queue is a data structure that allows elements to be 
	processed based on their priority. It is typically implemented using a heap data structure, 
	which allows efficient retrieval of the highest (or lowest) priority element.

	1. What is a Heap?
	A heap is a complete binary tree, meaning all levels are fully filled except possibly the last level, 
	which is filled from left to right.

	Each node has a key (value), and the heap structure follows either:
	- Min-Heap: The parent node is always smaller than or equal to its children.
	- Max-Heap: The parent node is always greater than or equal to its children.

	By default, a PriorityQueue is a min-heap, meaning the smallest element (according to natural ordering or a 
	specified comparator) is always at the head of the queue. It dynamically resizes as elements are added or 
	removed. It is not thread-safe. For concurrent access, consider using PriorityBlockingQueue from the 
	java.util.concurrent package.


	Key Features:
	- Heap-Based Priority Queue: Internally implemented using a binary heap.
	- Orders Elements by Priority:
		- By default, it is a Min-Heap (smallest element at the front).
		- Can use a custom comparator for a Max-Heap.
	- Non-Synchronized: Not thread-safe, use PriorityBlockingQueue for concurrent operations.
	- Does Not Allow null: Throws NullPointerException if null is added.
	- Supports Duplicates: Unlike Set, it allows duplicate elements.
	- Time Complexity:
		- Insertion (offer()): O(log n)
		- Deletion (poll()): O(log n)
		- Peek (peek()): O(1) (retrieves the highest priority element)


constructors: 

- PriorityQueue(): Creates a priority queue with default initial capacity (11) and natural ordering.

- PriorityQueue(int initialCapacity): Creates a priority queue with the specified initial capacity and 
	natural ordering.

- PriorityQueue(Comparator<? super E> comparator): Creates a PriorityQueue with the default initial capacity 
  and whose elements are ordered according to the specified comparator.

- PriorityQueue(int initialCapacity, Comparator<? super E> comparator): Creates a priority queue with the 
	specified initial capacity and custom comparator ordering.

- PriorityQueue(Collection<? extends E> c): Creates a priority queue containing elements from the specified 
	collection with natural ordering.

- PriorityQueue(PriorityQueue<? extends E> c): Creates a priority queue containing elements from the specified 
	priority queue with the same ordering.

- PriorityQueue(SortedSet<? extends E> c): Creates a priority queue containing elements from the specified sorted set 
	with the same ordering.

	Common Methods:

	- boolean offer(E e)		Inserts an element into the queue.
	- E poll()			Retrieves and removes the highest priority element.
	- E peek()			Retrieves but does not remove the highest priority element.
	- boolean add(E e)		Similar to offer(), but throws exception if insertion fails.
	- boolean remove(Object o)	Removes the specified element.
	- boolean contains(Object o)	Checks if an element exists.
	- int size()			Returns the number of elements.
	- void clear()			Removes all elements.
	- Iterator<E> iterator()	Returns an iterator over the elements.

	// Using default constructor and add(E):

package collectionexamples;
import java.util.PriorityQueue;
import java.util.Queue;
public class PriorityQueueExample {

	public static void main(String []args)
	{
		Queue<Integer> prq = new PriorityQueue<>();
		// prq uses the min heap as an internal data structure by default.
		prq.add(4);
		prq.add(3);
		prq.add(12);
		prq.add(45);
		prq.add(24);
		prq.add(11);
		prq.add(2);
		prq.add(18);
		prq.add(1);
		System.out.println("Original prq is: "+prq);
		prq.remove(4);
		System.out.println("After prq is: "+prq);
	}
}

---------- After Run ------------
Original prq is: [1, 2, 3, 4, 24, 12, 11, 45, 18]
After prq is: [1, 2, 3, 18, 24, 12, 11, 45]

  Note that the Min Heap (Tree based) used as a internal data structure so at the add and remove 
  the heapfy operation plays an important role.


//-----------------------------------------------------------------------------------------------------------------

	// Using max heap as an internal data structure


	- Min-Heap: (bydefault) PriorityQueue<Integer> minHeap = new PriorityQueue<>();
	- max-Heap:  PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());


package collectionexamples;
import java.util.Comparator;
import java.util.PriorityQueue;
import java.util.Queue;
public class PriorityQueueExample {

	public static void main(String []args)
	{
		Queue<Integer> prq = new PriorityQueue<>(Comparator.reverseOrder()); 
		// Comparator.reverseOrder() prq uses the max heap as an internal data structure
		prq.add(4);
		prq.add(3);
		prq.add(12);
		prq.add(45);
		prq.add(24);
		prq.add(11);
		prq.add(2);
		prq.add(18);
		prq.add(1);
		System.out.println("Original prq is: "+prq);
		prq.remove(4);
		System.out.println("After prq is: "+prq);
	}
}

//--------------------------------------------------------------------------------

	// Creating PriorityQueue using ArrayList

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
public class PriorityQueueExample {

	public static void main(String []args)
	{
		List<Integer> lst=new ArrayList<>();
		lst.add(4);
		lst.add(3);
		lst.add(12);
		lst.add(45);
		lst.add(24);
		lst.add(11);
		lst.add(2);
		lst.add(18);
		lst.add(1);
		Queue<Integer> prq = new PriorityQueue<>(lst); 
		System.out.println("Original prq is: "+prq);
	}
}

//------------------------------------------------------------------------------

	// Creating PriorityQueue from another PriorityQueue 


import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
public class PriorityQueueExample {

	public static void main(String []args)
	{
		List<Integer> lst=new ArrayList<>();
		lst.add(4);
		lst.add(3);
		lst.add(12);
		lst.add(45);
		lst.add(24);
		lst.add(11);
		lst.add(2);
		lst.add(18);
		lst.add(1);
		Queue<Integer> prq = new PriorityQueue<>(lst); 
		System.out.println("Original prq is: "+prq);
		
		Queue<Integer> p1 = new PriorityQueue<>(prq); 
		System.out.println("Now prq is: "+prq);
		System.out.println(" p1 is: "+p1);		

		prq.remove(4);
		
		System.out.println("Now again prq is: "+prq);
		System.out.println("again p1 is: "+p1);		
	}
}


//------------------------------------------------------------------------------------------

	// Using custom comparator to create the priority queue

 We can use the Compariable to decide the ordering oe elements in the Priority queue as

import java.util.PriorityQueue;
import java.util.Comparator;

class Person implements Comparable<Person> {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age); // Compare by age
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class CustomObjectPriorityQueue {
    public static void main(String[] args) {
        // PriorityQueue with custom objects (min-heap based on age)
        PriorityQueue<Person> personQueue = new PriorityQueue<>();

        personQueue.add(new Person("Amol", 30));
        personQueue.add(new Person("Bharat", 25));
        personQueue.add(new Person("Chaya", 35));
        personQueue.add(new Person("Neha", 5));

        System.out.println("Polling elements from Person Queue:");
        while (!personQueue.isEmpty()) {
            System.out.println(personQueue.poll());
        }
    }
}

//-------------------------------------

	// Anonymous implementation of Comparator  can be replaced with lambda expression as


import java.util.PriorityQueue;
import java.util.Comparator;

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class CustomObjectPriorityQueue1 {
    public static void main(String[] args) {

        // Comparator to compare Person objects by age
        Comparator<Person> ageComparator = (Person p1, Person p2) -> Integer.compare(p1.age, p2.age);
	// can be replaced using Comparator<Person> ageComparator = (p1, p2) -> Integer.compare(p1.age, p2.age);


        // PriorityQueue with custom comparator (min-heap based on age)
        PriorityQueue<Person> personQueue = new PriorityQueue<>(ageComparator);

        personQueue.add(new Person("Amol", 30));
        personQueue.add(new Person("Bharat", 25));
        personQueue.add(new Person("Chaya", 35));
        personQueue.add(new Person("Neha", 5));

        System.out.println("Polling elements from Person Queue:");
        while (!personQueue.isEmpty()) {
            System.out.println(personQueue.poll());
        }
    }
}

//---------------------------------------------------------------------------

	// again we can write it as 


import java.util.PriorityQueue;
import java.util.Comparator;

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

public class CustomObjectPriorityQueue1 {
    public static void main(String[] args) {

        // PriorityQueue with custom comparator (min-heap based on age)
        PriorityQueue<Person> personQueue = new PriorityQueue<>((p1, p2) -> Integer.compare(p1.age, p2.age));

        personQueue.add(new Person("Amol", 30));
        personQueue.add(new Person("Bharat", 25));
        personQueue.add(new Person("Chaya", 35));
        personQueue.add(new Person("Neha", 5));

        System.out.println("Polling elements from Person Queue:");
        while (!personQueue.isEmpty()) {
            System.out.println(personQueue.poll());
        }
    }
}

//-------------------------------------

	Key Points to Remember about PriorityQueue<E> 

	- PriorityQueue<E> (Min-Heap by Default)
	- Implements Queue<E> interface – Part of Java's Collection Framework.
	- Uses a Min-Heap (by default) or Max-Heap (with a custom comparator).
	- Maintains natural ordering – The smallest (or highest priority) element is always at the front.
	- Does not allow null values.
	- Not thread-safe – Use PriorityBlockingQueue if concurrency is needed.
	- Methods to remember:
		- add(E e) / offer(E e) → Inserts an element.
		- poll() → Retrieves and removes the head (smallest element).
		- peek() → Retrieves but does not remove the head.
		- remove(Object o) → Removes a specific element if present.
	- Time Complexity:
		- Insertion: O(log n)
		- Deletion (poll/remove): O(log n)
		- Peek (retrieving min/max element): O(1)

	
//-----------------------------------------------------------------------------------------------------------

	// using java.util.ArrayDeque<E>

	Resizable-array implementation of the Deque interface. Array deques have no capacity restrictions; 
	they grow as necessary to support usage. They are not thread-safe. Null elements are prohibited. 
	
	This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when 
	used as a queue.
	
	Here is a list of constructors and methods of java.util.ArrayDeque along with a brief description for 
	each:

	Constructors
	- ArrayDeque(): Creates an empty deque with an initial capacity sufficient to hold 16 elements.

	- ArrayDeque(int numElements): Creates an empty deque with an initial capacity sufficient to hold 
	  the specified number of elements.

	- ArrayDeque(Collection<? extends E> c): Creates a deque containing the elements of the specified 
	  collection, in the order they are returned by the collection's iterator.

	Methods
	- void add(E e): Inserts the specified element at the end of this deque.
	- void addFirst(E e): Inserts the specified element at the front of this deque.
	- void addLast(E e): Inserts the specified element at the end of this deque.
	- void clear(): Removes all of the elements from this deque.
	- ArrayDeque<E> clone(): Returns a shallow copy of this deque.
	- boolean contains(Object o): Returns true if this deque contains the specified element.
	- Iterator<E> descendingIterator(): Returns an iterator over the elements in this deque in reverse sequential order.
	- E element(): Retrieves, but does not remove, the head of this deque.
	- E getFirst(): Retrieves, but does not remove, the first element of this deque.
	- E getLast(): Retrieves, but does not remove, the last element of this deque.
	- boolean isEmpty(): Returns true if this deque contains no elements.
	- Iterator<E> iterator(): Returns an iterator over the elements in this deque in proper sequence.
	- boolean offer(E e): Inserts the specified element at the end of this deque (equivalent to add).
	- boolean offerFirst(E e): Inserts the specified element at the front of this deque.
	- boolean offerLast(E e): Inserts the specified element at the end of this deque.
	- E peek(): Retrieves, but does not remove, the head of this deque, or returns null if this deque is empty.
	- E peekFirst(): Retrieves, but does not remove, the first element of this deque, or returns null if this deque is empty.
	- E peekLast(): Retrieves, but does not remove, the last element of this deque, or returns null if this deque is empty.
	- E poll(): Retrieves and removes the head of this deque, or returns null if this deque is empty.
	- E pollFirst(): Retrieves and removes the first element of this deque, or returns null if this deque is empty.
	- E pollLast(): Retrieves and removes the last element of this deque, or returns null if this deque is empty.
	- E pop(): Pops an element from the stack represented by this deque (equivalent to removeFirst).
	- void push(E e): Pushes an element onto the stack represented by this deque (equivalent to addFirst).
	- void remove(): Retrieves and removes the head of this deque.
	- boolean remove(Object o): Removes the first occurrence of the specified element from this deque.
	- E removeFirst(): Retrieves and removes the first element of this deque.
	- boolean removeFirstOccurrence(Object o): Removes the first occurrence of the specified element from this deque.
	- E removeLast(): Retrieves and removes the last element of this deque.
	- boolean removeLastOccurrence(Object o): Removes the last occurrence of the specified element from this deque.
	- int size(): Returns the number of elements in this deque.
	- Spliterator<E> spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this deque.

import java.util.ArrayDeque;
import java.util.Deque;

public class ArrayDequeDemo {
    public static void main(String[] args) {
        // Initialize an ArrayDeque
        Deque<String> deque = new ArrayDeque<>();

        // Add elements at the end
        deque.add("One");
        deque.add("Two");
        deque.add("Three");
        System.out.println("After add: " + deque);

        // Add elements at the beginning
        deque.addFirst("Zero");
        System.out.println("After addFirst: " + deque);

        // Add elements at the end
        deque.addLast("Four");
        System.out.println("After addLast: " + deque);

        // Offer elements (equivalent to add but returns false if it fails)
        deque.offer("Five");
        System.out.println("After offer: " + deque);

        deque.offerFirst("Minus One");
        System.out.println("After offerFirst: " + deque);

        deque.offerLast("Six");
        System.out.println("After offerLast: " + deque);

        // Access elements without removal
        System.out.println("peek: " + deque.peek());
        System.out.println("peekFirst: " + deque.peekFirst());
        System.out.println("peekLast: " + deque.peekLast());

        // Remove elements
        System.out.println("poll: " + deque.poll());
        System.out.println("After poll: " + deque);

        System.out.println("pollFirst: " + deque.pollFirst());
        System.out.println("After pollFirst: " + deque);

        System.out.println("pollLast: " + deque.pollLast());
        System.out.println("After pollLast: " + deque);

        // Remove specific elements
        deque.remove("Two");
        System.out.println("After remove 'Two': " + deque);

        // Stack operations
        deque.push("First");
        System.out.println("After push: " + deque);

        System.out.println("pop: " + deque.pop());
        System.out.println("After pop: " + deque);

        // Remaining methods
        deque.add("Seven");
        deque.add("Eight");
        deque.add("Nine");
        System.out.println("After adding more elements: " + deque);

        System.out.println("removeFirst: " + deque.removeFirst());
        System.out.println("After removeFirst: " + deque);

        System.out.println("removeLast: " + deque.removeLast());
        System.out.println("After removeLast: " + deque);

        System.out.println("getFirst: " + deque.getFirst());
        System.out.println("getLast: " + deque.getLast());

        // Clear the deque
        deque.clear();
        System.out.println("After clear: " + deque);

        // Handling exceptions
        try {
            deque.removeFirst();
        } catch (Exception e) {
            System.out.println("Exception on removeFirst: " + e);
        }

        try {
            deque.removeLast();
        } catch (Exception e) {
            System.out.println("Exception on removeLast: " + e);
        }

        try {
            deque.getFirst();
        } catch (Exception e) {
            System.out.println("Exception on getFirst: " + e);
        }

        try {
            deque.getLast();
        } catch (Exception e) {
            System.out.println("Exception on getLast: " + e);
        }
    }
}

//-----------------------------------------------------------------------------------------------------------------

	// Write a program to implement the Queue using ArrayDeque

package collectionexamples;
import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Scanner;

public class QueueUsingArrayDequeWithSwitch {
    public static void main(String[] args) {
        Deque<Integer> queue = new ArrayDeque<>();
        Scanner scanner = new Scanner(System.in);
        boolean exit = false;

        while (!exit) {
            System.out.println("\nChoose an operation:");
            System.out.println("1: Enqueue");
            System.out.println("2: Dequeue");
            System.out.println("3: Peek");
            System.out.println("4: Check if empty");
            System.out.println("5: Get size");
            System.out.println("6: Exit");
            System.out.print("Enter your choice: ");
            int choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    System.out.print("Enter a number to enqueue: ");
                    int numberToEnqueue = scanner.nextInt();
                    queue.offer(numberToEnqueue);
                    System.out.println("Enqueued " + numberToEnqueue + " to the queue.");
                    System.out.println("Current queue: " + queue);
                    break;

                case 2:
                    if (queue.isEmpty()) {
                        System.out.println("Queue is empty. Cannot dequeue.");
                    } else {
                        int dequeuedNumber = queue.poll();
                        System.out.println("Dequeued " + dequeuedNumber + " from the queue.");
                        System.out.println("Current queue: " + queue);
                    }
                    break;

                case 3:
                    if (queue.isEmpty()) {
                        System.out.println("Queue is empty. Cannot peek.");
                    } else {
                        int frontNumber = queue.peek();
                        System.out.println("Front element is " + frontNumber);
                    }
                    break;

                case 4:
                    System.out.println("Is queue empty? " + queue.isEmpty());
                    break;

                case 5:
                    System.out.println("Size of the queue: " + queue.size());
                    break;

                case 6:
                    exit = true;
                    System.out.println("Exiting...");
                    break;

                default:
                    System.out.println("Invalid choice. Please try again.");
                    break;
            }
        }

        scanner.close();
    }
}

//-------------------------------

ArrayDeque<E> (Efficient Deque Implementation)
	- Implements Deque<E> (Double-Ended Queue) – Can be used as a stack or queue.
	- Faster than Stack and LinkedList in most cases.
	- No capacity restrictions – Grows dynamically as needed.
	- Does not allow null values.
	- Not thread-safe – Use ConcurrentLinkedDeque if needed.
	- Methods to remember:
		- addFirst(E e) / offerFirst(E e) → Inserts at the front.
		- addLast(E e) / offerLast(E e) → Inserts at the end.
		- removeFirst() / pollFirst() → Removes from the front.
		- removeLast() / pollLast() → Removes from the end.
		- getFirst() / peekFirst() → Retrieves front element without removal.
		- getLast() / peekLast() → Retrieves last element without removal.
	- Time Complexity:
		- Insertion & Deletion (both ends): O(1)
		- Accessing middle elements: O(n)

//--------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------
	
	Using java.uti.Set interface :
	----------------------------------

	The Set interface is part of the java.util package and extends the Collection interface. It represents a 
	collection of objects where each object is unique. In other words, a Set cannot contain duplicate values. 

	- A Set ensures that each element occurs only once. If you try to add a duplicate element, it won’t be added.
	- Unlike a List, a Set does not maintain any specific order for its elements. The order in which elements are 
	   stored is not guaranteed.
	- The Set interface follows the mathematical concept of a set. It provides methods to manipulate sets, such 
	   as union, intersection, and difference.
	
       some methods provided by the Set interface:

	 - add(element): Adds a specific element to the set. Returns true if the element was added successfully (i.e., it was not 
	   already present), otherwise returns false.
	 - addAll(collection): Appends all elements from the specified collection to the existing set.
	 - clear(): Removes all elements from the set (the set itself remains intact).
	 - contains(element): Checks whether a specific element is present in the set.
	 - containsAll(collection): Checks if the set contains all elements from the given collection.
	 - hashCode(): Returns the hash code value for the set.
	 - isEmpty(): Checks if the set is empty.
	 - iterator(): Returns an iterator to traverse the set (order is random).
	 - remove(element): Removes the specified element from the set.


///----------------------------------------------------

	java.util.SortedSet interface 
	----------------------------------

	The SortedSet interface, which is part of the java.util package, extends the Set interface. It provides 
	additional features related to sorting and ordering of elements. Here are the key points about the SortedSet:

	-  Unlike a regular Set, a SortedSet maintains its elements in a sorted order. The order can be natural (based 
	   on the elements’ natural ordering) or defined by a custom comparator.
	- Like other sets, a SortedSet does not allow duplicate elements.
	- The SortedSet interface also provides navigation methods, allowing you to find elements greater than or less 
	  than a given value.

	methods:

	 - Comparator<? super E> comparator(): Returns the comparator used to order the elements in this set, or null if 
	   this set uses the natural ordering of its elements.

	 - E first(): Returns the first (lowest) element currently in this set.

	 - SortedSet<E> headSet(E to Element): Returns a view of the portion of this set whose elements are strictly 
	   less than the specified element.

	 - E last(): Returns the last (highest) element currently in this set.

	 - SortedSet<E> subSet(E fromElement, E toElement): Returns a view of the portion of this set whose elements 
	   range from fromElement, inclusive, to toElement, exclusive.

	 - SortedSet<E> tailSet(E fromElement): Returns a view of the portion of this set whose elements are greater 
	   than or equal to fromElement.


//-----------------------------------------------------

	Using java.util.HashSet class
	------------------------------

	The HashSet class in Java is a member of the Java Collections Framework and it extends the AbstractSet class 
	and implements the Set interface. 

	- The elements in a HashSet are not ordered or sorted. There is no guarantee that the order will remain 
	  constant over time. 

	- HashSet does not allow duplicate values. It means you can only store a particular value once. If you try 
	  to add the same  value again, it will replace the old value. 

	- HashSet is non-synchronized. This means that it is not thread-safe and multiple threads can access it 
	  simultaneously. 

	- HashSet is implemented in terms of a hash table. It uses a mechanism called hashing to store the elements. 
	  HashSet internally uses HashMap to store the elements.

	- HashSet are not index based data structure, thet stores the elements according to their Hashcode value. 

	- Hashset can not store mutiple null value

	- HashSet can store hetrogeneous elements.

	- The initial default capacity of HashSet is 16, and the default load factor is 0.75.

	-  It offers constant-time performance for the basic operations (add, remove, contains, and size). 

	* What is hash table, hashing and Hashmap Hashcode, and hash function?
	* What is laod factor.
	* what is rehash.

	Here’s a breakdown of the terms related to hashing and hash-based data structures:

	1. Hash Table
	A hash table is a data structure that stores key-value pairs. It uses a hash function to compute an index 
	(or hash code) where the key-value pair is stored. The goal of a hash table is to allow fast retrieval, 
	insertion, and deletion of elements, typically in O(1) time complexity on average.

	2. Hashing
	Hashing is the process of converting an input (key) into a fixed-size integer (hash code) using a hash 
	function. This hash code determines where the data will be stored in a hash table. The efficiency of 
	hashing depends on a good hash function that minimizes collisions.

	3. HashMap (Java-specific)
	A HashMap in Java is a class in the java.util package that implements the Map interface using a hash table. 
	It allows storing key-value pairs and provides constant-time performance (on average) for basic operations 
	like put(), get(), and remove().

	Key Features of HashMap:
	- Uses hashing for fast lookups
	- Allows null keys and values
	- Not synchronized (not thread-safe)
	- Uses a dynamic array of linked lists or balanced trees for handling collisions

	4. HashCode
	A hash code is an integer value generated by a hash function from an object's data. In Java, every object 
	has a hashCode() method (defined in Object class) that returns a hash code. The hash code helps in placing 
	objects in a hash table.

	5. Hash Function
	A hash function is a function that takes an input (key) and produces a fixed-size integer output (hash code). 
	The goal of a good hash function is to distribute keys evenly across the hash table to minimize collisions.

	6. Load Factor
	The load factor is the measure of how full a hash table is before it resizes. It is calculated as:

			Number of elements in HashMap
	Load Factor =  ----------------------------------------
			Total capacity of HashMap
 
	- Default load factor in Java's HashMap is 0.75.
	- When the load factor exceeds the threshold (e.g., 75% full), rehashing occurs.

	7. Rehashing
	Rehashing is the process of increasing the size of the hash table and recalculating the hash codes of 
	existing keys to distribute them in the new table.

	- Java’s HashMap doubles its capacity when rehashing occurs.
	- Purpose: Reduces collisions and improves performance.

	//--------------------------------------------

	Step-by-Step Process of Data Insertion in a Hash Table

	A Hash Table stores key-value pairs using a hash function to compute an index in an array. Let’s go 
	through the insertion process step by step.

	- Step 1: Compute the Hash Code
	  Every object (key) has a unique hash code, which is an integer generated by the hashCode() function.

	- Step 2: Map Hash Code to an Index (Hash Function)
	  Since the array size is limited, the hash code must be converted into a valid index within the array 
	  using the formula:
			  
		Index = hashCode %(mod) arraySize
	
	- Step 3: Insert the Key-Value Pair at Computed Index
	  - If the computed index is empty, store the key-value pair directly.
	  - If the index already contains data, a collision occurs (explained in the next section).


		What is a Collision?

		A collision occurs when two different keys generate the same index after applying 
		the hash function.
		- Example:

			"Hello" produces index 0.
			"Data" produces the same index 0.

		 - If we insert "Data", it overwrites "Hello", which leads to data loss.
		 - To prevent this, we use collision resolution techniques.

		Collision Handling Techniques

		1️. Separate Chaining (Linked List)
		   - Instead of storing only one element at each index, store a linked list of key-value pairs.
		   - If multiple keys map to the same index, they are stored as a linked list at that index.

		2️. Open Addressing (Linear Probing)
		  - If a collision occurs, find the next available empty slot.
		  - Use a probing technique (Linear Probing, Quadratic Probing, or Double Hashing).

		    - Linear Probing: If index 0 is occupied, check index 1, then index 2, and so on.

		    - Double Hashing: Uses a secondary hash function if a collision occurs.
			New Index=(Original Index+i×Second Hash Function(key))modTable Size

		3. Quadratic Probing:
		   It is a collision resolution technique in open addressing where the next available slot is 
		   found using a quadratic function:

			New Index = (Original Index + i^2) mod Table Size

		  - Here, i is the attempt number (1, 2, 3, ...), reducing clustering compared to Linear Probing. 


	- Effect of Collisions on Performance:

	   - If too many collisions occur, the hash table becomes slower, reducing performance from O(1) 
	     to O(n) in the worst case.
	   - The load factor controls when rehashing occurs to maintain performance.

	HashSet Constructors:

	- HashSet(): Constructs a new, empty set; the backing HashMap instance has default initial capacity (16) and 
	  load factor (0.75).

	- HashSet(Collection<? extends E> c): Constructs a new set containing the elements in the specified collection.

	- HashSet(int initialCapacity): Constructs a new, empty set; the backing HashMap instance has the specified 
	  initial capacity and default load factor (0.75).

	- HashSet(int initialCapacity, float loadFactor): Constructs a new, empty set; the backing HashMap instance has 
	  the specified initial capacity and the specified load factor.

	HashSet Methods: 

	- boolean add(E e): Adds the specified element to this set if it is not already present.
	- void clear(): Removes all of the elements from this set.
	- Object clone(): Returns a shallow copy of this HashSet instance: the elements themselves are not cloned.
	- boolean contains(Object o): Returns true if this set contains the specified element.
	- boolean isEmpty(): Returns true if this set contains no elements.
	- Iterator<E> iterator(): Returns an iterator over the elements in this set.
	- boolean remove(Object o): Removes the specified element from this set if it is present.
	- int size(): Returns the number of elements in this set (its cardinality).
	- Spliterator<E> spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this set.




	// using all constructors

package collectionexamples;
import java.util.HashSet;
import java.util.Arrays;
import java.util.Collection;
public class HashSetExample {
    public static void main(String[] args) {
        // Using the no-argument constructor
        HashSet<String> set1 = new HashSet<>();
        set1.add("one");
        set1.add("two");
        set1.add("three");
        set1.add("one");
        System.out.println("Set1: " + set1);

        // Using the constructor that accepts a Collection
        Collection<String> collection = Arrays.asList("four", "five", "six");
	/*
		or you can create a list
		Collection<String> collection=new ArrayList<>();
		collection.add("four");
		collection.add("five",);
		collection.add("six");
		
	*/
        HashSet<String> set2 = new HashSet<>(collection);
        System.out.println("Set2: " + set2);

        // Using the constructor that accepts an initial capacity
        HashSet<String> set3 = new HashSet<>(10);
        set3.add("seven");
        set3.add("eight");
        System.out.println("Set3: " + set3);

        // Using the constructor that accepts an initial capacity and load factor
        HashSet<String> set4 = new HashSet<>(10, 0.5f);
        set4.add("nine");
        set4.add("ten");
        System.out.println("Set4: " + set4);
    }
}
	
//----------------------------------------------------------------------------------------------------------

	// Add Elements to HashSet

package collectionexamples;
import java.util.HashSet;

public class AddElementsInHashSet {
    public static void main(String[] args) {
        // Creating a HashSet
        HashSet<String> set = new HashSet<>();

        // Adding new elements to the HashSet
        set.add("Java");
        set.add("Python");
        set.add("JavaScript");
        set.add("Python");
        set.add("JavaScript");
        set.add("Python");

        // Displaying the HashSet elements
        for(String language : set){
            System.out.println(language);
        }
    }
}

//-------------------------------------------------------------------------------------

	// Create HashSet from Another Collection

package collectionexamples;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

public class HashSetFromCollections {
	public static void main(String[] args) {

		List<Integer> list = new ArrayList<>();
		list.add(5);
		list.add(10);
		list.add(15);
		list.add(20);
		list.add(25);

		List<Integer> list2 = new ArrayList<>();
		list2.add(3);
		list2.add(6);
		list2.add(9);
		list2.add(12);
		list2.add(15);

		// Creating a HashSet from another collection (ArrayList)
		Set<Integer> set = new HashSet<>(list);

		// Adding all the elements from an existing collection to a HashSet
		set.addAll(list2);

		System.out.println(set);
		// Accessing elements using an iterator
        	Iterator<Integer> iterator = set.iterator();
        	while(iterator.hasNext()){
            		Integer language = iterator.next();
            		System.out.println(language);
       	 	}
    	}
}

//-----------------------------------------------------------------------------------------

	// Remove elements

	We can remove elements from HashSet using these methods:
	- remove(Object o): This method is used to remove a single specified element from the set.
	- removeAll(Collection c): This method is used to remove all elements from the set that are contained in the 
	  specified collection.
	- removeIf(Predicate<? super E> filter): This method is used to remove all elements from the set that satisfy 
	  the given predicate.

package collectionexamples;
import java.util.HashSet;
import java.util.Arrays;

public class RemoveFromHashSet {
    public static void main(String[] args) {
        // Creating a HashSet
        HashSet<String> set = new HashSet<>();
        set.addAll(Arrays.asList("Apple", "Banana", "Cherry", "Date", "Elderberry"));

        System.out.println("Original HashSet: " + set);

        // Using remove(Object o)
        set.remove("Cherry");
        System.out.println("\nAfter remove('Cherry'): " + set);

        // Using removeAll(Collection c)
        set.removeAll(Arrays.asList("Apple", "Banana"));
        System.out.println("\nAfter removeAll(Arrays.asList('Apple', 'Banana')): " + set);

        // Using removeIf(Predicate<? super E> filter)
        set.removeIf(fruit -> fruit.startsWith("E"));
        System.out.println("\nAfter removeIf(fruit -> fruit.startsWith('E')): " + set);
    }
}


//-----------------------------------------------------------------------------------------

	// Using different iterators

package collectionexamples;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Consumer;

public class HashSetIterationExample {
    public static void main(String[] args) {
        // Create a HashSet of Integers
        HashSet<Integer> set = new HashSet<>();

        // Add elements to the HashSet
        set.add(1);
        set.add(2);
        set.add(3);
        set.add(4);
        set.add(5);

        // Using iterator()
        System.out.println("Using iterator():");
        Iterator<Integer> iterator = set.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }

        // Using spliterator()
        System.out.println("\nUsing spliterator():");
        Spliterator<Integer> spliterator = set.spliterator();
        spliterator.forEachRemaining((Integer i) -> System.out.println(i));

        // Using forEach()
        System.out.println("\nUsing forEach():");
        set.forEach((Integer i) -> System.out.println(i));
    }
}


//-----------------------------------------------------------------------------------------

	Using java.util.LinkedHashSet 
	------------------------------
	LinkedHashSet is a class that is part of the Java Collections Framework and is available in the java.util package. 
	It combines the characteristics of both a HashSet and a LinkedList. 

	LinkedHashSet is an extended version of HashSet. HashSet doesn’t follow any order where as LinkedHashSet 
	maintains insertion order. HashSet uses HashMap object internally to store it’s elements where as LinkedHashSet 
	uses LinkedHashMap object internally to store and process it’s elements. It uses a hash table (like HashSet) to 
	store the elements, and a linked list to maintain the order of insertion.

	Constructors:
	- LinkedHashSet(): Constructs a new, empty set; the backing HashMap instance has default initial capacity (16) and load 
	  factor (0.75).
	- LinkedHashSet(int initialCapacity): Constructs a new, empty set; the backing HashMap instance has the specified initial 
	  capacity and default load factor (0.75).
	- LinkedHashSet(int initialCapacity, float loadFactor): Constructs a new, empty set; the backing HashMap instance has the 
	  specified initial capacity and load factor.
	- LinkedHashSet(Collection<? extends E> c): Constructs a new set with the same elements as the specified collection. The 
	  backing HashMap is created with default load factor (0.75) and an initial capacity sufficient to contain the elements in 
	  the specified collection.

	Methods in LinkedHashSet

	- boolean add(E e): Adds the specified element to this set if it is not already present.

	- boolean remove(Object o): Removes the specified element from this set if it is present.
	- void clear(): Removes all of the elements from this set.

	- boolean contains(Object o): Returns true if this set contains the specified element.
	- Iterator<E> iterator(): Returns an iterator over the elements in this set in insertion order.
	- Spliterator<E> spliterator(): Creates a late-binding and fail-fast Spliterator over the elements in this set.

	- int size(): Returns the number of elements in this set.
	- boolean isEmpty(): Returns true if this set contains no elements.

	- Object clone(): Returns a shallow copy of this LinkedHashSet instance.
	- Object[] toArray(): Returns an array containing all of the elements in this set in proper sequence (insertion order).
	- <T> T[] toArray(T[] a): Returns an array containing all of the elements in this set in proper sequence (insertion order);
	  the runtime type of the returned array is that of the specified array.
	- boolean containsAll(Collection<?> c): Returns true if this set contains all of the elements in the specified collection.
	- boolean addAll(Collection<? extends E> c): Adds all of the elements in the specified collection to this set if they're 
	  not already present.
	- boolean retainAll(Collection<?> c): Retains only the elements in this set that are contained in the specified collection.
	- boolean removeAll(Collection<?> c): Removes from this set all of its elements that are contained in the 
	  specified collection.


import java.util.LinkedHashSet;

public class LinkedHashSetExample {
    public static void main(String[] args) {
        // Create a LinkedHashSet
        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();

        // Add elements to the LinkedHashSet
        linkedHashSet.add("One");
        linkedHashSet.add("Two");
        linkedHashSet.add("Three");
        linkedHashSet.add("Four");
        linkedHashSet.add("Five");

        // Attempting to add duplicate elements
        linkedHashSet.add("Three");
        linkedHashSet.add("Four");

        // Displaying the LinkedHashSet
        System.out.println(linkedHashSet);

        // Removing an element
        linkedHashSet.remove("Two");

        // Displaying after removal
        System.out.println(linkedHashSet);

        // Iterating over the LinkedHashSet
        for (String element : linkedHashSet) {
            System.out.println(element);
        }
    }
}

//-------------------

	Difference Between HashSet and LinkedHashSet in Java

	Ordering:
	- HashSet does not maintain insertion order.
	- LinkedHashSet maintains insertion order (elements are returned in the order they were added).

	Implementation:
	- HashSet uses a hash table for storing elements.
	- LinkedHashSet uses a hash table + doubly linked list to maintain insertion order.

	Performance:
	- HashSet is faster for insertions, deletions, and lookups (O(1) time complexity on average).
	- LinkedHashSet is slightly slower due to maintaining a linked list for ordering.

	Memory Usage:
	- HashSet uses less memory as it only stores hash table entries.
	- LinkedHashSet uses more memory due to the extra linked list structure.

	Use Case:
	- Use HashSet when ordering is not important, and you need better performance.
	- Use LinkedHashSet when you need to maintain the insertion order of elements.

///-----------------------------------------------------------------------------------------

 Using java.util.TreeSet:
 -------------------------- 

	The TreeSet class in Java is a part of the Java Collections Framework and implements the NavigableSet interface. 
	It represents a set that is sorted according to the natural ordering of its elements or by a custom Comparator 
	provided at the time of construction. TreeSet, which uses a self-balancing binary search tree to maintain the 
	sorted order. It is not an index based data struction, and not follow insertation order but follows sorting order. It is collection of 
	homogeneous data elements. no duplication allowed. non-synchronized, no null allowed

     - Constructors
	- TreeSet(): Constructs a new, empty tree set, sorted according to the natural ordering of its elements.
	- TreeSet(Collection<? extends E> c): Constructs a new tree set containing the elements in the specified collection, sorted 
	   according to the natural ordering of its elements.
	- TreeSet(Comparator<? super E> comparator): Constructsa new, empty tree set, sorted according to the specified comparator.
	- TreeSet(SortedSet<E> s): Constructs a new tree set containing the same elements and using the same ordering as the 
	  specified sorted set.

import java.util.*;

public class TreeSetConstructorsExample {
    public static void main(String[] args) {
        // Using the default constructor
        TreeSet<Integer> treeSet1 = new TreeSet<>();
        treeSet1.add(3);
        treeSet1.add(1);
        treeSet1.add(2);
        System.out.println("TreeSet created with default constructor: " + treeSet1);

        // Using the constructor with a collection parameter
        List<Integer> list = Arrays.asList(7, 5, 6);
        TreeSet<Integer> treeSet2 = new TreeSet<>(list);
        System.out.println("TreeSet created with collection constructor: " + treeSet2);

        // Using the constructor with a comparator parameter
        TreeSet<String> treeSet3 = new TreeSet<>(Comparator.reverseOrder());
        treeSet3.add("banana");
        treeSet3.add("apple");
        treeSet3.add("cherry");
        System.out.println("TreeSet created with comparator constructor: " + treeSet3);

    }
}

//---------------------------------

	// Element insert

add() - inserts the specified element to the set
addAll() - inserts all the elements of the specified collection to the set

package collectionexamples;
import java.util.TreeSet;

class TreeSetAddExample {
    public static void main(String[] args) {

        TreeSet<Integer> evenNumbers = new TreeSet<>();

        // Using the add() method
        evenNumbers.add(2);
        evenNumbers.add(4);
        evenNumbers.add(6);
        System.out.println("TreeSet: " + evenNumbers);

        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(1);

        // Using the addAll() method
        numbers.addAll(evenNumbers);
        System.out.println("New TreeSet: " + numbers);
    }
}

//-----------------------------------------------------------------------------------------

	// using iterator

package collectionexamples;

import java.util.Iterator;
import java.util.TreeSet;

public class TreeSetElementAccessExample {
	 public static void main(String[] args) {
	        TreeSet<Integer> numbers = new TreeSet<>();
	        numbers.add(2);
	        numbers.add(5);
	        numbers.add(6);
	        System.out.println("TreeSet: " + numbers);

	        // Calling iterator() method
	        Iterator<Integer> iterate = numbers.iterator();
	        System.out.print("TreeSet using Iterator: ");
	        // Accessing elements
	        while(iterate.hasNext()) {
	            System.out.print(iterate.next());
	            System.out.print(", ");
	        }
	    }
}


//-----------------------------------------------------------------------------------------

	// Remove Elements
remove() - removes the specified element from the set
removeAll() - removes all the elements from the set

package collectionexamples;

import java.util.TreeSet;

public class TreeSetRemoveElements {

	public static void main(String[] args) {
		TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(2);
        numbers.add(5);
        numbers.add(6);
        System.out.println("TreeSet: " + numbers);

        // Using the remove() method
        boolean value1 = numbers.remove(5);
        System.out.println("Is 5 removed? " + value1);

        // Using the removeAll() method
        boolean value2 = numbers.removeAll(numbers);
        System.out.println("Are all elements removed? " + value2);

	}

}

//-----------------------------------------------------------------------------------------

	// first() and last() Methods
first() - returns the first element of the set
last() - returns the last element of the set


package collectionexamples;

import java.util.TreeSet;

public class TreeSetFirstLast {
	 public static void main(String[] args) {
	        TreeSet<Integer> numbers = new TreeSet<>();
	        numbers.add(2);
	        numbers.add(5);
	        numbers.add(6);
	        System.out.println("TreeSet: " + numbers);

	        // Using the first() method
	        int first = numbers.first();
	        System.out.println("First Number: " + first);

	        // Using the last() method
	        int last = numbers.last();
	        System.out.println("Last Number: " + last);
	 }
}



//-----------------------------------------------------------------------------------------
	// ceiling(), floor(), higher() and lower() Methods
higher(element) - Returns the lowest element among those elements that are greater than the specified element.

lower(element) - Returns the greatest element among those elements that are less than the specified element.

ceiling(element) - Returns the lowest element among those elements that are greater than the specified element. 
		   If the element passed exists in a tree set, it returns the element passed as an argument.

floor(element) - Returns the greatest element among those elements that are less than the specified element. 
		 If the element passed exists in a tree set, it returns the element passed as an argument.

package collectionexamples;
import java.util.TreeSet;
public class TreeSetCeil {
	 public static void main(String[] args) {
	        TreeSet<Integer> numbers = new TreeSet<>();
	        numbers.add(2);
	        numbers.add(5);
	        numbers.add(4);
	        numbers.add(6);
	        System.out.println("TreeSet: " + numbers);

	        // Using higher()
	        System.out.println("Using higher: " + numbers.higher(4));

	        // Using lower()
	        System.out.println("Using lower: " + numbers.lower(4));

	        // Using ceiling()
	        System.out.println("Using ceiling: " + numbers.ceiling(4));

	        // Using floor()
	        System.out.println("Using floor: " + numbers.floor(3));

	    }
}

//-----------------------------------------------------------------------------------------
	//  pollfirst() and pollLast() Methods

pollFirst() - returns and removes the first element from the set
pollLast() - returns and removes the last element from the set

import java.util.TreeSet;

class TreeSetPoll{
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        numbers.add(2);
        numbers.add(5);
        numbers.add(4);
        numbers.add(6);
        System.out.println("TreeSet: " + numbers);

        // Using pollFirst()
        System.out.println("Removed First Element: " + numbers.pollFirst());

        // Using pollLast()
        System.out.println("Removed Last Element: " + numbers.pollLast());

        System.out.println("New TreeSet: " + numbers);
    }
}

//-----------------------------------------------------------------------------------------

	- The headSet() method returns all the elements of a tree set before the specified element (which is passed as an argument).
	- The tailSet() method returns all the elements of a tree set after the specified element (which is passed as a parameter) 
	  including the specified element.
	- The subSet() method returns all the elements between e1 and e2 including e1.

import java.util.TreeSet;

public class TreeSetMethodsDemo {
    public static void main(String[] args) {
        // Creating a TreeSet
        TreeSet<Integer> treeSet = new TreeSet<>();

        // Adding elements to the TreeSet
        treeSet.add(10);
        treeSet.add(20);
        treeSet.add(30);
        treeSet.add(40);
        treeSet.add(50);
        treeSet.add(60);
        treeSet.add(70);

        // Displaying the original TreeSet
        System.out.println("Original TreeSet: " + treeSet);

        // Demonstrating headSet() method
        TreeSet<Integer> headSet = (TreeSet<Integer>) treeSet.headSet(40);
        System.out.println("headSet(40): " + headSet);

        // Demonstrating tailSet() method
        TreeSet<Integer> tailSet = (TreeSet<Integer>) treeSet.tailSet(40);
        System.out.println("tailSet(40): " + tailSet);

        // Demonstrating subSet() method
        TreeSet<Integer> subSet = (TreeSet<Integer>) treeSet.subSet(20, 50);
        System.out.println("subSet(20, 50): " + subSet);
    }
}

//-----------------------------------------------------------------------------------------

	// Java program demonstrating the subset, difference, intersection, and union operations on TreeSet in Java.

import java.util.*;

public class TreeSetOperationsDemo {
    public static void main(String[] args) {
        // Creating TreeSets
        TreeSet<Integer> set1 = new TreeSet<>();
        TreeSet<Integer> set2 = new TreeSet<>();

        // Adding elements to the first set
        set1.addAll(Arrays.asList(1, 2, 3, 4, 5));

        // Adding elements to the second set
        set2.addAll(Arrays.asList(4, 5, 6, 7, 8));

        // Displaying the original sets
        System.out.println("Set 1: " + set1);
        System.out.println("Set 2: " + set2);

        // Union operation
        TreeSet<Integer> union = new TreeSet<>(set1);
        union.addAll(set2);
        System.out.println("Union of set1 and set2: " + union);

        // Subset operation
        TreeSet<Integer> subset = new TreeSet<>(set1);
        subset.retainAll(set2);
        System.out.println("Subset of set1 and set2: " + subset);

        // Difference operation (set1 - set2)
        TreeSet<Integer> difference1 = new TreeSet<>(set1);
        difference1.removeAll(set2);
        System.out.println("Difference of set1 and set2: " + difference1);

        // Difference operation (set2 - set1)
        TreeSet<Integer> difference2 = new TreeSet<>(set2);
        difference2.removeAll(set1);
        System.out.println("Difference of set2 and set1: " + difference2);

        // Intersection operation
        TreeSet<Integer> intersection = new TreeSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Intersection of set1 and set2: " + intersection);
    }
}

//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------

 Map interface in java
 ========================

	The Map interface in the java.util package is a part of Java's Collections Framework. It represents a collection that maps
 	keys to values, where each key is unique. This interface provides methods to perform basic operations like insertion,
	deletion, and retrieval of elements based on keys. 


	- Each element in a Map is a pair consisting of a key and a value. A key is used to uniquely identify the value in the Map.

	- A Map cannot contain duplicate keys. Each key can map to at most one value.

	- Depending on the implementation, a Map can contain null keys and values. For instance, HashMap allows one null key 
	  and multiple null values, whereas TreeMap does not allow null keys (because it sorts the keys and null cannot be compared).


	Map Implementations: 
	
	- HashMap: Uses a hash table to store the map. It allows null keys and values and does not maintain any order 
	  of the elements.

	- LinkedHashMap: Extends HashMap to maintain a doubly-linked list of the entries, preserving the insertion order.

	- TreeMap: Implements a map using a red-black tree, ensuring that the keys are sorted according to their natural order 
	  or by a comparator provided at map creation time.
	
	- Hashtable: Similar to HashMap but synchronized and does not allow null keys or values.


	Methods in Map Interface

	- put(K key, V value): Associates the specified value with the specified key in the map.
	- get(Object key): Returns the value to which the specified key is mapped, or null if the map contains 
	  no mapping for the key.
	- remove(Object key): Removes the mapping for a key from this map if it is present.
	- clear(): Removes all of the mappings from this map.
	- size(): Returns the number of key-value mappings in this map.
	- isEmpty(): Returns true if this map contains no key-value mappings.

	- putAll(Map<? extends K, ? extends V> m): Copies all of the mappings from the specified map to this map.
	- containsKey(Object key): Returns true if this map contains a mapping for the specified key.
	- containsValue(Object value): Returns true if this map maps one or more keys to the specified value.

	- keySet(): Returns a Set view of the keys contained in this map.
	- values(): Returns a Collection view of the values contained in this map.
	- entrySet(): Returns a Set view of the mappings contained in this map. Each element in the returned set 
	  is a Map.Entry<K, V>.



//---------------------------------------------------------------------------------------------------------------------

	Using java.util.HashMap class
	=============================

	The HashMap class in Java is part of the Java Collections Framework and implements the Map interface. 
	It provides the basic implementation of the Map interface of Java and is used to store data in the 
	form of key-value pairs, which are known as entries. HashMap uses a technique called Hashing, which 
	allows us to access elements directly by calculating a unique key from their content. This unique key 
	is the index at which the specific value is stored, making retrieval efficient.

	- HashMap belongs to the java.util package and implements the Map interface.
	- It stores data in key-value pairs.
	- Unlike arrays where you access data using numerical indexes, you access data in HashMap using unique keys.
	- Keys can be any object (including String, Integer, or custom classes) as long as they implement the 
	  equals() and hashCode() methods properly. These methods are crucial for determining if two keys are 
	  equivalent and for efficient storage within the HashMap.

	- Uses the Hash table as a underlaying data structure.

	- HashMap allows for one null key but any number of null values.

	- Does not guarantee the order of iteration.

	- Constant time complexity (O(1)) for basic operations (add, remove, contains) assuming a good hash function.

	- Not thread-safe by default. Use Collections.synchronizedMap for synchronized version.

	Constructors: 
	
	- HashMap(): Creates an empty HashMap with the default initial capacity (16) and load factor (0.75).
	- HashMap(int initialCapacity): Creates an empty HashMap with the specified initial capacity and the 
	  default load factor (0.75).
	- HashMap(int initialCapacity, float loadFactor): Creates an empty HashMap with the specified initial capacity 
	  and load factor.
	- HashMap(Map<? extends K, ? extends V> m): Creates a HashMap with the same mappings as the specified Map. 
	  The HashMap is created with an initial capacity sufficient to hold the mappings in the specified map.

	Methods
	- put(K key, V value): Adds a key-value pair to the map.
	- get(Object key): Returns the value associated with the specified key.
	- remove(Object key): Removes the key-value pair for the specified key.
	- containsKey(Object key): Checks if the map contains the specified key.
	- containsValue(Object value): Checks if the map contains the specified value.
	- size(): Returns the number of key-value pairs in the map.
	- isEmpty(): Checks if the map is empty.
	- clear(): Removes all key-value pairs from the map.


 // Using Constructors


import java.util.HashMap;
import java.util.Map;

public class HashMapConstructorsExample {
    public static void main(String[] args) {
        // Using the default constructor
        HashMap<String, Integer> defaultMap = new HashMap<>();
        defaultMap.put("Key1", 100);
        defaultMap.put("Key2", 200);
        System.out.println("Default constructor: " + defaultMap);

        // Using the constructor with initial capacity
        HashMap<String, Integer> capacityMap = new HashMap<>(10);
        capacityMap.put("Key2", 2);
        capacityMap.put("Key3", 300);
        System.out.println("Constructor with initial capacity: " + capacityMap);

        // Using the constructor with initial capacity and load factor
        HashMap<String, Integer> capacityLoadFactorMap = new HashMap<>(10, 0.7f);
        capacityLoadFactorMap.put("Key4", 400);
        System.out.println("Constructor with initial capacity and load factor: " + capacityLoadFactorMap);

        // Using the copy constructor
        Map<String, Integer> existingMap = new HashMap<>();
        existingMap.put("KeyA", 100);
        existingMap.put("KeyB", 200);

        HashMap<String, Integer> copyMap = new HashMap<>(existingMap);
        System.out.println("Copy constructor: " + copyMap);
    }
}

//-----------------------------------------------------------------

	// Accessing methods from HashMap

import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        // Creating a HashMap
        HashMap<String, Integer> map = new HashMap<>();

        // Adding elements to the HashMap
        map.put("Apple", 10);
        map.put("Banana", 15);
        map.put("Orange", 20);

        // Accessing elements
        System.out.println("Value for key 'Apple': " + map.get("Apple"));

        // Removing an element
        map.remove("Banana");

		int []x = {11,22,33,44,55}
		for(int elm : x)
		{
			System.out.print(elm);
		}

        // Iterating over elements
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }

        // Checking if a key exists
        System.out.println("Does key 'Orange' exist? " + map.containsKey("Orange"));

        // Checking if a value exists
        System.out.println("Does value 20 exist? " + map.containsValue(20));

        // Getting the size of the HashMap
        System.out.println("Size of the map: " + map.size());

        // Clearing the HashMap
        map.clear();
        System.out.println("Is the map empty? " + map.isEmpty());
    }
}


//-------------------------------------------------------------------------------------------

	// Different ways of Iterations

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class HashMapIterating {
    public static void main(String[] args) {
        // Creating a HashMap
        HashMap<String, String> map = new HashMap<>();
        map.put("Apple", "Red");
        map.put("Orange", "Orange");
        map.put("Banana", "Yellow");

        // Using `entrySet` and a `for-each` loop:
        System.out.println("Using `entrySet` and a `for-each` loop:");
        for (Map.Entry<String, String> entry : map.entrySet()) {
            System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
        }
        System.out.println();

        // Using `keySet` and a `for-each` loop:
        System.out.println("Using `keySet` and a `for-each` loop:");
        for (String key : map.keySet()) {
            System.out.println("Key = " + key + ", Value = " + map.get(key));
        }
        System.out.println();

        // Using `values` and a `for-each` loop:
        System.out.println("Using `values` and a `for-each` loop:");
        for (String value : map.values()) {
            System.out.println("Value = " + value);
        }
        System.out.println();

        // Using an `Iterator`:
        System.out.println("Using an `Iterator`:");
        Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<String, String> entry = iterator.next();
            System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
        }
        System.out.println();

        // Using Java 8's `forEach` method:
        System.out.println("Using Java 8's `forEach` method:");
        map.forEach((key, value) -> System.out.println("Key = " + key + ", Value = " + value));
    }
}


//----------------------------------------------------------------------------------------------------------

  Using java.util.LinkedHashMap class
  ====================================

	LinkedHashMap is a subclass of HashMap in Java, and it maintains a doubly-linked list running through all 
	of its entries. This linked list defines the iteration ordering, which can be either the order in which keys 
	were inserted (insertion-order) or the order in which keys were accessed (access-order).

	- A LinkedHashMap contains values based on the key.
	- It contains only unique elements.
	- It may have one null key and multiple null values.
	- It is the same as HashMap instead maintains insertion order.
	- Unlike HashMap, the iteration order of the elements in a LinkedHashMap is predictable.
	- Just like HashMap, LinkedHashMap is not thread-safe. You must explicitly synchronize concurrent access to a 
	  LinkedHashMap in a multi-threaded environment.

	Constructors: 

	- LinkedHashMap():Creates an empty LinkedHashMap with the default initial capacity (16) and load factor (0.75).
	- LinkedHashMap(int initialCapacity): Creates an empty LinkedHashMap with the specified initial capacity and default 
	  load factor (0.75).
	- LinkedHashMap(int initialCapacity, float loadFactor): Creates an empty LinkedHashMap with the specified initial 
	  capacity and load factor.
	- LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder): Creates an empty LinkedHashMap with the 
	  specified initial capacity, load factor, and ordering mode (access-order if true).
	- LinkedHashMap(Map<? extends K, ? extends V> m): Creates a LinkedHashMap with the same mappings as the specified Map. 
	  The LinkedHashMap is created with an initial capacity sufficient to hold the mappings in the specified map.


	Methods
	- put(K key, V value): Associates the specified value with the specified key in this map.
	- get(Object key): Returns the value to which the specified key is mapped, or null if this map contains 
	  no mapping for the key.
	- remove(Object key): Removes the mapping for the specified key from this map if present.
	- containsKey(Object key): Returns true if this map contains a mapping for the specified key.
	- containsValue(Object value): Returns true if this map maps one or more keys to the specified value.
	- size(): Returns the number of key-value mappings in this map.
	- isEmpty(): Returns true if this map contains no key-value mappings.
	- clear(): Removes all of the mappings from this map.
	- putAll(Map<? extends K, ? extends V> m): Copies all of the mappings from the specified map to this map.

	- keySet(): Returns a Set view of the keys contained in this map.
	- values(): Returns a Collection view of the values contained in this map.
	- entrySet(): Returns a Set view of the mappings contained in this map.

	- forEach(BiConsumer<? super K, ? super V> action): Performs the given action for each entry in this map until all 
	  entries have been processed or the action throws an exception.
	- replaceAll(BiFunction<? super K, ? super V, ? extends V> function): Replaces each entry’s value with the result of 
	  applying the given function to that entry.

	- putIfAbsent(K key, V value): If the specified key is not already associated with a value (or is mapped to null), 
	  associates it with the given value and returns null, else returns the current value.
	- remove(Object key, Object value): Removes the entry for the specified key only if it is currently mapped to the 
	  specified value.
	- replace(K key, V oldValue, V newValue): Replaces the entry for the specified key only if currently mapped to the 
	  specified value.
	- replace(K key, V value): Replaces the entry for the specified key only if it is currently mapped to some value.
	- computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction): If the specified key is not already associated
	  with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into 
	  this map unless null.
	- computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction): If the value for the specified 
	  key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.
	- compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction): Attempts to compute a mapping for the 
	  specified key and its current mapped value (or null if there is no current mapping).
	- merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction): If the specified key is not 
	  already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, 
	  replaces the value with the results of the given remapping function.



import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapConstructorsDemo {

    public static void main(String[] args) {
        // 1. Default constructor
        LinkedHashMap<String, Integer> defaultMap = new LinkedHashMap<>();
        defaultMap.put("One", 1);
        defaultMap.put("Two", 2);
        System.out.println("Default constructor: " + defaultMap);

        // 2. Constructor with initial capacity
        LinkedHashMap<String, Integer> initialCapacityMap = new LinkedHashMap<>(10);
        initialCapacityMap.put("Three", 3);
        initialCapacityMap.put("Four", 4);
        System.out.println("Constructor with initial capacity: " + initialCapacityMap);

        // 3. Constructor with initial capacity and load factor
        LinkedHashMap<String, Integer> capacityAndLoadFactorMap = new LinkedHashMap<>(10, 0.75f);
        capacityAndLoadFactorMap.put("Five", 5);
        capacityAndLoadFactorMap.put("Six", 6);
        System.out.println("Constructor with initial capacity and load factor: " + capacityAndLoadFactorMap);

        // 4. Constructor with initial capacity, load factor, and access order
        LinkedHashMap<String, Integer> accessOrderMap = new LinkedHashMap<>(10, 0.75f, true);
        accessOrderMap.put("Seven", 7);
        accessOrderMap.put("Eight", 8);
        // Accessing one of the elements to change order if accessOrder is true
        accessOrderMap.get("Seven");
        System.out.println("Constructor with initial capacity, load factor, and access order: " + accessOrderMap);

        // 5. Copy constructor
        Map<String, Integer> existingMap = new LinkedHashMap<>();
        existingMap.put("Nine", 9);
        existingMap.put("Ten", 10);
        LinkedHashMap<String, Integer> copyMap = new LinkedHashMap<>(existingMap);
        System.out.println("Copy constructor: " + copyMap);
    }
}

//------------------------------------------------

	// Using some methods 

import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample {

    public static void main(String[] args) {
        // Initialize the LinkedHashMap
        LinkedHashMap<String, Integer> dayNumberMapping = new LinkedHashMap<>();

        // Adding new key-value pairs to the LinkedHashMap
        dayNumberMapping.put("Mon", 1);
        dayNumberMapping.put("Tus", 2);
        dayNumberMapping.put("Wen", 3);
        dayNumberMapping.put("Thu", 4);
        dayNumberMapping.put("Fri", 5);
        dayNumberMapping.put("Sat", 6);

        // Display the map
        System.out.println("Initial map: " + dayNumberMapping);

        // Access an element
        System.out.println("Value for key 'Thu': " + dayNumberMapping.get("Thu"));

        // Remove an element
        dayNumberMapping.remove("Wen");
        System.out.println("After removing key 'Wen': " + dayNumberMapping);

        // Check for key and value
        System.out.println("Contains key 'Fri'? " + dayNumberMapping.containsKey("Fri"));
        System.out.println("Contains value 5? " + dayNumberMapping.containsValue(5));

        // Iterate over the map using forEach
        dayNumberMapping.forEach((key, value) -> System.out.println(key + ": " + value));

        // Using entrySet to iterate over the map
        for (Map.Entry<String, Integer> entry : dayNumberMapping.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }

        // Use putIfAbsent
        dayNumberMapping.putIfAbsent("Sun", 7);
        System.out.println("After putIfAbsent 'Sun': " + dayNumberMapping);

        // Replace an entry
        dayNumberMapping.replace("Sun", 0);
        System.out.println("After replace 'Sun' with 0: " + dayNumberMapping);

        // Compute a value if absent
        dayNumberMapping.computeIfAbsent("Wen", k -> 3);
        System.out.println("After computeIfAbsent 'Wen': " + dayNumberMapping);

        // Clear the map
        dayNumberMapping.clear();
        System.out.println("After clear: " + dayNumberMapping.isEmpty());
    }
}


//---------------------------------------------------------------------------------------------------------------------

  Using java.util.HashTable class
  ====================================

	The Hashtable class is a part of the java.util package and is a legacy class that was part of the 
	original version of Java. It provides thread-safe operations on key-value pairs.In general, it’s 
	recommended to use the Map interface or one of its implementations (such as HashMap or ConcurrentHashMap) 
	instead of the Hashtable class.
	Similar to HashMap but thread-safe (synchronized). Slower due to synchronization.

	Constructor 
	- Hashtable(): Constructs a new, empty hashtable with a default initial capacity (11) and load factor (0.75).
	- Hashtable(int initialCapacity): Constructs a new, empty hashtable with the specified initial capacity 
	  and default load factor (0.75).
	- Hashtable(int initialCapacity, float loadFactor): Constructs a new, empty hashtable with the specified initial capacity 
	  and the specified load factor.
	- Hashtable(Map<? extends K,? extends V> t): Constructs a new hashtable with the same mappings as the given Map.

	Methods

	- put(K key, V value): Maps the specified key to the specified value in this hashtable.
	- get(Object key): Returns the value to which the specified key is mapped, or null if this map contains no mapping for 
	  the key.
	- remove(Object key): Removes the key (and its corresponding value) from this hashtable.
	- containsKey(Object key): Tests if the specified object is a key in this hashtable.
	- contains(Object value): Tests if some key maps into the specified value in this hashtable.
	- containsValue(Object value): Returns true if this hashtable maps one or more keys to this value.
	- size(): Returns the number of keys in this hashtable.
	- isEmpty(): Tests if this hashtable maps no keys to values.
	- clear(): Clears this hashtable so that it contains no keys.
	- putAll(Map<? extends K, ? extends V> t): Copies all of the mappings from the specified map to this hashtable.

	- keys(): Returns an enumeration of the keys in this hashtable.
	- elements(): Returns an enumeration of the values in this hashtable.
	- entrySet(): Returns a Set view of the mappings contained in this map.
	- keySet(): Returns a Set view of the keys contained in this map.
	- values(): Returns a Collection view of the values contained in this map.

	- putIfAbsent(K key, V value): If the specified key is not already associated with a value (or is mapped to null), 
	  associates it with the given value and returns null, else returns the current value.
	- remove(Object key, Object value): Removes the entry for the specified key only if it is currently mapped to the 
	  specified value.
	- replace(K key, V oldValue, V newValue): Replaces the entry for the specified key only if currently mapped to the 
	  specified value.
	- replace(K key, V value): Replaces the entry for the specified key only if it is currently mapped to some value.

	- compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction): Attempts to compute a mapping for 
	  the specified key and its current mapped value (or null if there is no current mapping).
	- computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction): If the specified key is not already associated 
	  with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into 
	  this map unless null.
	- computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction): If the value for the specified 
	  key is present and non-null, attempts to compute a new mapping given the key and its current mapped value.
	- merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction): If the specified key is not 
	  already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, 
	  replaces the value with the results of the given remapping function.

	- clone(): Creates a shallow copy of this hashtable.
	- toString(): Returns a string representation of this hashtable.
	- equals(Object o): Compares the specified object with this map for equality.
	- hashCode(): Returns the hash code value for this map.


import java.util.Hashtable;

public class HashtableConstructorsDemo {

    public static void main(String[] args) {
        // Default constructor
        Hashtable<String, Integer> defaultHashtable = new Hashtable<>();
        defaultHashtable.put("One", 1);
        defaultHashtable.put("Two", 2);
        System.out.println("Default constructor: " + defaultHashtable);

        // Constructor with initial capacity
        Hashtable<String, Integer> initialCapacityHashtable = new Hashtable<>(20);
        initialCapacityHashtable.put("Three", 3);
        initialCapacityHashtable.put("Four", 4);
        System.out.println("Constructor with initial capacity: " + initialCapacityHashtable);

        // Clone constructor
        Hashtable<String, Integer> cloneHashtable = new Hashtable<>(initialCapacityHashtable);
        System.out.println("Clone constructor: " + cloneHashtable);
    }
}

//----------------------------------------------------------------------------

import java.util.Map;

public class HashtableExample {

    public static void main(String[] args) {
        // Initialize the Hashtable
        Hashtable<String, Integer> hashtable = new Hashtable<>();

        // Adding new key-value pairs to the Hashtable
        hashtable.put("One", 1);
        hashtable.put("Two", 2);
        hashtable.put("Three", 3);

        // Display the map
        System.out.println("Initial hashtable: " + hashtable);

        // Access an element
        System.out.println("Value for key 'Two': " + hashtable.get("Two"));

        // Remove an element
        hashtable.remove("Two");
        System.out.println("After removing key 'Two': " + hashtable);

        // Check for key and value
        System.out.println("Contains key 'Three'? " + hashtable.containsKey("Three"));
        System.out.println("Contains value 3? " + hashtable.contains(3));

        // Iterate over the map using entrySet
        for (Map.Entry<String, Integer> entry : hashtable.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }

        // Use putIfAbsent
        hashtable.putIfAbsent("Four", 4);
        System.out.println("After putIfAbsent 'Four': " + hashtable);

        // Replace an entry
        hashtable.replace("Four", 40);
        System.out.println("After replace 'Four' with 40: " + hashtable);

        // Compute a value if absent
        hashtable.computeIfAbsent("Five", k -> 5);
        System.out.println("After computeIfAbsent 'Five': " + hashtable);

        // Clear the map
        hashtable.clear();
        System.out.println("After clear: " + hashtable.isEmpty());
    }

//-------------------------------------------------------------------------------------------------

  Using java.util.TreeMap class
  ====================================

	TreeMap is a part of the Java Collections Framework and is an implementation of the Map interface. It provides an efficient 
	means of storing key-value pairs in sorted order based on the keys' natural ordering or a custom Comparator provided at 
	TreeMap creation time. TreeMap is based on a Red-Black Tree data structure, which ensures that the keys are always sorted.
	
	- TreeMap maintains the elements in sorted order, either based on their natural ordering or a custom Comparator.
	- Unlike HashMap, TreeMap does not allow duplicate keys; attempting to insert a duplicate key will replace the existing 
	  value associated with the key.
	- TreeMap provides efficient implementations of operations such as finding the smallest and largest keys, finding 
	  key-value pairs in a given range, and more.

	Constructor
	- TreeMap(): Constructs a new, empty tree map, using the natural ordering of its keys.
	- TreeMap(Comparator<? super K> comparator): Constructs a new, empty tree map, ordered according to the given comparator.
	- TreeMap(Map<? extends K,? extends V> m): Constructs a new tree map containing the same mappings as the given map, ordered 
	  according to the natural ordering of its keys.
	- TreeMap(SortedMap<K,? extends V> m): Constructs a new tree map containing the same mappings and using the same ordering 
	  as the specified sorted map.

	 Methods:
	- put(K key, V value): Associates the specified value with the specified key in this map.
	- get(Object key): Returns the value to which the specified key is mapped, or null if this map contains no mapping 
	  for the key.
	- remove(Object key): Removes the mapping for the specified key from this map if present.
	- containsKey(Object key): Returns true if this map contains a mapping for the specified key.
	- containsValue(Object value): Returns true if this map maps one or more keys to the specified value.
	- size(): Returns the number of key-value mappings in this map.
	- isEmpty(): Returns true if this map contains no key-value mappings.
	- clear(): Removes all of the mappings from this map.
	- keySet(): Returns a Set view of the keys contained in this map.
	- values(): Returns a Collection view of the values contained in this map.
	- entrySet(): Returns a Set view of the mappings contained in this map.
	- firstKey(): Returns the first (lowest) key currently in this map.
	- lastKey(): Returns the last (highest) key currently in this map.
	- higherKey(K key): Returns the least key strictly greater than the given key, or null if there is no such key.
	- lowerKey(K key): Returns the greatest key strictly less than the given key, or null if there is no such key.

import java.util.*;

public class TreeMapExample {

    public static void main(String[] args) {
        // Create a TreeMap
        TreeMap<Integer, String> treeMap = new TreeMap<>();

        // Add elements
        treeMap.put(3, "Three");
        treeMap.put(1, "One");
        treeMap.put(2, "Two");

        // Display the TreeMap
        System.out.println("TreeMap: " + treeMap);

        // Get value for a key
        System.out.println("Value for key 2: " + treeMap.get(2));

        // Remove an entry
        treeMap.remove(3);
        System.out.println("After removing key 3: " + treeMap);

        // Check if a key exists
        System.out.println("Contains key 3? " + treeMap.containsKey(3));

        // Iterate over entries
        for (Map.Entry<Integer, String> entry : treeMap.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }
    }
}

//-------------------------------------------------------------------------------------------------

	Key Differences Between Hashtable, HashMap, and LinkedHashMap in Java

	Thread Safety
	- Hashtable is synchronized (safe for multi-threading but slower).
	- HashMap and LinkedHashMap are not synchronized (faster but not thread-safe).
	- For thread safety in HashMap, use Collections.synchronizedMap(new HashMap<>()).

	Performance
	- HashMap and LinkedHashMap are faster than Hashtable because they do not have synchronization overhead.
	
	Insertion Order Maintenance
	- HashMap and Hashtable do not maintain any order of elements.
	- LinkedHashMap maintains insertion order of elements.

	Allows null Keys/Values
	- Hashtable does not allow null keys or values.
	- HashMap and LinkedHashMap allow one null key and multiple null values.


//=================================================================================================================================
//=================================================================================================================================

1. Introduction to File I/O
============================

I/O stands for the input and output. There are different way of input-output in java, some of these are

	- Console IO
	- file IO
	- Network IO
	- Mobile IO
	- Bluetooth, infra or wifi (wireless) IO
	....	

File Input/Output (I/O) is a fundamental concept in programming that involves reading from and writing to 
files on a storage device. In Java, file I/O operations are essential for handling persistent data, such as 
reading configuration files, logging information, and storing user data.

File I/O encompasses all the operations that a program performs to interact with files and directories. This 
includes creating, reading, writing, and deleting files, as well as managing file attributes and metadata. 
Java provides a rich set of classes and methods to perform these operations efficiently and reliably.

- Importance of File I/O in Java Applications

 - Data Persistence: Files provide a way to store data permanently, unlike inernal-memory storage which is 
   temporary. This is essential for saving user data, application state, and other critical information.

 - Configuration Management: Many applications rely on configuration files to manage settings and preferences. 
   File I/O allows these configurations to be read and modified as needed.

 - Logging and Monitoring: Applications often need to record events, errors, and other significant activities. 
   File I/O enables the creation of log files that can be analyzed for troubleshooting and performance 
   monitoring.

Basic Concepts and Terminology

 - File: A file is a named location on a storage device that holds data. Files can be text files (containing 
   readable characters) or binary files (containing data in a format not meant to be read as text).

 - Directory (or Folder): A directory is a container that can hold files and other directories. It helps 
   organize files in a hierarchical structure.

 - Path: A path is a string representation that specifies the location of a file or directory within the file 
   system. Paths can be absolute (starting from the root of the file system) or relative (relative to the 
   current working directory).

 - Streams: Streams are abstractions that represent a flow of data. In Java, streams are used to read from and    
   write to files. There are input streams (for reading data) and output streams (for writing data).

    - Standard Streams in Java:

	In Java, 3 streams are created for us automatically. All these streams are attached to the console.

	- System.out (standard output stream): This is used to feed the data to the user’s program and usually a keyboard is 
	  used as a standard input stream and represented as System.in.

	- System.in (standard input stream): This is used to output the data produced by the user’s program and usually a 
	  computer screen is used for standard output stream and represented as System.out.

	- System.err (standard error stream): This is used to output the error data produced by the user’s program and usually 
	  a computer screen is used for standard error stream and represented as System.err.
   

 In Java File I/O, streams are used to read from and write to files. Streams are categorized mainly 
 into two types: 

	- byte streams 
	- character streams.


Byte Streams: Byte streams handle I/O of raw binary data. They read and write data in bytes (8 bits). 
---------------
The main classes for byte streams are:

- InputStream
	- FileInputStream
	- ByteArrayInputStream
	- FilterInputStream
		-- BufferedInputStream
		-- DataInputStream
		-- PushbackInputStream
	- ObjectInputStream
	- PipedInputStream
	- SequenceInputStream

- OutputStream
	- FileOutputStream
	- ByteArrayOutputStream
	- FilterOutputStream
		-- BufferedOutputStream
		-- DataOutputStream
	- ObjectOutputStream
	- PipedOutputStream
	- PrintStream

Character Streams:Character streams handle I/O of character data, which means they read and write data in 16-bit Unicode.
------------------
 The main classes for character streams are:

- Reader
	- FileReader
	- BufferedReader
	- CharArrayReader
	- FilterReader
		-- PushbackReader
	- InputStreamReader
		-- FileReader
		-- PipedReader
	- StringReader

- Writer
	- FileWriter
	- BufferedWriter
	- CharArrayWriter
	- FilterWriter
		-- OutputStreamWriter
			- FileWriter
		-- PipedWriter
		-- PrintWriter
	- StringWriter

Specialized Streams: These streams provide additional functionality on top of basic I/O operations.
===================================================================================================

Data Streams: Used to read and write primitive data types.

	- DataInputStream
	- DataOutputStream

Object Streams: Used to read and write objects, supporting object serialization.

	- ObjectInputStream
	- ObjectOutputStream


//-----------------------------------------------------------------------------------------------------------------

class hierarchy of java.io classes:

java.io
├── Closeable (interface)
│   ├── AutoCloseable (interface)
│   └── Flushable (interface)
├── Serializable (interface)
├── DataInput (interface)
├── DataOutput (interface)
├── Externalizable (interface)
├── InputStream (abstract class)
│   ├── ByteArrayInputStream
│   ├── FileInputStream
│   ├── FilterInputStream
│   │   ├── BufferedInputStream
│   │   ├── DataInputStream
│   │   ├── PushbackInputStream
│   │   └── LineNumberInputStream (deprecated)
│   ├── ObjectInputStream
│   ├── PipedInputStream
│   └── SequenceInputStream
├── OutputStream (abstract class)
│   ├── ByteArrayOutputStream
│   ├── FileOutputStream
│   ├── FilterOutputStream
│   │   ├── BufferedOutputStream
│   │   ├── DataOutputStream
│   │   └── PrintStream
│   ├── ObjectOutputStream
│   ├── PipedOutputStream
│   └── SequenceOutputStream (deprecated)
├── Reader (abstract class)
│   ├── BufferedReader
│   ├── CharArrayReader
│   ├── FilterReader
│   │   └── PushbackReader
│   ├── InputStreamReader
│   │   └── FileReader
│   ├── PipedReader
│   ├── StringReader
│   └── LineNumberReader
├── Writer (abstract class)
│   ├── BufferedWriter
│   ├── CharArrayWriter
│   ├── FilterWriter
│   ├── OutputStreamWriter
│   │   └── FileWriter
│   ├── PipedWriter
│   ├── PrintWriter
│   └── StringWriter
├── File
├── RandomAccessFile
├── FileDescriptor
└── FilePermission

//------------------------------------------------------------------------------------

	// Using java.io.File class: 

	The File class in Java is part of the java.io package and represents an abstract representation of file and directory 
	pathnames. This class provides methods for creating, deleting, and querying files and directories.

Constructors:

File(String pathname): Creates a new File instance by converting the given pathname string into an abstract pathname.
File(String parent, String child): Creates a new File instance from a parent pathname string and a child pathname string.
File(File parent, String child): Creates a new File instance from a parent abstract pathname and a child pathname string.
File(URI uri): Creates a new File instance by converting the given file: URI into an abstract pathname.

Methods: 

boolean createNewFile(): Creates a new, empty file if it does not exist.
boolean delete(): Deletes the file or directory.

boolean exists(): Tests whether the file or directory exists.
boolean isDirectory(): Tests whether the file is a directory.
boolean isFile(): Tests whether the file is a normal file.
long length(): Returns the length of the file in bytes.

String getName(): Returns the name of the file or directory.
String getAbsolutePath(): Returns the absolute pathname string.
String getCanonicalPath(): Returns the canonical pathname string.
String getParent(): Returns the pathname string of the parent directory.

String[] list(): Returns an array of strings naming the files and directories in the directory.
File[] listFiles(): Returns an array of File objects representing the files and directories in the directory.
boolean mkdir(): Creates the directory named by this abstract pathname.
boolean mkdirs(): Creates the directory named by this abstract pathname, including any necessary but nonexistent parent directories.

boolean canRead(): Tests whether the application can read the file.
boolean canWrite(): Tests whether the application can modify the file.
boolean canExecute(): Tests whether the application can execute the file.

boolean renameTo(File dest): Renames the file or directory.		

boolean setReadOnly(): Marks the file as read-only.
boolean setReadable(boolean readable, boolean ownerOnly): Sets the owner's or everyone's read permission.
boolean setWritable(boolean writable, boolean ownerOnly): Sets the owner's or everyone's write permission.
boolean setExecutable(boolean executable, boolean ownerOnly): Sets the owner's or everyone's execute permission.


package fileexamples;

import java.io.File;
import java.io.*;

public class FileExample {
	public static void main(String[] args) {
		
		File file = new File("example.txt");
		// Creates a new File instance by converting the given pathname string into an abstract pathname.

		// Check if the file exists
		if (file.exists()) {
			System.out.println("File exists");
		} else {
			System.out.println("File does not exist");
		}

		// Create a new file
		try {
			boolean created = file.createNewFile();
			if (created) {
				System.out.println("File created successfully");
			} else {
				System.out.println("File already exists");
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		// Get file information
		System.out.println("File name: " + file.getName());
		System.out.println("Absolute path: " + file.getAbsolutePath());
		System.out.println("Writable: " + file.canWrite());
		System.out.println("Readable: " + file.canRead());
		System.out.println("File size in bytes: " + file.length());
	}
}

//------------------------------

	// using delete()

package fileexamples;

import java.io.File;
import java.io.*;

public class FileExample {
	public static void main(String[] args) {
		
		File file = new File("example.txt");
		// Creates a new File instance by converting the given pathname string into an abstract pathname.

		// Check if the file exists
		if (file.exists()) {
			System.out.println("File exists");
		} else {
			System.out.println("File does not exist");
		}

		// Create a new file
		try {
			boolean created = file.createNewFile();
			if (created) {
				System.out.println("File created successfully");
			} else {
				System.out.println("File already exists");
			}
		} catch (IOException e) {
			e.printStackTrace();
		}

		// Get file information
		System.out.println("File name: " + file.getName());
		System.out.println("Absolute path: " + file.getAbsolutePath());
		System.out.println("Writable: " + file.canWrite());
		System.out.println("Readable: " + file.canRead());
		System.out.println("File size in bytes: " + file.length());
		
		if(file.delete()) {
			System.out.println("File "+file.getName()+" Deleted");
		}
		else {
			System.out.println("Unable to delete File "+file.getName());
		}
	}
}

//-----------------------------------------------------------------------------------------

	// creating and deleting Directory

package fileexamples;
import java.io.File;
import java.io.IOException;

public class FileParentChildExample {
    public static void main(String[] args) {
        // Define the parent directory
        String parentDir = "e:\\parentDir";
        
        // Create a File object for the parent directory
        File parentDirectory = new File(parentDir);

        // Create the parent directory if it does not exist
        if (!parentDirectory.exists()) {
            if (parentDirectory.mkdir()) {
                System.out.println("Parent directory created: " + parentDirectory.getAbsolutePath());
            } else {
                System.out.println("Failed to create parent directory.");
                return;
            }
        }

        // Define the child file name
        String childFile = "childFile.txt";

        // Create a File object using the parent directory and child file name
        File file = new File(parentDir, childFile);

        try {
            // Check if the file exists, if not create a new file
            if (file.createNewFile()) {
                System.out.println("File created: " + file.getAbsolutePath());
            } else {
                System.out.println("File already exists: " + file.getAbsolutePath());
            }

            // Display file information
            System.out.println("Absolute path: " + file.getAbsolutePath());
            System.out.println("Parent: " + file.getParent());
            System.out.println("Is directory: " + file.isDirectory());
            System.out.println("Is file: " + file.isFile());


        } catch (IOException e) {
            e.printStackTrace();
        }

        // Clean up: delete the file and directory created for this example
        if (file.delete()) {
            System.out.println("File deleted: " + file.getAbsolutePath());
        } else {
            System.out.println("Failed to delete file.");
        }

        if (parentDirectory.delete()) {
            System.out.println("Parent directory deleted: " + parentDirectory.getAbsolutePath());
        } else {
            System.out.println("Failed to delete parent directory.");
        }
    }
}

//--------------------------------------------------------------------------------------------------

	// dealing with multiple files

package fileexamples;

import java.io.*;

public class DirectoryExample {
	public static void main(String[] args) throws Exception {
		
			// Create a directory
			File directory = new File("exampleDir");
			if (directory.mkdir()) {
				System.out.println("Directory created: " + directory.getName());
			} else {
				System.out.println("Directory already exists or failed to create.");
			}

			for (int i = 0; i < 5; i++) {
				File file = new File("exampleDir", "example" + i + ".txt");

				// Create a new file if it does not exist
				if (file.createNewFile()) {
					System.out.println("File created: " + file.getName());
				} else {
					System.out.println("File already exists.");
				}

			}
			// List files in the directory
			System.out.println("Files in directory: ");
			File[] filesList = directory.listFiles();
			if (filesList != null) {
				for (File f : filesList) {
					System.out.println(f.getName());
				}
			}

			// Delete the file and directory
			if (filesList != null) {
				for (File f : filesList) {
					if (f.delete()) {
						System.out.println("File deleted: " + f.getName());
					} else {
						System.out.println("Failed to delete file.");
					}
				}
			}

			if (directory.delete()) {
				System.out.println("Directory deleted: " + directory.getName());
			} else {
				System.out.println("Failed to delete directory.");
			}

		
		}
	}

//------------------------------------------------------------------------------------------------------------------------------

	// Byte stream Classes

	byte streams are used to perform input and output of 8-bit bytes. They are part of the java.io package and are used for 
	handling binary data. Byte stream classes are divided into two main categories: input streams and output streams. 

	Input Stream Classes:

	- InputStream: This is an abstract superclass that defines methods for reading bytes from a stream. All other input stream 
		       classes are derived from it.
	   - FileInputStream: Reads bytes from a file.
	   - ByteArrayInputStream: Reads bytes from a byte array.
	   - FilterInputStream: A wrapper around another input stream that provides additional functionality.
		- BufferedInputStream: Adds buffering to an input stream, improving efficiency by reducing the number of read 
					operations.
		- DataInputStream: Reads primitive Java data types (int, float, etc.) from an input stream.
		- PushbackInputStream: Allows a byte to be "pushed back" onto the stream, enabling a byte to be read again.
	   - ObjectInputStream: Reads objects that were previously serialized using an ObjectOutputStream.
	   - PipedInputStream: Used to read data from a connected PipedOutputStream.
	   - SequenceInputStream: Concatenates multiple input streams into one stream.

	Output Stream Classes

	- OutputStream: This is an abstract superclass that defines methods for writing bytes to a stream. All other output 
		 	stream classes are derived from it.
	   - FileOutputStream: Writes bytes to a file.
	   - ByteArrayOutputStream: Writes bytes to a byte array.
	   - FilterOutputStream: A wrapper around another output stream that provides additional functionality.
		- BufferedOutputStream: Adds buffering to an output stream, improving efficiency by reducing the number of 
					write operations.
		- DataOutputStream: Writes primitive Java data types (int, float, etc.) to an output stream.
		- PrintStream: Adds functionality to output formatted representations of objects to the stream.
	   - ObjectOutputStream: Writes objects to an output stream so they can be read back using an ObjectInputStream.
	   - PipedOutputStream: Used to write data to a connected PipedInputStream.

//-----------------------------------------------------------------------

FileOutputStream: FileOutputStream is a class in the java.io package that is used to write raw byte streams to a file. 
		  It is used when you need to write binary data, such as images, audio files, etc., or when you need to 
		  write textual data in a specific encoding.

	- FileOutputStream allows you to write bytes to a file. It can write a single byte, an array of bytes, or a 
	  portion of an array.
	- You can specify whether to overwrite the file or append data to it.
	- If the specified file does not exist, FileOutputStream will create it.

	Methods:
	- write(int b): Writes the specified byte to this file output stream.
	- write(byte[] b): Writes b.length bytes from the specified byte array to this file output stream.
	- write(byte[] b, int off, int len): Writes len bytes from the specified byte array starting at offset off to 
					     this file output stream.
	- close(): Closes the file output stream and releases any system resources associated with it.

FileInputStream: FileInputStream is a class in the java.io package that is used to read raw byte streams from a file. 
		 It is used when you need to read binary data, such as images, audio files, etc., or when you need to read 
		 textual data in a specific encoding.

	- FileInputStream allows you to read bytes from a file. It can read a single byte, an array of bytes, 
	  or a portion of an array.
	- The specified file must exist when you create a FileInputStream

	Methods
	- int read(): Reads a byte of data from this input stream.
	- int read(byte[] b): Reads up to b.length bytes of data from this input stream into an array of bytes.
	- int read(byte[] b, int off, int len): Reads up to len bytes of data from this input stream into an array of bytes 
						starting at offset off.
	- int available(): Returns an estimate of the number of remaining bytes that can be read from this input stream.
	- void close(): Closes the file input stream and releases any system resources associated with it.

package fileexamples;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileIOStreamExample {
	public static void main(String[] args) {
		String filename = "example.txt";
		String contentToWrite = "Hello, World! This is an example of FileOutputStream and FileInputStream.";

		// Write content to file using FileOutputStream
		FileOutputStream fos = new FileOutputStream(filename)
		try (fos) {
			fos.write(contentToWrite.getBytes());
			System.out.println("Content written to file: " + filename);
		} catch (IOException e) {
			System.err.println("Error writing to file: " + e.getMessage());
		}

		// Read content from file using FileInputStream
		try (FileInputStream fis = new FileInputStream(filename)) {
			int content;
			System.out.println("Content read from file: ");
			while ((content = fis.read()) != -1) {
				System.out.print((char) content);
			}
			System.out.println(); // Newline for clean output
		} catch (IOException e) {
			System.err.println("Error reading from file: " + e.getMessage());
		}
	}
}
//----------------- or -------------------------------
package fileexamples;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class StreamIOExample {
	public static void main(String[] args) throws Exception {
	
		String data = "This the data, that we have to write in to the file.";
		
		File datafile = new File("data.txt");
		//datafile.createNewFile();
		FileOutputStream fos=new FileOutputStream(datafile);
		byte []b=data.getBytes();
		fos.write(b);
		//fos.close();
		
		FileInputStream fis = new FileInputStream(datafile);
		byte []ba=new byte[fis.available()];
		fis.read(ba);
		
		System.out.println("The data read from file: ");
		for(byte t : ba)
		{
			System.out.print((char)t);
		}
		fis.close();
	}
}

//-----------------------------------------------------------------------------------

ByteArrayInputStream: ByteArrayInputStream is a class in the java.io package that allows an application to create an input stream 
		      from a byte array. This stream is used to read bytes from a byte array as if it were an input stream.

	- int read(): Reads the next byte of data from the input stream.
	- int read(byte[] b, int off, int len): Reads up to len bytes of data into an array of bytes.
	- long skip(long n): Skips n bytes of input.
	- int available(): Returns the number of remaining bytes that can be read from this input stream.
	- void reset(): Resets the input stream to the beginning of the byte array.

ByteArrayOutputStream: ByteArrayOutputStream is a class in the java.io package that allows an application to create an output 
		       stream in which data is written into a byte array. The buffer automatically grows as data is written to it.

	- void write(int b): Writes the specified byte to this byte array output stream.
	- void write(byte[] b, int off, int len): Writes len bytes from the specified byte array starting at offset off to 
						  this byte array output stream.
	- byte[] toByteArray(): Returns the current contents of the output stream as a byte array.
	- String toString(): Converts the buffer's contents into a string.
	- void reset(): Resets the ByteArrayOutputStream so that it can be reused.

package fileexamples;
import java.io.*;
public class ByteArrayInputStreamDemo {
	public static void main(String[] args) {
		String str = "Hello World";
		byte arrb[] = str.getBytes();
		ByteArrayInputStream bais = new ByteArrayInputStream(arrb);
		int ch;
		ch = bais.read();
		while (ch != -1) {
			System.out.print((char) ch);
			ch = bais.read();
		}
	}
}

//----------------------------------------------------

package fileexamples;
import java.io.*;
public class ByteArrayOutputStreamDemo {
	public static void main(String[] args) {
		String data = "Hello World";
		try {
			// Creates an output stream
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			byte[] array = data.getBytes();

			// Writes data to the output stream
			out.write(array);

			// Retrieves data from the output stream in string format
			String streamData = out.toString();
			System.out.println("Output stream: " + streamData);

			out.close();
		} catch (Exception e) {
			e.getStackTrace();
		}
	}
}

//--------------------------------------------------------------------------------------------------------------------------

	// FilterInputStream and FilterOutputStream in Java 

	FilterOutputStream is a concrete subclass class of OutputStream class that filters data of an underlying output stream.
	FilterInputStream class has following important subclasses that are as follows:

	- BufferedOutputStream
	- CheckedOutputStream
	- DataOutputStream
	- DeflaterOutputStream
	- DigestOutputStream
	- InflaterOutputStream
	- PrintStream

	
      Constructors
	- FilterOutputStream(OutputStream out): Creates an output stream filter built on top of the specified underlying 
						output stream.

	Method
	- void close(): Closes this output stream and releases any system resources associated with the stream.
	- void flush(): Flushes this output stream and forces any buffered output bytes to be written out to the stream.
	- void write(byte[] b): Writes b.length bytes to this output stream.
	- void write(byte[] b, int off, int len): Writes len bytes from the specified byte array starting at offset off to this output stream.
	- void write(int b): Writes the specified byte to this output stream.


	FilterInputStream in Java: FilterInputStream in Java is a concrete subclass class of InputStream class. Filter streams are 
	streams that wrap around underlying input or output streams and adds new features. filter streams are streams that filter 
	byte input or output streams for some purpose.

	ilterInputStream class has four important subclasses that are as follows:

	- BufferedInputStream
	- DataInputStream
	- LineNumberInputStream
	- PushbackInputStream

	Constructor:

	- protected FilterInputStream(InputStream in): Creates a FilterInputStream by assigning the argument in to the field 
	  this.in so as to remember it for later use.

	Methods:
	- int available()
	- void close()
	- void mark(int readlimit)
	- boolean markSupported()	
	- int read()
	- int read(byte[] b)
	- int read(byte[] b, int off, int len)
	- void reset()
	- long skip(long n)


//-----------------------------------------------------------------------------
	// BufferedInputStream and BufferedOutputStream class

	BufferedInputStream and BufferedOutputStream are two classes in the Java I/O framework that provide buffering capabilities 
	for input and output streams, respectively. Buffering improves the efficiency of I/O operations by reducing the number of 
	interactions with the underlying device, such as a file or network socket.

	BufferedOutputStream class in Java:

	Constructor of BufferedOutputStream class:
	
		- BufferedOutputStream(OutputStream outputStream): 
		- BufferedOutputStream(OutputStream outputStream, int size): 

	 Methods: BufferedOutputStream class in Java does not define any new methods. All the methods in BufferedOutputStream 
	 are inherited from the OutputStream class.

	 Some important methods are as follows:

	- void write(int b): This method writes the specified byte to the buffered output stream.
	- void write(byte[ ] b, int n, int m): This method writes the bytes from the specified byte-input stream m into a 
	  specified byte array, starting from the given nth byte.
	- void flush(): This method flushes the buffered output stream. It can be used to clear the internal buffer by forcing 
	  the output stream to write all data present in the buffer to the destination file.
	- void close(): This method closes the buffered output stream. Once the method is invoked, we cannot write the data again.

	All of the above methods will throw an exception named IOException if any error occurs.
	

	public class BufferedOutputStreamEx {
		public static void main(String[] args) {
		try {
			// Create a FileOutputStream object to connect myfile to FileOutputStream.	 
			FileOutputStream fos = new FileOutputStream("E:\\myfileout.txt");

			// Create a BufferedOutputStream object to wrap FileOutputStream in BufferedOutputStream.
			BufferedOutputStream bos = new BufferedOutputStream(fos);

			String s = "Welcome to Archer InfoTech Pune";
			byte b[] = s.getBytes(); // Converting String into array bytes.
			bos.write(b); // Write data to the output stream.
			bos.close(); // Closing output stream.
			fos.close();
			System.out.println("Successfully written...");
		} catch (Exception e) {
			System.out.println(e);
		}
	}
//------------------------------------
package fileexamples;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class BufferedOutputStreamEx1 {
	public static void main(String[] args) throws IOException {
		String data = "Hello Java";
		// Create a FileOutputStream object to connect myfile to FileOutputStream.	 
		FileOutputStream fos = new FileOutputStream("E:\\myfileout1.txt");

		// Create a BufferedOutputStream object to wrap FileOutputStream in BufferedOutputStream.
		BufferedOutputStream bos = new BufferedOutputStream(fos, 1024);

		bos.write(data.getBytes()); // Writing data to output stream.
		bos.flush(); // Flushing all data from internal buffer to destination file.
		bos.close();
		System.out.println("Successfully written...");
	}
}



   BufferedInputStream in Java

	A BufferedInputStream in Java is a concrete subclass of FilterInputStream that wraps (buffers) an input stream into a 
	buffered stream and makes read operations on the stream more efficient and fast. In simple words, it adds buffering 
	capabilities to an input stream that stores data (in bytes) temporarily into a memory buffer by reading from the stream.
	
	BufferedInputStream, a buffer is internally between the program and the source. During the read operation, the whole 
	block of data (in bytes) is read from the disk and temporarily stored into the internal buffer in the memory once.The data 
	are then transferred (read) individually to the program from the buffer.

	Constructors: 
	- BufferedInputStream(InputStream inputStream)
	- BufferedInputStream(InputStream inputStream, int size)	

	Methods:
	- int read(): Reads the next byte of data from the input stream.
	- int read(byte[] b, int off, int len): Reads up to len bytes of data into an array.
	- long skip(long n): Skips over and discards n bytes of data from the input stream.
	- int available(): Returns the number of bytes that can be read without blocking.
	- void mark(int readlimit): Marks the current position in the input stream.
	- void reset(): Resets the stream to the most recent mark.
	- boolean markSupported(): Indicates if mark and reset are supported.

package fileexamples;

import java.io.BufferedInputStream;
import java.io.FileInputStream;

public class BufferedInputStreamEx {
	public static void main(String[] args) {
		try {
			// Create a FileInputStream object to attach myfile to FileInputStream.	 
			FileInputStream fis = new FileInputStream("D:\\myfile.txt");

			// Create a BufferedInputStream object to wrap FileInputStream in BufferedInputStream.
			BufferedInputStream bis = new BufferedInputStream(fis);

			int i = 0;
			while ((i = bis.read()) != -1) {
				char ch = (char) i;
				System.out.print(ch);
			}
			bis.close();
			fis.close();
		} catch (Exception e) {
			System.out.println(e);
		}
	}
}

//-----------------------------------------------------
package fileexamples;

import java.io.BufferedInputStream;
import java.io.FileInputStream;

public class BufferedInputStreamEx1 {
	public static void main(String[] args) {
		try {
			// Create a FileInputStream object to attach myfile to FileInputStream.	 
			FileInputStream fis = new FileInputStream("E:\\myfile.txt");

			// Create a BufferedInputStream object to wrap FileInputStream in BufferedInputStream.
			BufferedInputStream bis = new BufferedInputStream(fis);

			// Skips 5 bytes from the buffered input stream.
			bis.skip(5);
			System.out.println("Input stream after skipping first 5 bytes:");

			// Reads all available bytes from buffered input stream after skipping.
			int i = 0;
			while ((i = bis.read()) != -1) {
				System.out.print((char) i);
			}
			bis.close();
		} catch (Exception e) {
			System.out.println(e);
		}
	}
}

//------------------------------------------------

	// DataInputStream and DataOutputStream class:

	DataInputStream Class: DataInputStream is a byte stream class which is used to perform reading operation from any input 
	device like keyboard, file, etc. Java DataInputStream class allows an application to read primitive data from the input 
	stream in a machine-independent way.

	Methods:
	- readBoolean(): Reads a boolean value.
	- readByte(): Reads a byte value.
	- readChar(): Reads a char value.
	- readDouble(): Reads a double value.
	- readFloat(): Reads a float value.
	- readInt(): Reads an int value.
	- readLong(): Reads a long value.
	- readShort(): Reads a short value.
	- readUTF(): Reads a String encoded in UTF-8.

	DataOutputStream Class: Java DataOutputStream class allows an application to write primitive Java data types to the output 
	stream in a machine-independent way. Java application generally uses the data output stream to write data that can later be 
	read by a data input stream.
	
	Methods:
	- writeBoolean(boolean v): Writes a boolean value.
	- writeByte(int v): Writes a byte value.
	- writeChar(int v): Writes a char value.
	- writeDouble(double v): Writes a double value.
	- writeFloat(float v): Writes a float value.
	- writeInt(int v): Writes an int value.
	- writeLong(long v): Writes a long value.
	- writeShort(int v): Writes a short value.
	- writeUTF(String str): Writes a String encoded in UTF-8.


	// using DataInputStream 

package fileexamples;
import java.io.*;
public class DataInputStreamDemo {
	@SuppressWarnings("deprecation")
	public static void main(String[] args) throws IOException {

		DataInputStream dis = new DataInputStream(System.in);
		System.out.println("Enter any string");
		String str = dis.readLine(); // parsing
		System.out.println("str=" + str);
		
		System.out.println("Enter any Integer");
		int i = Integer.parseInt(dis.readLine()); // parsing
		System.out.println("i=" + i);
		
		System.out.println("Enter any Double");
		double d = Double.parseDouble(dis.readLine());
		System.out.println("d=" + d);
	}
}

//-------

package fileexamples;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class DataInputStreamEx {
	public static void main(String[] args) throws IOException {
		String filepath = "e:\\myfileout.dat";
		// Create a FileOutputStream object to connect with myfileout.dat file.
		FileOutputStream fos = new FileOutputStream(filepath);

		// Create a DataOutputStream object to wrap on fos.  
		DataOutputStream dos = new DataOutputStream(fos);

		// Write following primitive data to the "myfileout.dat" file.
		dos.writeUTF("Welcome to Java world");
		dos.writeInt(1246);
		dos.writeDouble(125.25);
		dos.writeBoolean(true);
		dos.writeChar('S');

		dos.close();
		fos.close();

		// Reading data from the "myfileout.dat" file.
		FileInputStream fis = new FileInputStream(filepath);
		DataInputStream dis = new DataInputStream(fis);

		System.out.println(dis.readUTF());
		System.out.println(dis.readInt());
		System.out.println(dis.readDouble());
		System.out.println(dis.readBoolean());
		System.out.println(dis.readChar());

		dis.close();
		fis.close();
	}
}

//----------------------------------------

   // PushbackInputStream in Java :

	PushbackInputStream in Java is an input stream that pushes (i.e. returns) a single byte or character back into the input 
	stream to reread. In other words, PushbackInputStream is a buffer stream that adds “push back” functionality to an input 
	stream to reread “unread” bytes (or push back read bytes). That’s why it is also called pushback buffer. It is used on an 
	input stream to allow a byte to be read and then returned to the stream.

	constructors:
	 - PushbackInputStream(InputStream inputStream)
	 - PushbackInputStream(InputStream inputStream, int numBytes)

	Methods: 
	 - int available()
	 - void close()
	 - void mark(int readlimit)
	 - boolean markSupported()
	 - int read()
	 - int read(byte[ ] b, int n, int m)
	 - long skip(long n)
	 - void unread(byte[ ] b)
	 - void unread(byte[ ] b, int n, int m)	
	 - void unread(int b)

package fileexamples;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.PushbackInputStream;

public class PushbackFileReading {
	public static void main(String[] args) throws IOException {
		String filepath = "myfileout.txt";
		FileInputStream fis = new FileInputStream(filepath);
		PushbackInputStream pushback = new PushbackInputStream(fis);

		// Read a single byte at a time and print it.
		byte bytedata;
		while ((bytedata = (byte) pushback.read()) != -1) {
			System.out.print((char) bytedata);

			// Unread the last byte that we have just read.
			pushback.unread(bytedata);

			// Reread the byte we unread (or pushed back).
			bytedata = (byte) pushback.read();
			System.out.print((char) bytedata);
		}
	}
}

//--------------------------------------------------------------------------------------------------------

	// PrintStream class in Java

	The PrintStream class in Java is a subclass of FilterOutputStream and is used for producing formatted output to a stream. 
	It adds the ability to print various data types conveniently, with automatic flushing, and supports formatting similar 
	to printf in C.

	Constructors:

	- PrintStream(OutputStream out): Creates a new print stream with automatic line flushing.
	- PrintStream(OutputStream out, boolean autoFlush): Creates a new print stream with optional automatic line flushing.
	- PrintStream(OutputStream out, boolean autoFlush, String encoding): Creates a new print stream with optional automatic 
	  line flushing and a specified character encoding.

	Methods:

	- void print(boolean b): Prints a boolean value.
	- void print(char c): Prints a character.
	- void print(int i): Prints an integer.
	- void print(long l): Prints a long integer.
	- void print(float f): Prints a floating-point number.
	- void print(double d): Prints a double-precision floating-point number.
	- void print(char[] s): Prints an array of characters.
	- void print(String s): Prints a string.
	- void print(Object obj): Prints an object.
	- void println(): Terminates the current line by writing the line separator string.
	- void println(boolean b): Prints a boolean value and then terminates the line.
	- void println(char c): Prints a character and then terminates the line.
	- void println(int i): Prints an integer and then terminates the line.
	- void println(long l): Prints a long integer and then terminates the line.
	- void println(float f): Prints a floating-point number and then terminates the line.
	- void println(double d): Prints a double-precision floating-point number and then terminates the line.
	- void println(char[] s): Prints an array of characters and then terminates the line.
	- void println(String s): Prints a string and then terminates the line.
	- void println(Object obj): Prints an object and then terminates the line.
	- PrintStream printf(String format, Object... args): A method to format and print text.
	- PrintStream printf(Locale l, String format, Object... args): A method to format and print text with a specified locale.
	- void flush(): Flushes the stream.
	- void close(): Closes the stream.

package fileexamples;
import java.io.PrintStream;
public class PrintStreamExample {
	public static void main(String[] args) {
		PrintStream ps = System.out;

		ps.print("Hello, ");
		ps.println("World!");
		ps.printf("This is a number: %d%n", 42);
		ps.printf("This is a floating-point number: %.2f%n", 3.14159);

		boolean b = true;
		char c = 'A';
		int i = 123;
		long l = 123456789L;
		float f = 1.23f;
		double d = 1.23456789;
		String str = "Hello, PrintStream!";

		ps.println(b);
		ps.println(c);
		ps.println(i);
		ps.println(l);
		ps.println(f);
		ps.println(d);
		ps.println(str);
	}
}

//--------------------
package fileexamples;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;

public class PrintStreamToFileExample {
    public static void main(String[] args) {
        try (PrintStream ps = new PrintStream(new FileOutputStream("output.txt"))) {
            ps.println("Writing to a file");
            ps.printf("Formatted number: %d%n", 100);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
//----------

package fileexamples;
import java.io.PrintStream;
import java.util.Date;

public class PrintStreamFormattingExample {
    public static void main(String[] args) {
        PrintStream ps = System.out;

        ps.printf("Current date and time: %tc%n", new Date());
        ps.printf("Number with leading zeros: %04d%n", 5);
        ps.printf("Floating-point number with 2 decimals: %.2f%n", 123.456);
        ps.printf("Right-justified number: %10d%n", 42);
    }
}
//---------------------------------

package fileexamples;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;

public class RedirectSystemOutExample {
    public static void main(String[] args) {
        try {
            PrintStream fileOut = new PrintStream(new FileOutputStream("system_out.txt"));
            System.setOut(fileOut);
            
            System.out.println("This will be written to the file");
            System.out.printf("Formatted output to the file: %d%n", 123);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

//------------------------------------------------------------------------------------------------------------------------

	// ObjectInputStream and ObjectOutputStream classes

	ObjectInputStream and ObjectOutputStream are classes in the Java I/O framework that are used for serializing and 
	deserializing objects. Serialization is the process of converting an object's state into a byte stream, while 
	deserialization is the process of reconstructing the object from the byte stream.


	ObjectOutputStream: ObjectOutputStream is a subclass of OutputStream that is used to write objects to an output stream. 
	It allows objects to be written to a stream in a way that they can be read back later.
	
	Constructors:

	- ObjectOutputStream(OutputStream out): Creates an ObjectOutputStream that writes to the specified OutputStream.

	Methods:

	- void writeObject(Object obj): Writes the specified object to the ObjectOutputStream.
	- void writeInt(int val): Writes an int to the stream.
	- void writeBoolean(boolean val): Writes a boolean to the stream.
	- void writeDouble(double val): Writes a double to the stream.
	- void close(): Closes the ObjectOutputStream.

	ObjectInputStream: ObjectInputStream is a subclass of InputStream that is used to read objects from an input stream. 
	It allows objects to be reconstructed from the byte stream

	Constructors:

	- ObjectInputStream(InputStream in): Creates an ObjectInputStream that reads from the specified InputStream.

	Methods:

	- Object readObject(): Reads an object from the ObjectInputStream.
	- int readInt(): Reads an int from the stream.
	- boolean readBoolean(): Reads a boolean from the stream.
	- double readDouble(): Reads a double from the stream.
	- void close(): Closes the ObjectInputStream.

	// example demonstrating how to use ObjectInputStream and ObjectOutputStream to serialize and deserialize an object

package fileexamples;

import java.io.*;

class Person implements Serializable {
	private String name;
	private int age;

	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	@Override
	public String toString() {
		return "Person{name='" + name + "', age=" + age + "}";
	}
}

public class SerializationExample {
	public static void main(String[] args) {
		Person person = new Person("John Doe", 30);
		String filename = "person.ser";

		// Serialize the object
		try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
			oos.writeObject(person);// Serialize
			System.out.println("Serialization successful: " + person);
		} catch (IOException e) {
			e.printStackTrace();
		}

		// Deserialize the object
		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
			Person deserializedPerson = (Person) ois.readObject();// Deserialize 
			System.out.println("Deserialization successful: " + deserializedPerson);
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
		}
	}
}

//------------------------------

	// Serializing and Deserializing Multiple Objects
package fileexamples;

import java.io.*;

class Employee implements Serializable {
	private String name;
	private double salary;

	public Employee(String name, double salary) {
		this.name = name;
		this.salary = salary;
	}

	@Override
	public String toString() {
		return "Employee{name='" + name + "', salary=" + salary + "}";
	}
}

public class MultipleObjectsExample {
	public static void main(String[] args) {
		Employee emp1 = new Employee("Alice", 75000);
		Employee emp2 = new Employee("Bob", 80000);
		String filename = "employees.ser";

		// Serialize the objects
		try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
			oos.writeObject(emp1);
			oos.writeObject(emp2);
			System.out.println("Serialization successful: " + emp1 + ", " + emp2);
		} catch (IOException e) {
			e.printStackTrace();
		}

		// Deserialize the objects
		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
			Employee deserializedEmp1 = (Employee) ois.readObject();
			Employee deserializedEmp2 = (Employee) ois.readObject();
			System.out.println("Deserialization successful: " + deserializedEmp1 + ", " + deserializedEmp2);
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
		}
	}
}

//--------------------------------------------------

	// Handling Transient Fields: Fields declared as transient are not serialized. This can be useful for sensitive data 
				      or fields that can be recalculated.

	The transient keyword is used to exclude fields from the serialization process. This can be useful for:

	- Sensitive information (e.g., passwords, security tokens) that should not be stored or transmitted.
	- Fields that can be easily recomputed and do not need to be saved.
	- Reducing the size of the serialized object by excluding non-essential fields.

package fileexamples;

import java.io.*;

class User implements Serializable {
	private static final long serialVersionUID = 1L;
	private String username;
	private transient String password; // This field will not be serialized

	public User(String username, String password) {
		this.username = username;
		this.password = password;
	}

	@Override
	public String toString() {
		return "User{username='" + username + "', password='" + password + "'}";
	}
}

public class TransientFieldExample {
	public static void main(String[] args) {
		User user = new User("john_doe", "password123");
		String filename = "user.ser";

		// Serialize the object
		try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
			oos.writeObject(user);
			System.out.println("Serialization successful: " + user);
		} catch (IOException e) {
			e.printStackTrace();
		}

		// Deserialize the object
		try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
			User deserializedUser = (User) ois.readObject();
			System.out.println("Deserialization successful: " + deserializedUser);
		} catch (IOException | ClassNotFoundException e) {
			e.printStackTrace();
		}
	}
}


///-------------------------------------------------------------

	// PipedInputStream and PipedOutputStream 
	//-------------------------------------------

	PipedInputStream and PipedOutputStream are part of the java.io package in Java and provide a way to create a communication 
	pipe between two threads. The PipedOutputStream can be connected to a PipedInputStream, and data written to the 
	PipedOutputStream can be read from the PipedInputStream.

	 - PipedInputStream: This stream reads data written to a PipedOutputStream. It is used to create a communication channel 
	   between threads.
	 - PipedOutputStream: This stream writes data to a PipedInputStream.

	- PipedInputStream Class
	Fields:
	- byte[] buffer: The circular buffer to hold the data.
	- int in: The index one position beyond the last byte written.
	- int out: The index of the first byte to be read.
	- boolean connected: Indicates if the pipe is connected to a PipedOutputStream.

	Constructor:	
	- PipedInputStream(): Creates an unconnected pipe.
	- PipedInputStream(PipedOutputStream src): Creates a pipe connected to the specified PipedOutputStream.

	Methods:
	- read(): Reads the next byte of data from the input stream.
	- read(byte[] b, int off, int len): Reads up to len bytes of data from the input stream into an array.
	- close(): Closes the input stream and releases any system resources associated with it.
	- connect(PipedOutputStream src): Connects this PipedInputStream to a PipedOutputStream.

	- PipedOutputStream Class
	Fields:
	- PipedInputStream sink: The connected PipedInputStream.
	Constructor:
	- PipedOutputStream(): Creates an unconnected pipe.
	- PipedOutputStream(PipedInputStream snk): Creates a pipe connected to the specified PipedInputStream.

	Methods:
	- write(int b): Writes the specified byte to the output stream.
	- write(byte[] b, int off, int len): Writes len bytes from the specified byte array starting at off to this output stream.
	- close(): Closes the output stream and releases any system resources associated with it.
	- connect(PipedInputStream snk): Connects this PipedOutputStream to a PipedInputStream.

		Thread 1 (Writer)                        Thread 2 (Reader)
		==================                       ==================
		  |                                       |
		  | write(int b)                          | read()
		  |    |                                  |    |
		  |    V                                  |    V
		+-------------+    +----------------+    +-------------+
		|             |    |                |    |             |
		| PipedOutput |--->| PipedInternal  |--->| PipedInput  |
		|   Stream    |    |    Buffer      |    |   Stream    |
		|             |    |                |    |             |
		+-------------+    +----------------+    +-------------+


package fileexamples;

import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.IOException;

public class PipedStreamExample {
	public static void main(String[] args) {
		try {
			// Create piped input and output streams
			PipedOutputStream pos = new PipedOutputStream();
			PipedInputStream pis = new PipedInputStream(pos);

			// Create a thread to write data
			Thread writerThread = new Thread(() -> {
				try {
					for (int i = 0; i < 10; i++) {
						pos.write(i);
						System.out.println("Written: " + i);
						Thread.sleep(500);
					}
					pos.close();
				} catch (IOException | InterruptedException e) {
					e.printStackTrace();
				}
			});

			// Create a thread to read data
			Thread readerThread = new Thread(() -> {
				try {
					int data;
					while ((data = pis.read()) != -1) {
						System.out.println("Read: " + data);
					}
					pis.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			});

			// Start both threads
			writerThread.start();
			readerThread.start();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}



//---------------------------------------------------------------

	// Reader and Writer class in Java IO:
	// -------------------------------------

	The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and 
	OutputStream with the exception that Reader and Writer are character based. They are intended for reading and writing text.

	BufferedReader and BufferedWriter class:
	----------------------------------------

	In Java, the BufferedReader and BufferedWriter classes in the java.io package are used to efficiently read from and write 
	to character streams, respectively. They provide buffering for the I/O operations, which improves performance by reducing 
	the number of read/write operations performed directly on the underlying stream.

	- BufferedReader Class
	The BufferedReader maintains an internal buffer of 8192 characters.During the read operation in BufferedReader, a chunk 
	of characters is read from the disk and stored in the internal buffer. And from the internal buffer characters are read 
	individually. Hence, the number of communication to the disk is reduced. This is why reading characters is faster using 
	BufferedReader.

	Constructors: 
	- BufferedReader buffer = new BufferedReader(file)
	- BufferedReader buffer = new BufferedReader(file, int size)

	Methods:
	- read(): Reads a single character.
	- read(char[] cbuf, int off, int len): Reads characters into a portion of an array.
	- readLine(): Reads a line of text. A line is considered to be terminated by any one of a line feed ('\n'), 
		      a carriage return ('\r'), or a carriage return followed immediately by a line feed.
	- close(): Closes the stream and releases any system resources associated with it.


	- BufferedWriter Class
	The BufferedWriter class writes text to an output stream, buffering characters to provide efficient writing of single 
	characters, arrays, and strings. It is often wrapped around a FileWriter or OutputStreamWriter.

	Methods:
	- write(int c): Writes a single character.
	- write(char[] cbuf, int off, int len): Writes a portion of an array of characters.
	- write(String s, int off, int len): Writes a portion of a string.
	- newLine(): Writes a line separator.
	- flush(): Flushes the stream.
	- close(): Closes the stream and releases any system resources associated with it.

	By wrapping FileReader/InputStreamReader and FileWriter/OutputStreamWriter with BufferedReader and BufferedWriter, 
	you can achieve better performance in your I/O operations in Java.

package fileexamples;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CopyFileExample {
	public static void main(String[] args) {
		String inputFile = "source.txt";
		String outputFile = "destination.txt";

		try (BufferedReader br = new BufferedReader(new FileReader(inputFile));
				BufferedWriter bw = new BufferedWriter(new FileWriter(outputFile))) {
			String line;
			while ((line = br.readLine()) != null) {
				bw.write(line);
				bw.newLine();
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

//----------------------------------------------------------
package fileexamples;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class WordCountExample {
    public static void main(String[] args) {
        String filePath = "source.txt";
        int wordCount = 0;
        
        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            String line;
            while ((line = br.readLine()) != null) {
                String[] words = line.split("\\s+");
                wordCount += words.length;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        
        System.out.println("Total number of words: " + wordCount);
    }
}

//----------------------------------------------------------
package fileexamples;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class ConsoleInputExample {
	public static void main(String[] args) {
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));

		try {
			System.out.print("Enter your name: ");
			String name = reader.readLine();
			System.out.println("Hello, " + name + "!");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

//--------------------------------------------------------------

	// CharArrayReader and CharArrayWriter class

	The CharArrayReader and CharArrayWriter classes in java.io are part of Java's I/O (input/output) framework. They are 
	specifically designed for reading and writing character data from and to character arrays. 

	CharArrayReader class:
	Constructor:
	- CharArrayReader(char[] buf)
	- CharArrayReader(char[] buf, int offset, int length)

	Methods:
	- int read(): Reads a single character.
	- int read(char[] cbuf, int off, int len): Reads characters into a portion of an array.
	- boolean ready(): Tells whether the stream is ready to be read.
	- void close(): Closes the stream and releases any system resources associated with it.
	- long skip(long n): Skips the specified number of characters in the stream.
	- boolean markSupported(): Returns true if this stream supports mark/reset.
	- void mark(int readAheadLimit): Marks the current position in the stream.
	- void reset(): Resets the stream to the most recent mark.


	CharArrayWriter class:
	The CharArrayWriter class is a character stream that collects its output in a character array, which can then be 
	converted to a string or a character array.

	Constructors
	CharArrayWriter() - Creates a new CharArrayWriter with a default initial size.
	CharArrayWriter(int initialSize) - Creates a new CharArrayWriter with the specified initial size.

	Methods:
	- void write(int c): Writes a single character.
	- void write(char[] cbuf, int off, int len): Writes characters from a portion of an array.
	- void write(String str, int off, int len): Writes a portion of a string.
	- void writeTo(Writer out): Writes the contents of the buffer to another writer.
	- CharArrayWriter append(CharSequence csq): Appends a character sequence.
	- char[] toCharArray(): Returns a copy of the input data as a character array.
	- int size(): Returns the current size of the buffer.
	- void reset(): Resets the buffer so that it can be used again without throwing away the already allocated buffer.
	- String toString(): Converts the buffer's contents to a string.
	- void close(): Closes the stream.

package fileexamples;

import java.io.CharArrayReader;
import java.io.CharArrayWriter;
import java.io.IOException;

public class CharArrayReaderWriterExample {
	public static void main(String[] args) {
		// Create a CharArrayWriter instance
		CharArrayWriter charArrayWriter = new CharArrayWriter();

		// Write some data to the CharArrayWriter
		String data = "Hello, World!";
		try {
			charArrayWriter.write(data);

			// Convert the CharArrayWriter's content to a character array
			char[] charArray = charArrayWriter.toCharArray();

			// Print the character array
			System.out.println("Written to CharArrayWriter: " + new String(charArray));

			// Create a CharArrayReader to read the data from the character array
			CharArrayReader charArrayReader = new CharArrayReader(charArray);

			// Read and print the data from CharArrayReader
			int i;
			System.out.print("Read from CharArrayReader: ");
			while ((i = charArrayReader.read()) != -1) {
				System.out.print((char) i);
			}

			// Close the readers and writers
			charArrayReader.close();
			charArrayWriter.close();

		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

//----------------------------------------------------------------

	// InputStreamReader and OutputStreamWriter
	------------------------------------------

	InputStreamReader and OutputStreamWriter are part of the java.io package in Java and serve as bridges between byte streams 
	and character streams. 
		
	- InputStreamReader class:
	InputStreamReader is a subclass of Reader and is used to convert a byte stream (InputStream) into a character 
	stream (Reader). It reads bytes from an input stream and decodes them into characters using a specified charset.

	Constructor:

	- InputStreamReader(InputStream in): Creates an InputStreamReader that uses the default charset.
	- InputStreamReader(InputStream in, Charset charset): Creates an InputStreamReader that uses the specified charset.

	Methods:
	- read(): Reads a single character. Reads bytes from the underlying input stream into a byte buffer. Decodes the bytes 
	  into characters using the charset decoder. Returns the character read or -1 if the end of the stream is reached.
	- read(char[] cbuf, int offset, int length): Reads characters into a portion of an array.
	- close(): Closes the underlying input stream.

	- OutputStreamWriter class:
	OutputStreamWriter is a subclass of Writer and is used to convert a character stream (Writer) into a byte 
	stream (OutputStream). It encodes characters into bytes using a specified charset and writes them to an output stream.

	Methods:
	- write(int c): Writes a single character. Encodes the character into bytes using the charset encoder. Writes the bytes 
	  to the underlying output stream.
	- write(char[] cbuf, int offset, int length): Writes characters from a portion of an array.
	- write(String str, int offset, int length): Writes a portion of a string.
	- flush(): Flushes the stream, ensuring that all buffered characters are encoded and written to the output stream.
	- close(): Closes the underlying output stream, flushing it first.


package fileexamples;

import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.IOException;

public class InputStreamReaderExample {
    public static void main(String[] args) {
        try (InputStreamReader isr = new InputStreamReader(new FileInputStream("example.txt"), "UTF-8")) {
            int data;
            while ((data = isr.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

//----------------------------
package fileexamples;

import java.io.FileOutputStream;
import java.io.OutputStreamWriter;
import java.io.IOException;

public class OutputStreamWriterExample {
    public static void main(String[] args) {
        try (OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("output.txt"), "UTF-8")) {
            osw.write("Hello, World!");
            osw.write("\nThis is an example of OutputStreamWriter.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


//----------------------------------------------------------------------------------------------------------------------

	// FileReader and FileWriter class in java
	// --------------------------------------------

 	FileReader and FileWriter in Java, which are used for reading from and writing to files, respectively. Both classes are 
	part of the java.io package and are designed for handling character streams, making them suitable for text files.

	- FileReader class
	The FileReader class is a convenient class for reading character files. It provides a way to read the contents of a 
	file as a stream of characters.

	Constructors:
	- FileReader(String fileName): Creates a new FileReader, given the name of the file to read.
	- FileReader(File file): Creates a new FileReader, given the File object to read.
	- FileReader(FileDescriptor fd): Creates a new FileReader, given a FileDescriptor object.

	Methods:
	- int read(): Reads a single character.
	- int read(char[] cbuf, int offset, int length): Reads characters into a portion of an array.
	- boolean ready(): Tells whether this stream is ready to be read.
	- void close(): Closes the stream and releases any system resources associated with it.

	- FileWriter class
	The FileWriter class is a convenient class for writing characters to files. It provides a way to write characters to a file.

	Constructors:
	- FileWriter(String fileName): Creates a new FileWriter, given the name of the file to write to.
	- FileWriter(String fileName, boolean append): Creates a new FileWriter, given the name of the file to write to, with an option to append data to the end of the file.
	- FileWriter(File file): Creates a new FileWriter, given the File object to write to.
	- FileWriter(File file, boolean append): Creates a new FileWriter, given the File object to write to, with an option to append data.
	- FileWriter(FileDescriptor fd): Creates a new FileWriter, given a FileDescriptor object.
	
	Methods:
	- void write(int c): Writes a single character.
	- void write(char[] cbuf, int offset, int length): Writes a portion of an array of characters.
	- void write(String str, int offset, int length): Writes a portion of a string.
	- void flush(): Flushes the stream.
	- void close(): Closes the stream and releases any system resources associated with it.

package fileexamples;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class FileReaderWriterExample {
	public static void main(String[] args) {
		String fileName = "example.txt";
		String data = "Hello, World!\nThis is an example of FileReader and FileWriter.";

		// Write data to the file using FileWriter
		try (FileWriter writer = new FileWriter(fileName)) {
			writer.write(data);
			System.out.println("Data written to file: " + fileName);
		} catch (IOException e) {
			e.printStackTrace();
		}

		// Read data from the file using FileReader
		try (FileReader reader = new FileReader(fileName)) {
			int ch;
			System.out.print("Data read from file: ");
			while ((ch = reader.read()) != -1) {
				System.out.print((char) ch);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

//-------------------------------------------------------------------------------------------------------------

	// FilterReader and FilterWriter
	// -----------------------------

	FilterReader and FilterWriter are part of the java.io package and are used as abstract classes to provide a way to create 
	filtered character streams. They are subclasses of Reader and Writer respectively, and are used to read and write character 
	streams with additional filtering capabilities.

	- FilterReader class:
	The FilterReader class is an abstract class that provides a base for creating filtered reader streams. It reads from another 
	Reader, which it uses as its basic source of data, possibly transforming the input while doing so.

	Constructor:
	FilterReader(Reader in): Creates a new filtered reader with the specified underlying reader.

	Methods:
	- int read(): Reads a single character.
	- int read(char[] cbuf, int off, int len): Reads characters into a portion of an array.
	- boolean ready(): Tells whether this stream is ready to be read.
	- void close(): Closes the stream and releases any system resources associated with it.

	- FilterWriter
	The FilterWriter class is an abstract class that provides a base for creating filtered writer streams. It writes to 
	another Writer, which it uses as its basic sink of data, possibly transforming the output while doing so.

	Constructor:
	- FilterWriter(Writer out): Creates a new filtered writer with the specified underlying writer.

	Methods:
	- void write(int c): Writes a single character.
	- void write(char[] cbuf, int off, int len): Writes characters from a portion of an array.
	- void write(String str, int off, int len): Writes a portion of a string.
	- void flush(): Flushes the stream.
	- void close(): Closes the stream and releases any system resources associated with it.

//---------------------------------------------------------------------

	// Some addiotional classes

	- RandomAccessFile: Allows reading and writing to any position within a file.
	- FileDescriptor: Represents the handle to the underlying machine-specific file structure.
	- FilePermission: Represents access rights to a file or directory, used for enforcing security policies.


	- RandomAccessFile class:
		The RandomAccessFile class in Java provides both reading and writing capabilities to files and allows you to move 
		the file pointer to any position within the file. This enables non-sequential (random) access, unlike the 
		traditional sequential access provided by streams. The RandomAccessFile class is part of the java.io package. It 
		implements the DataInput and DataOutput interfaces, which provide methods to read and write primitive data types. 
		This makes RandomAccessFile suitable for working with binary files as well as text files.

	Constructors:
	- RandomAccessFile(String name, String mode): Opens a file with the specified name and mode.
	- RandomAccessFile(File file, String mode): Opens a file represented by a File object and mode.

	The mode parameter can be:
		- "r": Open for reading only.
		- "rw": Open for reading and writing.
		- "rws": Open for reading and writing, with every update to the file’s content or metadata immediately 
			 written to the storage device.
		- "rwd": Open for reading and writing, with every update to the file’s content immediately written to the 
			 storage device.

	Methods
	- read(): Reads a byte of data from the file.
	- read(byte[] b): Reads data into a byte array.
	- readInt(), readLong(), readDouble(), etc.: Read different types of primitive data.

	- write(int b): Writes a byte of data to the file.
	- write(byte[] b): Writes data from a byte array.
	- writeInt(int v), writeLong(long v), writeDouble(double v), etc.: Write different types of primitive data.

	- seek(long pos): Sets the file pointer to the specified position.
	- getFilePointer(): Returns the current position of the file pointer.
	- length(): Returns the length of the file.
	- setLength(long newLength): Sets the length of the file.
	
package fileexamples;
import java.io.RandomAccessFile;
import java.io.IOException;

public class RandomAccessFileExample {
    public static void main(String[] args) {
        try {
            // Create a RandomAccessFile instance in "rw" (read/write) mode
            RandomAccessFile file = new RandomAccessFile("source.txt", "rw");

            // Write data to the file
            file.writeUTF("Hello, RandomAccessFile!");
            file.writeInt(12345);

            // Move the file pointer to the beginning
            file.seek(0);

            // Read data from the file
            String str = file.readUTF();
            int num = file.readInt();

            System.out.println("Read from file: " + str + ", " + num);

            // Move the file pointer to the beginning again
            file.seek(0);

            // Write new data, overwriting the old data
            file.writeUTF("Updated text");
            
            // Set the file length to truncate the file
            file.setLength(file.getFilePointer());

            // Move the file pointer to the beginning
            file.seek(0);

            // Read the updated data
            str = file.readUTF();

            System.out.println("Read after update: " + str);

            // Close the file
            file.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

//--------------------------------------------------------------------------------------------------------------------------------

	/// CRUD APPLICATION USING FILE AND COMMAND LINE INTERFACE - MINI PROJECT

package fileexamples;
import java.io.Serializable;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.io.IOException;
import java.util.Scanner;
class Item implements Serializable {
    private static final long serialVersionUID = 1L;
    private int id;
    private String name;

    public Item(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Item{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}


class FileUtil {
    private static final String FILE_NAME = "items.txt";

    public static void saveItems(List<Item> items) throws IOException {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_NAME))) {
            oos.writeObject(items);
        }
    }

    public static List<Item> loadItems() throws IOException, ClassNotFoundException {
        File file = new File(FILE_NAME);
        if (!file.exists()) {
            return new ArrayList<>();
        }
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) {
            return (List<Item>) ois.readObject();
        }
    }
}

public class CRUDApplication {
    public static void main(String[] args) {
        try {
            List<Item> items = FileUtil.loadItems();
            Scanner scanner = new Scanner(System.in);
            boolean running = true;

            while (running) {
                System.out.println("Choose an operation: create, read, update, delete, exit");
                String operation = scanner.nextLine();

                switch (operation.toLowerCase()) {
                    case "create":
                        createItem(scanner, items);
                        break;
                    case "read":
                        readItems(items);
                        break;
                    case "update":
                        updateItem(scanner, items);
                        break;
                    case "delete":
                        deleteItem(scanner, items);
                        break;
                    case "exit":
                        running = false;
                        break;
                    default:
                        System.out.println("Invalid operation");
                }
                FileUtil.saveItems(items);
            }
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }

    private static void createItem(Scanner scanner, List<Item> items) {
        System.out.println("Enter item id:");
        int id = Integer.parseInt(scanner.nextLine());
        System.out.println("Enter item name:");
        String name = scanner.nextLine();
        items.add(new Item(id, name));
        System.out.println("Item created.");
    }

    private static void readItems(List<Item> items) {
        if (items.isEmpty()) {
            System.out.println("No items found.");
        } else {
            for (Item item : items) {
                System.out.println(item);
            }
        }
    }

    private static void updateItem(Scanner scanner, List<Item> items) {
        System.out.println("Enter item id to update:");
        int id = Integer.parseInt(scanner.nextLine());
        for (Item item : items) {
            if (item.getId() == id) {
                System.out.println("Enter new item name:");
                String newName = scanner.nextLine();
                item.setName(newName);
                System.out.println("Item updated.");
                return;
            }
        }
        System.out.println("Item not found.");
    }

    private static void deleteItem(Scanner scanner, List<Item> items) {
        System.out.println("Enter item id to delete:");
        int id = Integer.parseInt(scanner.nextLine());
        items.removeIf(item -> item.getId() == id);
        System.out.println("Item deleted.");
    }
}

//---------------------------------------------------------------------------------------------------------------------------------

	// NIO (New Input/Output)
	//---------------------------

	In Java, blocking I/O and non-blocking I/O are key concepts for handling input and output operations, particularly in the 
	context of network communications and file operations. 

	In blocking I/O is the traditional and straightforward way of handling I/O operations. When a thread performs a blocking 
	I/O operation, it is suspended until the operation completes. During this period, the thread is idle and cannot perform 
	any other tasks.

	The Non-blocking I/O allows a thread to initiate an I/O operation and continue executing other tasks before the I/O operation 
	completes. This is particularly useful in applications requiring high concurrency and performance, such as web servers and 
	real-time systems.

			Blocking I/O (java.io)			Non-Blocking I/O (java.nio)

	available After I/O operation completes	    available Immediately after initiating I/O operation
	Less efficient (threads may be idle)	    More efficient (threads can do other work)
	Easier to implement and understand	    More complex to implement
	efficiency Limited, as threads are blocked  efficiency High, as multiple I/O operations can be handled concurrently

	The java.nio Package: Java provides the java.nio (New I/O) package, which includes classes for non-blocking I/O. It was 
	introduced in Java 1.4 and provides a more efficient and scalable way to handle IO operations compared to the traditional 
	IO API (java.io package). With NIO, IO operations can be performed in a non-blocking manner, allowing a thread to continue 
	processing other tasks while waiting for IO operations to complete.

	There are three key terms in NIO

	- Buffers: NIO uses buffers to read and write data. A buffer is essentially a block of memory into which data can be read 
	  and from which data can be written. Traditional IO Uses streams for reading and writing data. A stream reads or writes 
	  one byte at a time, which can be less efficient.

	- Channels: Channels are analogous to streams in traditional IO, but they are bi-directional. A channel can be used for 
	  reading, writing, or both. Channels provide a direct connection to the underlying data source, such as a file or a network 
	  socket. Traditional IO Uses input and output streams to read and write data.

	- Selectors: Selectors allow a single thread to monitor multiple channels for events, such as data arriving (read event) 
	  or ready to be written (write event). means NIO introduces selectors, which allow a single thread to manage multiple 
	  channels. This non-blocking approach enables the thread to continue processing other tasks while waiting for IO operations 
	  to complete.
	

	Buffers in Java NIO
	--------------------
	Buffers are a fundamental component of the Java NIO (New Input/Output) library. They provide a mechanism for handling data 
	in memory and are used in conjunction with channels for reading and writing data. Buffers simplify the process of moving 
	data between the application's memory and an external data source or sink, such as a file or a network socket.

	Each buffer has three main properties:

	- Capacity: The maximum amount of data the buffer can hold.
	- Limit: The limit up to which data can be read or written.
	- Position: The index of the next element to be read or written.

	Types of Buffers: Java NIO provides several types of buffers for different data types

	- ByteBuffer: For handling byte data.
	- CharBuffer: For handling character data.
	- ShortBuffer: For handling short integer data.
	- IntBuffer: For handling integer data.
	- LongBuffer: For handling long integer data.
	- FloatBuffer: For handling floating-point data.
	- DoubleBuffer: For handling double-precision floating-point data.

	Buffer Allocation: 

	- ByteBuffer buffer = ByteBuffer.allocate(1024) - Buffers are allocated using factory methods provided by the 
							   buffer classes. 
	- ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024) -  Direct buffers can be faster for IO operations since they 
								       can be passed directly to native OS functions, bypassing the 
								       Java heap.

	Buffer Methods:

	- position(): Returns or sets the buffer's position.
	- limit(): Returns or sets the buffer's limit.
	- capacity(): Returns the buffer's capacity.
	- mark() and reset(): Allows you to mark a particular position in the buffer and reset the position to this mark later.

	- clear(): Clear the buffer to prepare it for writing.
	- put(data): Put data into the buffer.
	- flip(): Flip the buffer to prepare it for reading.
	- rewind(): Rewinds the buffer to the beginning.
	- compact(): Compacts the buffer, moving any remaining data to the beginning of the buffer.

package fileexamples;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class NIOExample {
    public static void main(String[] args) {
        Path path = Paths.get("example.txt");

        // Write to a file using NIO
        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE)) {
            String data = "Hello, From NIO!";
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            buffer.put(data.getBytes());
            buffer.flip();
            fileChannel.write(buffer);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Read from a file using NIO
        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ)) {
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            int bytesRead = fileChannel.read(buffer);
            buffer.flip();
            byte[] bytes = new byte[bytesRead];
            buffer.get(bytes);
            System.out.println(new String(bytes));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

	// Channels in Java NIO
	// -----------------------

	Channels are a core component of the Java NIO (New Input/Output) library. They represent connections to input/output sources 
	or destinations, such as files, network sockets, or other channels. Channels provide a more flexible and efficient way to 
	perform IO operations compared to the traditional stream-based IO provided by java.io.

	- Channels provide a bi-directional flow of data, meaning they can be used for both reading and writing.
	- Channels are typically used in conjunction with buffers, where data is read from or written to the channel via buffers.

	Types of Channels: Java NIO provides several types of channels to suit different IO scenarios

	- FileChannel: Used for reading, writing, and manipulating files.
	- SocketChannel: Used for client-side and server-side TCP socket communication.
	- ServerSocketChannel: Used for server-side TCP socket communication.
	- DatagramChannel: Used for UDP (User Datagram Protocol) communication.

	Creating and Opening Channels

	- FileChannel fileChannel = FileChannel.open(Paths.get("file.txt"), StandardOpenOption.READ);
	- SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress("example.com", 8080));
	- ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

package fileexamples;

import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;

public class FileChannelExample {
	public static void main(String[] args) {
		try (RandomAccessFile file = new RandomAccessFile("example.txt", "r");
				FileChannel channel = file.getChannel()) {

			ByteBuffer buffer = ByteBuffer.allocate(48);
			int bytesRead = channel.read(buffer);

			while (bytesRead != -1) {
				buffer.flip();
				while (buffer.hasRemaining()) {
					System.out.print((char) buffer.get());
				}
				buffer.clear();
				bytesRead = channel.read(buffer);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
//-------------------------------------------------------------------------------------------------------
	
	// Selectors in Java NIO
	// ------------------------

	Selectors are a key component in Java NIO that enable non-blocking I/O operations, allowing a single 
	thread to manage multiple channels. This can significantly enhance the performance and scalability of 
	I/O-intensive applications.

	In Java NIO, selectors are primarily designed to work with network channels, such as SocketChannel, 
	ServerSocketChannel, and DatagramChannel. They are used to handle non-blocking I/O operations for 
	these network channels efficiently. Selectors are not intended to be used with file channels
	(FileChannel), as file I/O operations are typically blocking by nature and do not fit the event-driven 
	model that selectors provide.

	Why Selectors Are Not Used with File Channels?
	 - Nature of File I/O: File I/O operations are inherently blocking. When you read from or write to a file,
	the operation typically blocks until it completes. This behavior does not align with the non-blocking, 
	event-driven model that selectors support.

	- Selector Design: Selectors are designed to handle network events like connection requests, readiness 
	for reading or writing data, etc. These events are not applicable to file I/O, which does not generate 
	such asynchronous events.

	- Alternative for Asynchronous File I/O
	While you can't use selectors with file channels, Java NIO.2 (introduced in Java 7) provides an 
	alternative for asynchronous file operations: AsynchronousFileChannel. This class supports asynchronous 
	read and write operations, allowing you to perform non-blocking file I/O using callbacks or futures.

	// Charsets:
	// ----------
	Charsets in Java NIO are essential for encoding and decoding character data. They enable conversion 
	between bytes and characters, supporting a wide range of character sets. The Charset, CharsetEncoder, 
	and CharsetDecoder classes, along with the StandardCharsets utility class, provide a comprehensive API 
	for working with different character encodings. Understanding and correctly handling charsets is 
	crucial for building robust I/O operations, especially in applications that deal with multiple 
	languages and character sets.

	// Scattering and Gathering in Java NIO
	Scattering and Gathering are two key concepts in Java NIO that deal with the way data is read from and 
	written to channels. These concepts are particularly useful when dealing with protocols or file formats 
	that have a fixed structure.

	- Scattering reads refer to reading data from a single channel into multiple buffers. This is useful 
	when you want to split the read data into distinct parts. For example, you might want to separate a 
	header from a body in a network protocol.
		Scattering reads with a FileChannel involve reading data from a file into multiple buffers in 
	a single read operation. This is useful when the file data is structured in a way that different parts 
	should be processed separately.

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class ScatteringReadFileExample {
    public static void main(String[] args) {
        Path path = Paths.get("example.txt");

        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ)) {
            ByteBuffer header = ByteBuffer.allocate(128);
            ByteBuffer body = ByteBuffer.allocate(1024);
            ByteBuffer[] buffers = {header, body};

            fileChannel.read(buffers);

            header.flip();
            body.flip();

            System.out.println("Header: " + new String(header.array(), 0, header.limit()));
            System.out.println("Body: " + new String(body.array(), 0, body.limit()));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


	- Gathering writes refer to writing data from multiple buffers into a single channel. This is useful 
	when you have distinct parts of data that you want to send as a single unit. For example, you might 
	want to send a header and a body together in a network protocol.
		Gathering writes with a FileChannel involve writing data from multiple buffers to a file in a 
	single write operation. This is useful when you want to combine different parts of data and write them 
	to a file together.

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class GatheringWriteFileExample {
    public static void main(String[] args) {
        Path path = Paths.get("example.txt");

        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE)) {
            ByteBuffer header = ByteBuffer.wrap("Header information".getBytes());
            ByteBuffer body = ByteBuffer.wrap("Body of the file content".getBytes());
            ByteBuffer[] buffers = {header, body};

            fileChannel.write(buffers);

            System.out.println("Data written to the file.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

     - Use Cases and Benefits
	Use Cases for Scattering Reads
	- Structured Data Files: Files where data is split into fixed sections, such as file headers, metadata,
	  and body content.
	- Log Files: Reading log files where each entry consists of a fixed-size timestamp and a variable-size 
	  message.

     - Use Cases for Gathering Writes
	- Combining Data Sections: Writing structured data to a file where different sections (like headers 
	  and body content) are combined.
	- Batch Writes: Efficiently writing multiple data segments in one operation to reduce I/O overhead.



	// File Locking in Java NIO
	// ---------------------------

	File locking is a mechanism that prevents multiple processes from accessing a file concurrently, 
	which can help avoid data corruption or inconsistencies. Java NIO provides support for file locking 
	through the FileChannel class.

	Java NIO supports two types of file locks:

	- Shared Lock (Read Lock): Multiple processes can hold shared locks on a file, allowing them to read 
	  from it simultaneously. However, no process can write to the file while a shared lock is held.

	- Exclusive Lock (Write Lock): Only one process can hold an exclusive lock on a file, preventing both 
	  read and write access by other processes.

	File Locking API - 
	The main methods related to file locking in FileChannel are:

	- lock(): Acquires an exclusive lock on the file.
	- lock(long position, long size, boolean shared): Acquires a lock on a specific region of the file. 
	  The shared parameter specifies whether the lock is shared.
	- tryLock(): Attempts to acquire an exclusive lock on the file without blocking.
	- tryLock(long position, long size, boolean shared): Attempts to acquire a lock on a specific region 
	  of the file without blocking.

	Locks are represented by the FileLock class, which provides methods to check the lock status and 
	release the lock.

package fileexamples;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class ExclusiveFileLockExample {
	public static void main(String[] args) {
		Path path = Paths.get("example.txt");

		try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE)) {
			// Acquire an exclusive lock on the file
			FileLock lock = fileChannel.lock();

			System.out.println("File is locked.");

			// Write data to the file while holding the lock
			ByteBuffer buffer = ByteBuffer.wrap("This is some test data.".getBytes());
			fileChannel.write(buffer);

			// Release the lock
			lock.release();

			System.out.println("File lock released.");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}


package fileexamples;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class SharedFileLockExample {
    public static void main(String[] args) {
        Path path = Paths.get("example.txt");

        try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ)) {
            // Acquire a shared lock on the file
            FileLock lock = fileChannel.lock(0, Long.MAX_VALUE, true);

            System.out.println("File is locked.");

            // Read data from the file while holding the lock
            ByteBuffer buffer = ByteBuffer.allocate(1024);
            fileChannel.read(buffer);

            buffer.flip();
            byte[] data = new byte[buffer.limit()];
            buffer.get(data);

            System.out.println("Read data: " + new String(data));

            // Release the lock
            lock.release();

            System.out.println("File lock released.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

- Exclusive Lock:
  - Acquired using lock() or tryLock().
  - Ensures that no other process can read or write to the file.
  - Used when you need complete control over the file for operations like writing or updating.

- Shared Lock:
  - Acquired using lock(long position, long size, boolean shared) or tryLock(long position, long size, boolean shared) with shared set to true.
  - Allows multiple processes to read from the file concurrently but prevents writing.
  - Used when you want to allow concurrent read access while preventing modifications.

// Region Locking
// -----------------
    Java NIO also allows locking specific regions of a file, which can be useful for large files where 
    different processes need access to different parts of the file.

package fileexamples;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class RegionFileLockExample {
	public static void main(String[] args) {
		Path path = Paths.get("example.txt");

		try (FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE, StandardOpenOption.CREATE)) {
			// Acquire an exclusive lock on a region of the file
			FileLock lock = fileChannel.lock(0, 50, false);

			System.out.println("File region is locked.");

			// Write data to the locked region of the file
			ByteBuffer buffer = ByteBuffer.wrap("This is some test data for a specific region.".getBytes());
			fileChannel.write(buffer);

			// Release the lock
			lock.release();

			System.out.println("File region lock released.");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

//=================================================================================================================================
//=================================================================================================================================

	// User Interface: 

	User interface is actually a program used by the user of application which acts as a medium to transfer the command to 
	program for the execution start and it is also used to represent the output given by the program to the user.

	we have used unknowing an interface and we must use some other advanced interfaces which are as listed below.
		
	- Command Line Interface (CLI): Dos styled textbased black and white user interface, used some commands for the interaction.
	- Graphical User Interface (GUI): Pictorial interface generally provides point-and-click interaction, or operated using
	  some keyboard shortcuts.

		Generaly there are two types of appocations

			- Stand-Alone Applications: CLI(Java SE provides default JSL) -> GUI (AWT -> Swing )
			- Networked/web Applications: Networked app using CLI (java.net) -> Networked app using GUI -> Applets 
					web(client-server) -> Servlets/jsp -> .... spring/spring boot 

	The Java programming language class library provides a user interface toolkit called the Abstract Windowing Toolkit,
	or the AWT. 

	What is a user interface
	
	The user interface is that part of a program that interacts with the user of the program. User interfaces take many forms. 
	These forms range in complexity from simple command-line interfaces to the point-and-click graphical user interfaces provided 
	by many modern applications.
	
	AWT is a platform-independent. The AWT was designed to provide a common set of tools for graphical user interface design that 
	work on a variety of platforms. The user interface elements provided by the AWT are implemented using each platform's native 
	GUI toolkit, thereby preserving the look and feel of each platform. This is one of the AWT's strongest points. The 
	disadvantage of such an approach is the fact that a graphical user interface designed on one platform may look different 
	when displayed on another platform. 

	Components and containers

	A graphical user interface is built of graphical elements called components. Typical components include such items as 
	buttons, scrollbars, and text fields. Components allow the user to interact with the program and provide the user with 
	visual feedback about the state of the program. In the AWT, all user interface components are instances of class Component 
	or one of its subtypes. 
	Components do not stand alone, but rather are found within containers. Containers contain and control the layout of 
	components. Containers are themselves components, and can thus be placed inside other containers. In the AWT, all containers
	are instances of class Container or one of its subtypes

	Types of containers

	The AWT provides four container classes. They are class Window and its two subtypes -- class Frame and class Dialog -- as 
	well as the Panel class. In addition to the containers provided by the AWT, the Applet class is a container -- it is a 
	subtype of the Panel class and can therefore hold components. Brief descriptions of each container class provided by the 
	AWT are provided below

	Component:
	At the top of the AWT hierarchy is the Component class. Component is an abstract class that encapsulates all of the attributes
	of a visual component. All user interface elements that are displayed on the screen and that interact with the user are 
	subclasses of Component. It defines over a hundred public methods that are responsible for managing events, such as mouse 
	and keyboard input, positioning and sizing the window, and repainting. A Component object is responsible for remembering 
	the current foreground and background colors and the currently selected text font.

	Container:
	The Container class is a subclass of Component. It has additional methods that allow other Component objects to be nested
	within it. Other Container objects can be stored inside of a Container (since they are themselves instances of Component). 
	This makes for a multileveled containment system. A container is responsible for laying out (that is, positioning) any 
	components that it contains.

	Panel
	A generic container for holding components. An instance of the Panel class provides a container to which to add components. 
	The Panel class is a concrete subclass of Container. It doesn’t add any new methods; it simply implements Container. Panel is 
	the super class for Applet. When screen output is directed to an applet, it is drawn on the surface of a Panel object. In 
	essence, a Panel is a window that does not contain a title bar, menu bar, or border

	Window
	A top-level display surface (a window). An instance of the Window class is not attached to nor embedded within another 	
	container. An instance of the Window class has no border and no title Generally, you won’t create Window objects directly. 		
	Instead, you will use a subclass of Window called Frame

	Frame
	It is a subclass of Window and has a title bar, menu bar, borders, and resizing corners. It very much like an instance of 
	the Window class. 

	Dialog
	A top-level display surface (a window) with a border and title. An instance of the Dialog class cannot exist without an 
	associated instance of the Frame class. 

//------------------------------------------------------------------------------------------------

	// Interactive components in java.awt

	- Button: A push button.
	- Checkbox: A check box component.
	- CheckboxGroup: A group of checkboxes in which only one checkbox at a time can be selected.
	- Choice: A pop-up list of choices.
	- *Dialog: A top-level window with a title and a border.
	- *FileDialog: A dialog window from which the user can select a file.
	- Frame: A top-level window with a title and a border.
	- Label: A component for placing text in a container.(passive)
	- List: A component that allows the user to select one or more items from a list.
	- Scrollbar: A component that represents a scroll bar.
	- TextArea: A multi-line area to display/edit text.
	- TextField: A single-line text field.
	- MenuComponent: The superclass for all menu-related components.
		- MenuBar: A menu bar to hold menus.
		- Menu: A pull-down menu.
		- MenuItem: An item in a menu.
//-------------------------------------------------------------------------------------------------

	// Working with Frame Windows

	A class Frame is used to create child windows within applets, and top-level or child windows for applications.
	It having constructors:
		Frame( )
		Frame(String title)
	Methods:
	Setting the Window’s Dimensions
		void setSize(int newWidth, int newHeight)
		void setSize(Dimension newSize)
		Dimension getSize( )
	Hiding and Showing a Window
		void setVisible(boolean visibleFlag)
		void setTitle(String newTitle)
	Setting a Window’s Title
		void setTitle(String newTitle)

 // Program to create the simpe window

import java.awt.*;
class DemoWindow 
{
	public static void main(String[] args) 
	{
		Frame f=new Frame("First Frame Example");
		f.setSize(400,300);
		f.setVisible(true);
	}
}

//----------------------------------------------------------------------------------------------------------------

	// We know Frame is a container, which is used to place the interactive components.
	
	lets see how..??


import java.awt.*;
import java.awt.event.*;
class MyFrame extends Frame implements ActionListener
{
	Button b1,b2,b3;
	public MyFrame()
	{
		super("First Frame Example");
		setSize(400,300);
		setLayout(new FlowLayout());

		b1=new Button("Red");
		b1.addActionListener(this);

		b2=new Button("Green");
		b2.addActionListener(this);

		b3=new Button("Blue");
		b3.addActionListener(this);

		add(b1);
		add(b2);
		add(b3);
	}
	public void actionPerformed(ActionEvent e)
	{
		String str=((Button)e.getSource()).getLabel();
		System.out.println(str+" Button pressed");
	}
}
class DemoWindow 
{
	public static void main(String[] args) 
	{
		MyFrame mf=new MyFrame();
		mf.setVisible(true);
	}
}

//----------------------------------------------------------------------------------------

// using seperate eventhandler class

import java.awt.*;
import java.awt.event.*;
class MyActionListener implements ActionListener
{
	public void actionPerformed(ActionEvent e)
	{
		String str=((Button)e.getSource()).getLabel();
		System.out.println(str+" Button pressed");
	}
}
class MyFrame extends Frame 
{
	Button b1,b2,b3;
	public MyFrame()
	{
		super("First Frame Example");
		setSize(400,300);
		setLayout(new FlowLayout());

		b1=new Button("Red");
		b1.addActionListener(new MyActionListener());

		b2=new Button("Green");
		b2.addActionListener(new MyActionListener());

		b3=new Button("Blue");
		b3.addActionListener(new MyActionListener());

		add(b1);
		add(b2);
		add(b3);
	}
}
class DemoWindow1
{
	public static void main(String[] args) 
	{
		MyFrame mf=new MyFrame();
		mf.setVisible(true);
	}
}

//------------------------------------------------------------------------------------------------


// Event handlilng using anonymous inner class

import java.awt.*;
import java.awt.event.*;
class MyFrame extends Frame 
{
	Button b1,b2,b3;
	public MyFrame()
	{
		super("First Frame Example");
		setSize(400,300);
		setLayout(new FlowLayout());

		b1=new Button("Red");
		b1.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e)
			{
				String str=((Button)e.getSource()).getLabel();
				System.out.println(str+" Button pressed");
			}	
		});

		b2=new Button("Green");
		b2.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e)
			{
				String str=((Button)e.getSource()).getLabel();
				System.out.println(str+" Button pressed");
			}	
		});

		b3=new Button("Blue");
		b3.addActionListener(new ActionListener(){
			public void actionPerformed(ActionEvent e)
			{
				String str=((Button)e.getSource()).getLabel();
				System.out.println(str+" Button pressed");
			}	
		});

		add(b1);
		add(b2);
		add(b3);
	}
}
class DemoWindow2
{
	public static void main(String[] args) 
	{
		MyFrame mf=new MyFrame();
		mf.setVisible(true);
	}
}

//----------------------------------------------------------------------------------------------------------------

 comprehensive table that lists all AWT components along with their events and corresponding event names:

Component		Event			Event Name

Component		ComponentEvent		componentResized, componentMoved, componentShown, componentHidden
			FocusEvent		focusGained, focusLost
			KeyEvent		keyPressed, keyReleased, keyTyped
			MouseEvent		mouseClicked, mousePressed, mouseReleased, mouseEntered, mouseExited
			MouseMotionEvent	mouseMoved, mouseDragged
			MouseWheelEvent		mouseWheelMoved
Container		ContainerEvent		componentAdded, componentRemoved
Button			ActionEvent		actionPerformed
Canvas			Same as Component	Same as Component
Checkbox		ItemEvent		itemStateChanged
Choice			ItemEvent		itemStateChanged
Label			Same as Component	Same as Component
List			ActionEvent		actionPerformed
			ItemEvent		itemStateChanged
Scrollbar		AdjustmentEvent		adjustmentValueChanged
ScrollPane		Same as Component	Same as Component
TextComponent		TextEvent		textValueChanged
			FocusEvent		focusGained, focusLost
			KeyEvent		keyPressed, keyReleased, keyTyped
			MouseEvent		mouseClicked, mousePressed, mouseReleased, mouseEntered, mouseExited
			MouseMotionEvent	mouseMoved, mouseDragged
TextField		ActionEvent		actionPerformed
TextArea		Same as TextComponent	Same as TextComponent
Window			WindowEvent		windowOpened, windowClosing, windowClosed, windowIconified, windowDeiconified, 								windowActivated, windowDeactivated
			FocusEvent		focusGained, focusLost
			KeyEvent		keyPressed, keyReleased, keyTyped
			MouseEvent		mouseClicked, mousePressed, mouseReleased, mouseEntered, mouseExited
			MouseMotionEvent	mouseMoved, mouseDragged
			MouseWheelEvent		mouseWheelMoved
Frame			Same as Window		Same as Window
Dialog			Same as Window		Same as Window
FileDialog		Same as Dialog		Same as Dialog
MenuComponent		ActionEvent		actionPerformed
			ItemEvent		itemStateChanged
MenuBar			Same as MenuComponent	Same as MenuComponent
Menu			Same as MenuComponent	Same as MenuComponent
MenuItem		ActionEvent		actionPerformed
CheckboxMenuItem	ItemEvent		itemStateChanged
PopupMenu		Same as MenuComponent	Same as MenuComponent

//-------------------------------------------------------------------------------------------------------------------

// Table listing all AWT components, their events, corresponding event names, and when each event is generated:

Component: Component
Event: ComponentEvent
Event Name: componentResized
When Event is Generated: When the component is resized

Component: Component
Event: ComponentEvent
Event Name: componentMoved
When Event is Generated: When the component is moved

Component: Component
Event: ComponentEvent
Event Name: componentShown
When Event is Generated: When the component is shown

Component: Component
Event: ComponentEvent
Event Name: componentHidden
When Event is Generated: When the component is hidden

Component: Component
Event: FocusEvent
Event Name: focusGained
When Event is Generated: When the component gains focus

Component: Component
Event: FocusEvent
Event Name: focusLost
When Event is Generated: When the component loses focus

Component: Component
Event: KeyEvent
Event Name: keyPressed
When Event is Generated: When a key is pressed

Component: Component
Event: KeyEvent
Event Name: keyReleased
When Event is Generated: When a key is released

Component: Component
Event: KeyEvent
Event Name: keyTyped
When Event is Generated: When a key is typed

Component: Component
Event: MouseEvent
Event Name: mouseClicked
When Event is Generated: When the mouse is clicked

Component: Component
Event: MouseEvent
Event Name: mousePressed
When Event is Generated: When a mouse button is pressed

Component: Component
Event: MouseEvent
Event Name: mouseReleased
When Event is Generated: When a mouse button is released

Component: Component
Event: MouseEvent
Event Name: mouseEntered
When Event is Generated: When the mouse enters the component

Component: Component
Event: MouseEvent
Event Name: mouseExited
When Event is Generated: When the mouse exits the component

Component: Component
Event: MouseMotionEvent
Event Name: mouseMoved
When Event is Generated: When the mouse is moved

Component: Component
Event: MouseMotionEvent
Event Name: mouseDragged
When Event is Generated: When the mouse is dragged

Component: Component
Event: MouseWheelEvent
Event Name: mouseWheelMoved
When Event is Generated: When the mouse wheel is moved

Component: Container
Event: ContainerEvent
Event Name: componentAdded
When Event is Generated: When a component is added to the container

Component: Container
Event: ContainerEvent
Event Name: componentRemoved
When Event is Generated: When a component is removed from the container

Component: Button
Event: ActionEvent
Event Name: actionPerformed
When Event is Generated: When the button is clicked

Component: Canvas
Event: Same as Component
Event Name: Same as Component
When Event is Generated: Same as Component

Component: Checkbox
Event: ItemEvent
Event Name: itemStateChanged
When Event is Generated: When the state of the checkbox is changed

Component: Choice
Event: ItemEvent
Event Name: itemStateChanged
When Event is Generated: When an item is selected or deselected

Component: Label
Event: Same as Component
Event Name: Same as Component
When Event is Generated: Same as Component

Component: List
Event: ActionEvent
Event Name: actionPerformed
When Event is Generated: When an item is double-clicked or Enter is pressed

Component: List
Event: ItemEvent
Event Name: itemStateChanged
When Event is Generated: When an item is selected or deselected

Component: Scrollbar
Event: AdjustmentEvent
Event Name: adjustmentValueChanged
When Event is Generated: When the scrollbar value is changed

Component: ScrollPane
Event: Same as Component
Event Name: Same as Component
When Event is Generated: Same as Component

Component: TextComponent
Event: TextEvent
Event Name: textValueChanged
When Event is Generated: When the text value is changed

Component: TextComponent
Event: FocusEvent
Event Name: focusGained
When Event is Generated: When the component gains focus

Component: TextComponent
Event: FocusEvent
Event Name: focusLost
When Event is Generated: When the component loses focus

Component: TextComponent
Event: KeyEvent
Event Name: keyPressed
When Event is Generated: When a key is pressed

Component: TextComponent
Event: KeyEvent
Event Name: keyReleased
When Event is Generated: When a key is released

Component: TextComponent
Event: KeyEvent
Event Name: keyTyped
When Event is Generated: When a key is typed

Component: TextComponent
Event: MouseEvent
Event Name: mouseClicked
When Event is Generated: When the mouse is clicked

Component: TextComponent
Event: MouseEvent
Event Name: mousePressed
When Event is Generated: When a mouse button is pressed

Component: TextComponent
Event: MouseEvent
Event Name: mouseReleased
When Event is Generated: When a mouse button is released

Component: TextComponent
Event: MouseEvent
Event Name: mouseEntered
When Event is Generated: When the mouse enters the component

Component: TextComponent
Event: MouseEvent
Event Name: mouseExited
When Event is Generated: When the mouse exits the component

Component: TextComponent
Event: MouseMotionEvent
Event Name: mouseMoved
When Event is Generated: When the mouse is moved

Component: TextComponent
Event: MouseMotionEvent
Event Name: mouseDragged
When Event is Generated: When the mouse is dragged

Component: TextField
Event: ActionEvent
Event Name: actionPerformed
When Event is Generated: When the Enter key is pressed

Component: TextArea
Event: Same as TextComponent
Event Name: Same as TextComponent
When Event is Generated: Same as TextComponent

Component: Window
Event: WindowEvent
Event Name: windowOpened
When Event is Generated: When the window is opened

Component: Window
Event: WindowEvent
Event Name: windowClosing
When Event is Generated: When the user attempts to close the window

Component: Window
Event: WindowEvent
Event Name: windowClosed
When Event is Generated: When the window is closed

Component: Window
Event: WindowEvent
Event Name: windowIconified
When Event is Generated: When the window is minimized

Component: Window
Event: WindowEvent
Event Name: windowDeiconified
When Event is Generated: When the window is restored from being minimized

Component: Window
Event: WindowEvent
Event Name: windowActivated
When Event is Generated: When the window is activated

Component: Window
Event: WindowEvent
Event Name: windowDeactivated
When Event is Generated: When the window is deactivated

Component: Window
Event: FocusEvent
Event Name: focusGained
When Event is Generated: When the window gains focus

Component: Window
Event: FocusEvent
Event Name: focusLost
When Event is Generated: When the window loses focus

Component: Window
Event: KeyEvent
Event Name: keyPressed
When Event is Generated: When a key is pressed

Component: Window
Event: KeyEvent
Event Name: keyReleased
When Event is Generated: When a key is released

Component: Window
Event: KeyEvent
Event Name: keyTyped
When Event is Generated: When a key is typed

Component: Window
Event: MouseEvent
Event Name: mouseClicked
When Event is Generated: When the mouse is clicked

Component: Window
Event: MouseEvent
Event Name: mousePressed
When Event is Generated: When a mouse button is pressed

Component: Window
Event: MouseEvent
Event Name: mouseReleased
When Event is Generated: When a mouse button is released

Component: Window
Event: MouseEvent
Event Name: mouseEntered
When Event is Generated: When the mouse enters the window

Component: Window
Event: MouseEvent
Event Name: mouseExited
When Event is Generated: When the mouse exits the window

Component: Window
Event: MouseMotionEvent
Event Name: mouseMoved
When Event is Generated: When the mouse is moved

Component: Window
Event: MouseMotionEvent
Event Name: mouseDragged
When Event is Generated: When the mouse is dragged

Component: Window
Event: MouseWheelEvent
Event Name: mouseWheelMoved
When Event is Generated: When the mouse wheel is moved

Component: Frame
Event: Same as Window
Event Name: Same as Window
When Event is Generated: Same as Window

Component: Dialog
Event: Same as Window
Event Name: Same as Window
When Event is Generated: Same as Window

Component: FileDialog
Event: Same as Dialog
Event Name: Same as Dialog
When Event is Generated: Same as Dialog

Component: MenuComponent
Event: ActionEvent
Event Name: actionPerformed
When Event is Generated: When a menu item is selected

Component: MenuComponent
Event: ItemEvent
Event Name: itemStateChanged
When Event is Generated: When a checkbox menu item is selected or deselected

Component: MenuBar
Event: Same as MenuComponent
Event Name: Same as MenuComponent
When Event is Generated: Same as MenuComponent

Component: Menu
Event: Same as MenuComponent
Event Name: Same as MenuComponent
When Event is Generated: Same as MenuComponent

Component: MenuItem
Event: ActionEvent
Event Name: actionPerformed
When Event is Generated: When a menu item is selected

Component: CheckboxMenuItem
Event: ItemEvent
Event Name: itemStateChanged
When Event is Generated: When a checkbox menu item is selected or deselected

Component: PopupMenu
Event: Same as MenuComponent
Event Name: Same as MenuComponent
When Event is Generated: Same as MenuComponent

//-------------------------------------------------------------------------------------------------------------

	// Layout Manager

	a layout manager automatically arranges your controls within a window by using some type of algorithm. Each Container 
	object has a layout manager associated with it. A layout manager is an instance of any class that implements the 
	LayoutManager interface. The layout manager is set by the setLayout( ) method. If no call to setLayout( ) is made, then the 	
	default layout manager is used. Whenever a container is resized (or sized for the first time), the layout manager is used to 
	position each of the components within it. The setLayout( ) method has the following general form: 

			void setLayout(LayoutManager layoutObj)

	If you wish to disable the layout manager and position components manually, pass null for layoutObj. If you do this, 
	you will need to determine the shape and position of each component manually, using the setBounds( ) method defined by 
	Component.

	// FlowLayout: 

	The FlowLayout class arranges components in a directional flow, much like lines of text in a paragraph. Here, we'll create 
	a frame with several buttons laid out using FlowLayout.

import java.awt.*;
import java.awt.event.*;

public class FlowLayoutExample {
    public static void main(String[] args) {
        // Create a frame
        Frame frame = new Frame("FlowLayout Example");

        // Set the layout manager to FlowLayout
        frame.setLayout(new FlowLayout());

        // Create some buttons and add them to the frame
        Button button1 = new Button("Button 1");
        Button button2 = new Button("Button 2");
        Button button3 = new Button("Button 3");
        Button button4 = new Button("Button 4");
        Button button5 = new Button("Button 5");

        frame.add(button1);
        frame.add(button2);
        frame.add(button3);
        frame.add(button4);
        frame.add(button5);

        // Add window listener to handle window close event
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                frame.dispose();
            }
        });

        // Set the frame size and make it visible
        frame.setSize(400, 200);
        frame.setVisible(true);
    }
}

	Note: 

	WindowAdapter is used instead of WindowListener in the above example because WindowAdapter provides default (empty) 
	implementations for all methods in the WindowListener interface. This allows you to override only the methods you need.

//--------------------------------------------------------------------------------------------------------------------------

	// BorderLayout:

	BorderLayout is a layout manager provided by java.awt that divides a container into five areas: North, South, East, West, 
	and Center. Components added to a container using BorderLayout are positioned in one of these five regions. Here's a simple 
	example demonstrating the use of BorderLayout:

import java.awt.*;

public class BorderLayoutExample {
    public static void main(String[] args) {
        // Create a frame
        Frame frame = new Frame("BorderLayout Example");

        // Set BorderLayout for the frame
        frame.setLayout(new BorderLayout());

        // Create buttons for each region
        Button northButton = new Button("North");
        Button southButton = new Button("South");
        Button eastButton = new Button("East");
        Button westButton = new Button("West");
        Button centerButton = new Button("Center");

        // Add buttons to the frame with BorderLayout constraints
        frame.add(northButton, BorderLayout.NORTH);
        frame.add(southButton, BorderLayout.SOUTH);
        frame.add(eastButton, BorderLayout.EAST);
        frame.add(westButton, BorderLayout.WEST);
        frame.add(centerButton, BorderLayout.CENTER);

        // Add window listener to handle window close event
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent windowEvent) {
                System.exit(0);
            }
        });

        // Set the frame size and make it visible
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}


//----------------------------------------------------------------------------------------------------------------

	// GridLayout: 

	GridLayout in java.awt arranges components in a grid of rows and columns. All components in a GridLayout are of equal size. 
	Here's a simple example demonstrating the use of GridLayout:

import java.awt.*;

public class GridLayoutExample {
    public static void main(String[] args) {
        // Create a frame
        Frame frame = new Frame("GridLayout Example");

        // Set GridLayout for the frame (3 rows, 2 columns)
        frame.setLayout(new GridLayout(3, 2));

        // Create buttons for the grid
        Button button1 = new Button("Button 1");
        Button button2 = new Button("Button 2");
        Button button3 = new Button("Button 3");
        Button button4 = new Button("Button 4");
        Button button5 = new Button("Button 5");
        Button button6 = new Button("Button 6");

        // Add buttons to the frame
        frame.add(button1);
        frame.add(button2);
        frame.add(button3);
        frame.add(button4);
        frame.add(button5);
        frame.add(button6);

        // Add window listener to handle window close event
        frame.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent windowEvent) {
                System.exit(0);
            }
        });

        // Set the frame size and make it visible
        frame.setSize(300, 200);
        frame.setVisible(true);
    }
}

//------------------------------------------------------------------------------------------------------------

	// CardLayout: 

		CardLayout in java.awt is a layout manager that allows you to display different components in the same area of a 
	container, like a deck of cards. Only one component (or "card") is visible at a time. Here's a simple example demonstrating 
	the use of CardLayout:



import java.awt.*;
import java.awt.event.*;

public class CardLayoutExample1 {
    private Frame frame;
    private Panel cardPanel;
    private CardLayout cardLayout;

    public CardLayoutExample1() {
        frame = new Frame("CardLayout Example");

        // Create a Panel with CardLayout
        cardPanel = new Panel();
        cardLayout = new CardLayout();
        cardPanel.setLayout(cardLayout);

        // Create panels for each "card"
        Panel card1 = new Panel();
        card1.setBackground(Color.RED);
        Label label1 = new Label("Card 1");
        card1.add(label1);

        Panel card2 = new Panel();
        card2.setBackground(Color.GREEN);
        Label label2 = new Label("Card 2");
        card2.add(label2);

        Panel card3 = new Panel();
        card3.setBackground(Color.BLUE);
        Label label3 = new Label("Card 3");
        card3.add(label3);

        // Add cards to the cardPanel with unique names
        cardPanel.add(card1, "Card 1");
        cardPanel.add(card2, "Card 2");
        cardPanel.add(card3, "Card 3");

        // Create buttons for navigation
        Panel buttonPanel = new Panel();
        Button prevButton = new Button("Previous");
        Button nextButton = new Button("Next");

        // Add action listeners to the buttons
        prevButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                cardLayout.previous(cardPanel);
            }
        });

        nextButton.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                cardLayout.next(cardPanel);
            }
        });

        buttonPanel.add(prevButton);
        buttonPanel.add(nextButton);

        // Add the cardPanel and buttonPanel to the frame
        frame.add(cardPanel, BorderLayout.CENTER);
        frame.add(buttonPanel, BorderLayout.SOUTH);

        // Add window listener to handle window close event
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        // Set the frame size and make it visible
        frame.setSize(300, 200);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        new CardLayoutExample1();
    }
}

//-------------------------------------------------------------------------------------------------------

	// Using Checkbox and CheckboxGroup

import java.awt.*;
import java.awt.event.*;

public class CheckboxExample {
    private Frame frame;
    private CheckboxGroup checkboxGroup;

    public CheckboxExample() {
        frame = new Frame("Checkbox Example");

        // Create a CheckboxGroup
        checkboxGroup = new CheckboxGroup();

        // Create Checkboxes
        Checkbox checkbox1 = new Checkbox("Option 1", checkboxGroup, false);
        Checkbox checkbox2 = new Checkbox("Option 2", checkboxGroup, false);
        Checkbox checkbox3 = new Checkbox("Option 3", checkboxGroup, false);

        // Create a Label to display selected option
        Label selectionLabel = new Label("Selected option: ");

        // Add ItemListener to handle checkbox selection change
        ItemListener itemListener = new ItemListener() {
            public void itemStateChanged(ItemEvent e) {
                Checkbox selectedCheckbox = checkboxGroup.getSelectedCheckbox();
                if (selectedCheckbox != null) {
                    selectionLabel.setText("Selected option: " + selectedCheckbox.getLabel());
                }
            }
        };

        checkbox1.addItemListener(itemListener);
        checkbox2.addItemListener(itemListener);
        checkbox3.addItemListener(itemListener);

        // Create a Panel for checkboxes
        Panel checkboxPanel = new Panel();
        checkboxPanel.setLayout(new FlowLayout());
        checkboxPanel.add(checkbox1);
        checkboxPanel.add(checkbox2);
        checkboxPanel.add(checkbox3);

        // Create a Panel for selection label
        Panel labelPanel = new Panel();
        labelPanel.setLayout(new FlowLayout());
        labelPanel.add(selectionLabel);

        // Add panels to the frame
        frame.add(checkboxPanel, BorderLayout.CENTER);
        frame.add(labelPanel, BorderLayout.SOUTH);

        // Add window listener to handle window close event
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        // Set frame size and make it visible
        frame.setSize(300, 150);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        new CheckboxExample();
    }
}

//-------------------------------------------------------------------------------------------------------

	// Using Checkbox 
import java.awt.*;
import java.awt.event.*;

public class CheckboxExample {
    private Frame frame;
    private CheckboxGroup checkboxGroup;

    public CheckboxExample() {
        frame = new Frame("Checkbox Example");

        // Create Checkboxes
        Checkbox checkbox1 = new Checkbox("Option 1",  false);
        Checkbox checkbox2 = new Checkbox("Option 2",  false);
        Checkbox checkbox3 = new Checkbox("Option 3",  false);

        // Create a Label to display selected option
        Label selectionLabel = new Label("Selected option: ");

        // Add ItemListener to handle checkbox selection change
        ItemListener itemListener = new ItemListener() {
            public void itemStateChanged(ItemEvent e) {
                Checkbox selectedCheckbox = (Checkbox)e.getSource();
                if (selectedCheckbox != null) {
                    selectionLabel.setText("Selected option: " + selectedCheckbox.getLabel());
                }
            }
        };

        checkbox1.addItemListener(itemListener);
        checkbox2.addItemListener(itemListener);
        checkbox3.addItemListener(itemListener);

        // Create a Panel for checkboxes
        Panel checkboxPanel = new Panel();
        checkboxPanel.setLayout(new FlowLayout());
        checkboxPanel.add(checkbox1);
        checkboxPanel.add(checkbox2);
        checkboxPanel.add(checkbox3);

        // Create a Panel for selection label
        Panel labelPanel = new Panel();
        labelPanel.setLayout(new FlowLayout());
        labelPanel.add(selectionLabel);

        // Add panels to the frame
        frame.add(checkboxPanel, BorderLayout.CENTER);
        frame.add(labelPanel, BorderLayout.SOUTH);

        // Add window listener to handle window close event
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        // Set frame size and make it visible
        frame.setSize(300, 150);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        new CheckboxExample();
    }
}


//---------------------------------------------------------------------------------------------------------------

	// Using Choice and List

import java.awt.*;
import java.awt.event.*;

public class ChoiceAndListExample {
    private Frame frame;
    private Choice choice;
    private List list;

    public ChoiceAndListExample() {
        frame = new Frame("Choice and List Example");

        // Create Choice
        choice = new Choice();
        choice.add("Option 1");
        choice.add("Option 2");
        choice.add("Option 3");

        // Create List
        list = new List(3); // Maximum visible rows in the list
        list.add("Item 1");
        list.add("Item 2");
        list.add("Item 3");
        list.add("Item 4");
        list.add("Item 5");
        list.add("Item 6");
        list.add("Item 7");
        list.add("Item 8");
        list.add("Item 9");

        // Create Label to display selection
        Label selectionLabel = new Label("Selected item: ");

        // Add ItemListener to Choice
        choice.addItemListener(new ItemListener() {
            public void itemStateChanged(ItemEvent e) {
                selectionLabel.setText("Selected item: " + choice.getSelectedItem());
            }
        });

        // Add ItemListener to List
        list.addItemListener(new ItemListener() {
            public void itemStateChanged(ItemEvent e) {
                selectionLabel.setText("Selected item: " + list.getSelectedItem());
            }
        });

        // Create Panels for Choice, List, and Label
        Panel choicePanel = new Panel(new BorderLayout());
        choicePanel.add(choice, BorderLayout.NORTH);

        Panel listPanel = new Panel(new BorderLayout());
        listPanel.add(list, BorderLayout.CENTER);

        Panel labelPanel = new Panel(new FlowLayout());
        labelPanel.add(selectionLabel);

        // Add Panels to the Frame
        frame.setLayout(new GridLayout(1, 3));
        frame.add(choicePanel);
        frame.add(listPanel);
        frame.add(labelPanel);

        // Add window listener to handle window close event
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        // Set the frame size and make it visible
        frame.setSize(400, 150);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        new ChoiceAndListExample();
    }
}

//-------------------------------------------------------------------------------------------------------------------------

		Using Scrollbar, TextArea, and TextField
import java.awt.*;
import java.awt.event.*;

public class ScrollbarTextAreaTextFieldExample {
    private Frame frame;
    private Scrollbar scrollbar;
    private TextArea textArea;
    private TextField textField;

    public ScrollbarTextAreaTextFieldExample() {
        frame = new Frame("Scrollbar, TextArea, and TextField Example");

        // Create Scrollbar
        scrollbar = new Scrollbar(Scrollbar.VERTICAL, 0, 1, 0, 100);

        // Create TextArea
        textArea = new TextArea(10, 30);

        // Create TextField
        textField = new TextField(30);

        // Add AdjustmentListener to Scrollbar
        scrollbar.addAdjustmentListener(new AdjustmentListener() {
            public void adjustmentValueChanged(AdjustmentEvent e) {
                textArea.setFont(new Font("Arial", Font.PLAIN, e.getValue()));
            }
        });

        // Add ActionListener to TextField
        textField.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                String text = textField.getText();
                textArea.append(text + "\n");
                textField.setText("");
            }
        });

        // Create Panels for Scrollbar, TextArea, and TextField
        Panel scrollbarPanel = new Panel();
        scrollbarPanel.add(scrollbar);

        Panel textAreaPanel = new Panel();
        textAreaPanel.add(textArea);

        Panel textFieldPanel = new Panel();
        textFieldPanel.add(textField);

        // Add Panels to the Frame
        frame.setLayout(new BorderLayout());
        frame.add(scrollbarPanel, BorderLayout.EAST);
        frame.add(textAreaPanel, BorderLayout.CENTER);
        frame.add(textFieldPanel, BorderLayout.SOUTH);

        // Add window listener to handle window close event
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        // Set the frame size and make it visible
        frame.setSize(400, 300);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        new ScrollbarTextAreaTextFieldExample();
    }
}


//-------------------------------------------------------------------------------------------------------------------------

	// Using MenuBar, Menu, and MenuItem

import java.awt.*;
import java.awt.event.*;

public class MenuBarMenuMenuItemExample {
    private Frame frame;

    public MenuBarMenuMenuItemExample() {
        frame = new Frame("MenuBar, Menu, and MenuItem Example");

        // Create MenuBar
        MenuBar menuBar = new MenuBar();

        // Create Menus
        Menu fileMenu = new Menu("File");
        Menu editMenu = new Menu("Edit");
        Menu helpMenu = new Menu("Help");

        // Create MenuItems for File Menu
        MenuItem newItem = new MenuItem("New");
        MenuItem openItem = new MenuItem("Open");
        MenuItem saveItem = new MenuItem("Save");
        MenuItem exitItem = new MenuItem("Exit");

        // Create MenuItems for Edit Menu
        MenuItem cutItem = new MenuItem("Cut");
        MenuItem copyItem = new MenuItem("Copy");
        MenuItem pasteItem = new MenuItem("Paste");

        // Create MenuItem for Help Menu
        MenuItem aboutItem = new MenuItem("About");

        // Add ActionListeners to MenuItems
        newItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("New File action performed");
            }
        });

        openItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("Open File action performed");
            }
        });

        saveItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("Save File action performed");
            }
        });

        exitItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        });

        cutItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("Cut action performed");
            }
        });

        copyItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("Copy action performed");
            }
        });

        pasteItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("Paste action performed");
            }
        });

        aboutItem.addActionListener(new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                System.out.println("About action performed");
            }
        });

        // Add MenuItems to Menus
        fileMenu.add(newItem);
        fileMenu.add(openItem);
        fileMenu.add(saveItem);
        fileMenu.addSeparator(); // Adds a separator line
        fileMenu.add(exitItem);

        editMenu.add(cutItem);
        editMenu.add(copyItem);
        editMenu.add(pasteItem);

        helpMenu.add(aboutItem);

        // Add Menus to MenuBar
        menuBar.add(fileMenu);
        menuBar.add(editMenu);
        menuBar.add(helpMenu);

        // Set MenuBar to the Frame
        frame.setMenuBar(menuBar);

        // Add window listener to handle window close event
        frame.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        // Set the frame size and make it visible
        frame.setSize(300, 200);
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        new MenuBarMenuMenuItemExample();
    }
}

//-----------------------------------------------------------------------------------------------------------------------

	// Using MouseEvents

import java.awt.*;
import java.awt.event.*;

public class MouseEventExample extends Frame implements MouseListener, MouseMotionListener {
    private Label statusLabel;

    public MouseEventExample() {
        setTitle("Mouse Events Example");

        // Create a label to display mouse event status
        statusLabel = new Label("Mouse status will be displayed here.");
        add(statusLabel, BorderLayout.SOUTH);

        // Add mouse listeners to the frame
        addMouseListener(this);
        addMouseMotionListener(this);

        // Add window listener to handle window close event
        addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                System.exit(0);
            }
        });

        setSize(400, 300);
        setVisible(true);
    }

    // MouseListener methods
    public void mouseClicked(MouseEvent e) {
        statusLabel.setText("Mouse Clicked at (" + e.getX() + ", " + e.getY() + ")");
		System.out.println("Mouse Clicked at (" + e.getX() + ", " + e.getY() + ")");
    }

    public void mousePressed(MouseEvent e) {
        statusLabel.setText("Mouse Pressed at (" + e.getX() + ", " + e.getY() + ")");
    }

    public void mouseReleased(MouseEvent e) {
        statusLabel.setText("Mouse Released at (" + e.getX() + ", " + e.getY() + ")");
    }

    public void mouseEntered(MouseEvent e) {
        statusLabel.setText("Mouse Entered at (" + e.getX() + ", " + e.getY() + ")");
    }

    public void mouseExited(MouseEvent e) {
        statusLabel.setText("Mouse Exited at (" + e.getX() + ", " + e.getY() + ")");
    }

    // MouseMotionListener methods
    public void mouseDragged(MouseEvent e) {
        statusLabel.setText("Mouse Dragged at (" + e.getX() + ", " + e.getY() + ")");
    }

    public void mouseMoved(MouseEvent e) {
        statusLabel.setText("Mouse Moved at (" + e.getX() + ", " + e.getY() + ")");
    }

    public static void main(String[] args) {
        new MouseEventExample();
    }
}


//--------------------------------------------------------------------------------------------------------------------------

	// Overview of java.awt and javax.swing

In Java, java.awt and javax.swing are two primary libraries for creating graphical user interfaces (GUIs). 
They serve similar purposes but have some important differences in terms of their design, functionality, and usage. 
Here is a detailed explanation of both:

java.awt (Abstract Window Toolkit)

1. Overview:
java.awt stands for Abstract Window Toolkit.
It was the original GUI toolkit for Java, introduced in JDK 1.0.
AWT provides a set of APIs for creating and managing GUI components like windows, buttons, text fields, etc.
AWT components are heavyweight, meaning they are tied closely to the native system's GUI components.

2. Key Features:
Platform-Dependent: AWT components rely on the underlying native system's GUI controls, which can lead to inconsistencies across different platforms.
Heavyweight Components: Because they use native peer components, they can be more resource-intensive and have less flexible rendering capabilities.
Basic Functionality: AWT provides basic UI components but lacks the more advanced features found in modern GUIs.

3. Components:
Basic GUI components: Button, Label, TextField, TextArea, Checkbox, Choice, List, etc.
Containers: Frame, Panel, Dialog, Applet, etc.
Layout managers: FlowLayout, BorderLayout, GridLayout, etc.


	// javax.swing

1. Overview:

javax.swing is part of the Java Foundation Classes (JFC).
Introduced in JDK 1.2 to provide a more robust, flexible, and consistent GUI toolkit.
Swing components are lightweight and written entirely in Java, providing a uniform look-and-feel across different platforms.

2. Key Features:
Platform-Independent: Swing components are not tied to the native system's GUI controls, ensuring consistency across platforms.
Lightweight Components: Swing components do not rely on native peers, making them less resource-intensive and more flexible.
Rich Functionality: Swing offers a wide range of advanced GUI components and features, such as tables, trees, and rich text editors.
3. Components:

Basic GUI components: JButton, JLabel, JTextField, JTextArea, JCheckBox, JComboBox, JList, etc.
Containers: JFrame, JPanel, JDialog, JApplet, etc.
Layout managers: FlowLayout, BorderLayout, GridLayout, BoxLayout, etc.
Advanced components: JTable, JTree, JTabbedPane, JToolBar, JMenuBar, etc.
4. Pluggable Look and Feel:

Swing supports the concept of pluggable look-and-feel, allowing applications to have different appearances (Metal, Nimbus, Windows, etc.).


	--------------------- Mini Project : Shopping Application ----------------------------

//==================================================================================================================================
//==================================================================================================================================
//==================================================================================================================================

	// Overview of Networking Concepts

	Networking refers to the practice of connecting computers and other devices to 
	share resources, exchange data, and facilitate communication. It is a fundamental
	aspect of modern computing, enabling everything from simple file sharing between 
	computers to complex internet-based applications and services.

	Key networking concepts include:

	Network Types:
	- Local Area Network (LAN): A network covering a small geographic area, like a single building 
	  or campus.
	- Wide Area Network (WAN): A network covering a large geographic area, such as a city, country, 
	  or even globally.
	- Metropolitan Area Network (MAN): A network that spans a city or large campus.
	- Internet - World wide network

	Network Topologies: The layout pattern of interconnected nodes in a network. 
		Common topologies include bus, star, ring, and mesh.

	Protocols: Rules and conventions for communication between network devices. 	
	Examples include TCP/IP, HTTP, FTP, and SMTP.

	IP Addressing: Unique identifiers assigned to each device on a network, 
	allowing them to be located and contacted. IPv4 and IPv6 are the two versions of IP addresses.

	DNS (Domain Name System): A hierarchical system that translates human-readable 	domain names 
	(like www.example.com) into IP addresses.

//-------------------------------------------------------------------------------------------------------------

	// Importance of Networking in Applications

	Networking is crucial for modern applications for several reasons:

	- Resource Sharing: Networking allows multiple devices to share resources such 
	  as printers, files, and internet connections.
	- Communication: Enables communication between users through email, instant 
	  messaging, and video conferencing.
	- Data Exchange: Facilitates the exchange of data between devices, enabling 
	  applications like web browsing, file transfers, and online gaming.
	- Distributed Computing: Supports the distribution of computational tasks across
	  multiple devices, improving performance and reliability.
	- Internet of Things (IoT): Connects various devices (sensors, appliances, 
	  vehicles) to the internet, enabling remote monitoring and control.

//-----------------------------------------------------------------------------------------------------

	// Java and Networking

	Java provides a robust set of libraries and APIs for developing networked 
	applications. The java.net package is the core library for networking in Java, 
	offering a range of classes and interfaces to handle various networking tasks.

	Some key features of Java for networking include:

	- Platform Independence: Java applications are platform-independent, meaning 
	  they can run on any device with a Java Virtual Machine (JVM), making it easier 
	  to develop networked applications that work across different operating systems.
	- Extensive Networking Libraries: Java's java.net package includes classes for 
	  working with URLs, sockets, and datagrams, as well as higher-level abstractions
	  like HTTP and RMI (Remote Method Invocation).
	- Security: Java provides built-in security features, such as the SecurityManager
	  class and SSL/TLS support, to help secure networked applications.
	- Multithreading: Java's support for multithreading makes it easier to handle 
	  multiple network connections concurrently, improving the efficiency and 
	  responsiveness of networked applications.

//---------------------------------------------------------------------------------

	// Common Java Networking Terminology

	- IP Address: A unique identifier assigned to each device on a network. IPv4 
	  addresses are 32-bit numbers, while IPv6 addresses are 128-bit numbers.

	- Port: A numerical value assigned to specific processes or network services, 
	  allowing multiple services to run on a single IP address. Common ports 
	  include 80 (HTTP) and 443 (HTTPS).

	- Socket: An endpoint for communication between two machines. A socket is bound 
	  to a port number and an IP address.

	- ServerSocket: A class in Java used to create server-side sockets that listen 
	  for incoming connections from clients.

	- ClientSocket: A socket initiated by a client to establish a connection with a 
	  server's socket.

	- Datagram: A self-contained packet of data sent over a network. Used primarily 
	  in UDP (User Datagram Protocol) communication.

	- URL (Uniform Resource Locator): A reference to a web resource that specifies 
	  its location on a network and the protocol used to access it.
	  (e.g., http://www.example.com).

	- Protocol: A set of rules governing the communication between devices. Common 
	  protocols include TCP (Transmission Control Protocol) and UDP (User Datagram 
	  Protocol).

	- TCP/IP (Transmission Control Protocol/Internet Protocol): A suite of 
	  communication protocols used to interconnect network devices on the internet. 
	  TCP ensures reliable data transfer, while IP handles addressing and routing.

	- UDP (User Datagram Protocol): A connectionless protocol that allows data to be
	  sent without establishing a connection. It is faster but less reliable 
	  than TCP.

	- HTTP (HyperText Transfer Protocol): The protocol used for transmitting web 
	  pages over the internet. It is the foundation of data communication for the 
	  World Wide Web.

	- HTTPS (HyperText Transfer Protocol Secure): An extension of HTTP that uses 
	  SSL/TLS to provide secure communication over a computer network.

	- DNS (Domain Name System): A hierarchical system that translates human-readable 
	  domain names (like www.example.com) into IP addresses.

	- Multicasting: Sending a single message to a group of recipients simultaneously.
	  This is typically used in applications like video conferencing.

	- NIO (New Input/Output): A collection of Java programming APIs that offer 
	  features for intensive I/O operations, including non-blocking I/O, buffer 
	  management, and file handling.

	- RMI (Remote Method Invocation): A Java API that allows objects to communicate 
	  with each other in a networked environment, invoking methods remotely.

	- SSL/TLS (Secure Sockets Layer/Transport Layer Security): Protocols used to 
	  secure communication over a network by encrypting the data transferred between
 	  clients and servers.

	- Firewall: A network security system that monitors and controls incoming and 
	  outgoing network traffic based on predetermined security rules.

//---------------------------------------------------------------------------------
	
	// Overview of java.net Package
	
	The java.net package provides classes and interfaces for implementing networking applications in Java. 
	It covers both low-level and high-level networking features, allowing developers to work with various 
	network protocols and communication methods. 

	// Core Classes:
	//----------------
	- InetAddress
		- Represents an IP address.
		- Provides methods to resolve hostnames to IP addresses and vice versa.
		- Example
			InetAddress address = InetAddress.getByName("www.example.com");
			System.out.println("IP Address: " + address.getHostAddress());

	- Socket
		- Represents a client-side socket for establishing a connection to a server.
		- Provides methods for reading from and writing to the connection.
		- Example
			Socket socket = new Socket("localhost", 8080);

	- ServerSocket
		- Represents a server-side socket that listens for incoming client connections.
		- Example:
			ServerSocket serverSocket = new ServerSocket(8080);
			Socket clientSocket = serverSocket.accept();

	- DatagramSocket
		- Used for sending and receiving datagram packets (UDP communication).
		- Example
			DatagramSocket socket = new DatagramSocket();

	- DatagramPacket
		- Represents a datagram packet used in UDP communication.
		- Example
			byte[] buf = new byte[256];
			DatagramPacket packet = new DatagramPacket(buf, buf.length);

	- URL
		- Represents a Uniform Resource Locator, a pointer to a resource on the web.
		- Provides methods to access and manipulate URL components.
		- Example
			URL url = new URL("http://www.example.com");
	
	- URLConnection
		- Represents a communication link between the application and a URL.
		- Example
			URLConnection connection = new URL("http://www.example.com").openConnection();

	- HttpURLConnection
		- A subclass of URLConnection for HTTP-specific features.
		- Example
	
	HttpURLConnection httpConn = (HttpURLConnection) new URL("http://www.example.com").openConnection();
	httpConn.setRequestMethod("GET");

	// Interfaces
	//----------------

	- ContentHandler: Defines a method for reading an Object from a URLConnection.
	- FileNameMap: Provides a method for mapping a file name to a MIME type string.
	- SocketImplFactory: Defines a factory interface for creating socket implementations.
	- URLStreamHandlerFactory: Defines a factory interface for creating URLStreamHandler instances.

	// Exception Classes
	//----------------

	- SocketException: Indicates an error with the underlying protocol, such as a TCP error.
	- UnknownHostException: Thrown when a host name cannot be resolved.


	The java.net package provides support for the two common network protocols −

	- TCP − TCP stands for Transmission Control Protocol, which allows for reliable communication between 
	  two applications. TCP is typically used over the Internet Protocol, which is referred to as TCP/IP.

	- UDP − UDP stands for User Datagram Protocol, a connection-less protocol that allows for packets of 
	  data to be transmitted between applications.

	The java.net provides two different ways of deaing with n/w applications, which are 

	- Socket Programming: Socket programming involves creating network applications that communicate over 
	  a network using sockets. A socket is one endpoint of a two-way communication link between two 
	  programs running on the network. Socket programming allows developers to create client-server 
	  applications where one program (the client) sends requests to another program (the server), and the
 	  server processes these requests and sends back responses. - Transportation using streams

	- URL Programming: URL programming involves working with Uniform Resource Locators (URLs) to access 
	  resources on the web. Java provides classes and methods to work with URLs, allowing you to retrieve 	  	  
	  data from web pages, send HTTP requests, and handle responses. - Transportation using Datagrams

//------------------------------------------------------------------------------------------------------------

	// Java Socket programming

	Java Socket programming can either be connection-oriented or connection-less. In Socket Programming, 
	Socket and ServerSocket classes are managed for connection-oriented socket programming. However, 
	DatagramSocket and DatagramPacket classes are utilized for connection-less socket programming.

    - The java.net.ServerSocket class: 

	The java.net.ServerSocket class in Java is a fundamental class used in network programming for 
	implementing server-side network communication. It is part of the java.net package and provides 
	mechanisms for server applications to listen for incoming client connections over the network. 
	
	Constructors: Methods:
	- ServerSocket(int port): Creates a server socket bound to the specified port.
	- ServerSocket(int port, int backlog): Creates a server socket with a specified backlog.
	- ServerSocket(int port, int backlog, InetAddress bindAddr): Binds to a specific address and 
	  port with a specified backlog.

	Methods: 

	- accept(): Waits for an incoming client connection and returns a Socket object for the connection.
	- bind(SocketAddress endpoint): Binds the server socket to a specific address.
	- close(): Closes the server socket, releasing the port and any resources associated with it.
	- setSoTimeout(int timeout): Sets a timeout for the accept() method.
	- getLocalPort(): Returns the port number the server socket is bound to.
	- isBound(): Checks if the server socket is bound to an address.
	- isClosed(): Checks if the server socket is closed.

    - The java.net.Socket:
	
	The java.net.Socket class in Java is a fundamental class used for client-side network communication. 
	It is part of the java.net package and provides the necessary mechanisms for connecting to a server, 
	sending and receiving data over a network.

	Constructors:
	- Socket(String host, int port): Creates a socket and connects it to the specified host and port.
	- Socket(InetAddress address, int port): Connects to the server at the specified IP address and port.
	  Various other constructors for advanced configurations, such as specifying a local address or binding 
	  to a specific local port.

	 Methods:
	- getInputStream(): Returns an input stream for reading data from the socket.
	- getOutputStream(): Returns an output stream for writing data to the socket.
	- close(): Closes the socket, releasing any associated resources.
	- setSoTimeout(int timeout): Sets a timeout for reading from the input stream.
	- setSendBufferSize(int size): Sets the send buffer size for the socket.
	- setReceiveBufferSize(int size): Sets the receive buffer size for the socket.
 	- getInetAddress(): Returns the address of the remote server.
	- getPort(): Returns the remote port number.
	- isClosed(): Checks if the socket is closed.
	- isConnected(): Checks if the socket is connected.


   - Steps to establishing a TCP connection between two computing devices using Socket Programming

	The following are the steps that occur on establishing a TCP connection between two computers using 
	socket programming are given as follows:
 

	Step 1 – The server instantiates a ServerSocket object, indicating at which port number communication
	will occur.

	Step 2 – After instantiating the ServerSocket object, the server requests the accept() method of the 
	ServerSocket class. This program pauses until a client connects to the server on the given port.

	Step 3 – After the server is idling, a client instantiates an object of Socket class, defining the 
	server name and the port number to connect to.

	Step 4 – After the above step, the constructor of the Socket class strives to connect the client to 
	the designated server and the port number. If communication is authenticated, the client forthwith 
	has a Socket object proficient in interacting with the server.

	Step 5 – On the server-side, the accept() method returns a reference to a new socket on the server 
	connected to the client’s socket.

	After the connections are stabilized, communication can happen using I/O streams. Each object of a 
	socket class has both an OutputStream and an InputStream. The client’s OutputStream is correlated to 
	the server’s InputStream, and the client’s InputStream is combined with the server’s OutputStream. 
	Transmission Control Protocol (TCP) is a two-way communication protocol. Hence information can be 
	transmitted over both streams at the corresponding time. 

	// server program

import java.io.*;
import java.net.*;

public class SimpleServer {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(12345)) {
            System.out.println("Server is listening on port 12345");
            while (true) {
                Socket socket = serverSocket.accept();
                System.out.println("New client connected");

                // Handle the client connection
                InputStream input = socket.getInputStream();
                BufferedReader reader = new BufferedReader(new InputStreamReader(input));
                String message = reader.readLine();
                System.out.println("Received: " + message);

                // Close the client connection
                socket.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

	// Client program

import java.io.*;
import java.net.*;

public class SimpleClient {
    public static void main(String[] args) {
        String hostname = "localhost";
        int port = 12345;

        try (Socket socket = new Socket(hostname, port)) {
            OutputStream output = socket.getOutputStream();
            PrintWriter writer = new PrintWriter(output, true);
            writer.println("Hello, Server!");
	    System.out.println("message sent");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

//----------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------

	// Two way Communication

import java.net.*;
import java.io.*;

public class GreetingServer extends Thread {
   private ServerSocket serverSocket;
   
   public GreetingServer(int port) throws IOException {
      serverSocket = new ServerSocket(port);
      //serverSocket.setSoTimeout(10000);
   }

   public void run() {
      while(true) {
         try {
            System.out.println("Waiting for client on port " + 
               serverSocket.getLocalPort() + "...");
            Socket server = serverSocket.accept();
            
            System.out.println("Just connected to " + server.getRemoteSocketAddress());
            DataInputStream in = new DataInputStream(server.getInputStream());
            
            System.out.println(in.readUTF());
            DataOutputStream out = new DataOutputStream(server.getOutputStream());
            out.writeUTF("Thank you for connecting to " + server.getLocalSocketAddress()
               + "\nGoodbye!");
            server.close();
            
         } catch (SocketTimeoutException s) {
            System.out.println("Socket timed out!");
            break;
         } catch (IOException e) {
            e.printStackTrace();
            break;
         }
      }
   }
   
   public static void main(String [] args) {
      int port = 1000;
      try {
         Thread t = new GreetingServer(port);
         t.start();
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}

//---------------------

import java.net.*;
import java.io.*;

public class GreetingClient {

   public static void main(String [] args) {
      String serverName = "localhost";;
      int port = 1000;
      try {
         System.out.println("Connecting to " + serverName + " on port " + port);
         Socket client = new Socket(serverName, port);
         
         System.out.println("Just connected to " + client.getRemoteSocketAddress());
         OutputStream outToServer = client.getOutputStream();
         DataOutputStream out = new DataOutputStream(outToServer);
         
         out.writeUTF("Hello from " + client.getLocalSocketAddress());
         InputStream inFromServer = client.getInputStream();
         DataInputStream in = new DataInputStream(inFromServer);
         
         System.out.println("Server says " + in.readUTF());
         client.close();
      } catch (IOException e) {
         e.printStackTrace();
      }
   }
}

//---------------------------------------------------------------------------------------------------

	// Program to where client send the string to server to convert it to uppercase and send
	// back to client after converting

import java.io.*;
import java.net.*;

public class UppercaseServer {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(12345)) {
            System.out.println("Server is listening on port 12345");
            Socket socket = serverSocket.accept();
            System.out.println("Client connected");

            InputStream input = socket.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(input));
            OutputStream output = socket.getOutputStream();
            PrintWriter writer = new PrintWriter(output, true);

            String text;

            do {
                text = reader.readLine();
                System.out.println("String Received: " + text);
                if (text != null && !text.equalsIgnoreCase("exit")) {
                    String uppercasedText = text.toUpperCase();
                    writer.println(uppercasedText);
                }
            } while (text != null && !text.equalsIgnoreCase("exit"));

            System.out.println("Client disconnected");

        } catch (IOException ex) {
            System.out.println("Server exception: " + ex.getMessage());
            ex.printStackTrace();
        }
    }
}

//---------------------------

import java.io.*;
import java.net.*;

public class UppercaseClient {
    public static void main(String[] args) {
        String hostname = "localhost";
        int port = 12345;

        try (Socket socket = new Socket(hostname, port)) {
            OutputStream output = socket.getOutputStream();
            PrintWriter writer = new PrintWriter(output, true);
            InputStream input = socket.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(input));

            BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
            String text;

            System.out.println("Enter text (type 'exit' to quit):");

            do {
                System.out.print("Client: ");
                text = consoleReader.readLine();
                writer.println(text);

                if (!text.equalsIgnoreCase("exit")) {
                    String response = reader.readLine();
                    System.out.println("Server: " + response);
                }

            } while (!text.equalsIgnoreCase("exit"));

        } catch (UnknownHostException ex) {
            System.out.println("Server not found: " + ex.getMessage());
        } catch (IOException ex) {
            System.out.println("I/O error: " + ex.getMessage());
        }
    }
}

//------------------------------------------------------------------------------------------------

	// Chatting Appication

import java.io.*;
import java.net.*;

public class ChatClient {
    public static void main(String[] args) {
        String hostname = "localhost";
        int port = 12345;

        try (Socket socket = new Socket(hostname, port)) {
            OutputStream output = socket.getOutputStream();
            PrintWriter writer = new PrintWriter(output, true);
            InputStream input = socket.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(input));

            BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
            String text;

            new Thread(new ServerHandler(reader)).start();

            System.out.println("Enter text (type 'exit' to quit):");

            do {
                System.out.print("Client: ");
                text = consoleReader.readLine();
                writer.println(text);

            } while (!text.equalsIgnoreCase("exit"));

        } catch (UnknownHostException ex) {
            System.out.println("Server not found: " + ex.getMessage());
        } catch (IOException ex) {
            System.out.println("I/O error: " + ex.getMessage());
        }
    }
}

class ServerHandler implements Runnable {
    private BufferedReader reader;

    public ServerHandler(BufferedReader reader) {
        this.reader = reader;
    }

    public void run() {
        try {
            String response;
            while ((response = reader.readLine()) != null) {
                System.out.println("Server: " + response);
            }
        } catch (IOException ex) {
            System.out.println("ServerHandler exception: " + ex.getMessage());
            ex.printStackTrace();
        }
    }
}

//---------------------------------------

import java.io.*;
import java.net.*;

public class ChatServer {
    public static void main(String[] args) {
        try (ServerSocket serverSocket = new ServerSocket(12345)) {
            System.out.println("Server is listening on port 12345");
            Socket socket = serverSocket.accept();
            System.out.println("Client connected");

            new Thread(new ClientHandler(socket)).start();

        } catch (IOException ex) {
            System.out.println("Server exception: " + ex.getMessage());
            ex.printStackTrace();
        }
    }
}

class ClientHandler implements Runnable {
    private Socket socket;

    public ClientHandler(Socket socket) {
        this.socket = socket;
    }

    public void run() {
        try (
            InputStream input = socket.getInputStream();
            BufferedReader reader = new BufferedReader(new InputStreamReader(input));
            OutputStream output = socket.getOutputStream();
            PrintWriter writer = new PrintWriter(output, true);
        ) {
            BufferedReader consoleReader = new BufferedReader(new InputStreamReader(System.in));
            String text;

            do {
                // Read message from client
                text = reader.readLine();
                System.out.println("Client: " + text);

                // Server response
                if (!text.equalsIgnoreCase("exit")) {
                    System.out.print("Server: ");
                    String response = consoleReader.readLine();
                    writer.println(response);
                }

            } while (!text.equalsIgnoreCase("exit"));

            System.out.println("Client disconnected");

        } catch (IOException ex) {
            System.out.println("Server exception: " + ex.getMessage());
            ex.printStackTrace();
        }
    }
}

//--------------------------------------------------------------------------------------

	// Using All About Datagrams - UDP Protocol 

	InetAddress class: 

	The InetAddress class in Java, part of the java.net package, is used to represent an IP address, either IPv4 or IPv6.
	It provides methods to work with IP addresses and hostnames, facilitating network communication.

	- Constructors
		The InetAddress class does not have public constructors. Instead, it uses factory methods to create instances.

	- Factory Methods
		- static InetAddress getByName(String host)
			Returns an InetAddress object for the specified hostname or IP address.
		- static InetAddress[] getAllByName(String host)
			Returns an array of InetAddress objects for the specified hostname, which can resolve to 
			multiple IP addresses.
		- static InetAddress getByAddress(byte[] addr): Returns an InetAddress object for the specified raw IP address.
		- static InetAddress getByAddress(String host, byte[] addr): 
			Returns an InetAddress object for the specified hostname and raw IP address.
		- static InetAddress getLoopbackAddress(): Returns an InetAddress object representing the loopback address.
		- static InetAddress getLocalHost(): Returns the InetAddress object representing the local host.

	- Methods
		- String getHostName(): Returns the hostname associated with this IP address.
		- String getCanonicalHostName(): Returns the fully qualified domain name for this IP address.
		- String getHostAddress(): Returns the IP address string in textual representation.
		- byte[] getAddress(): Returns the raw IP address in a byte array.
		- boolean isReachable(int timeout): Tests whether the address is reachable within the given timeout.
		- boolean isLoopbackAddress(): Checks if the address is a loopback address.
		- boolean isLinkLocalAddress(): Checks if the address is a link-local address.
		- boolean isSiteLocalAddress(): Checks if the address is a site-local address.
		- boolean isMulticastAddress(): Checks if the address is a multicast address.
		- boolean isAnyLocalAddress(): Checks if the address is a wildcard address.
		- boolean isMCGlobal(): Checks if the address is a global multicast address.
		- boolean isMCNodeLocal(): Checks if the address is a node-local multicast address.
		- boolean isMCLinkLocal(): Checks if the address is a link-local multicast address.
		- boolean isMCSiteLocal(): Checks if the address is a site-local multicast address.
		- boolean isMCOrgLocal(): Checks if the address is an organization-local multicast address.

import java.net.InetAddress;
import java.net.UnknownHostException;

public class InetAddressExample {
    public static void main(String[] args) {
        try {
            // Get the InetAddress object for a hostname
            InetAddress address = InetAddress.getByName("www.yahoo.com");
            System.out.println("Host Name: " + address.getHostName());
            System.out.println("Host Address: " + address.getHostAddress());
            System.out.println("Canonical Host Name: " + address.getCanonicalHostName());
            
            // Get the InetAddress object for the local host
            InetAddress localAddress = InetAddress.getLocalHost();
            System.out.println("Local Host Name: " + localAddress.getHostName());
            System.out.println("Local Host Address: " + localAddress.getHostAddress());
            
            // Check if an address is reachable
            boolean reachable = address.isReachable(5000);
            System.out.println("Is reachable: " + reachable);
            
            // Get all IP addresses for a hostname
            InetAddress[] allAddresses = InetAddress.getAllByName("www.archerinfotech.in");
            for (InetAddress addr : allAddresses) {
                System.out.println("All Addresses: " + addr.getHostAddress());
            }
            
        } catch (UnknownHostException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//-----------------------------------------------------------------------------------------------------------------

	Datagram:
		A datagram is a self-contained, independent packet of data that is sent over a network. It contains enough 
	information to be routed from the source to the destination without relying on previous exchanges between the sender and 
	receiver or the transport layer. Datagram communication is typically connectionless, meaning each packet is treated 
	independently, and there is no need for establishing a connection beforehand.

	DatagramSocket
		The DatagramSocket class in Java is used to send and receive datagram packets. It provides the mechanism for 
	communication via the User Datagram Protocol (UDP), which is a connectionless protocol.

	- Constructors
		- DatagramSocket()
			Creates a datagram socket and binds it to any available port on the local host machine.
		- DatagramSocket(int port)
			Creates a datagram socket and binds it to the specified port on the local host machine.
		- DatagramSocket(int port, InetAddress laddr)
			Creates a datagram socket and binds it to the specified port and local address.

	- DatagramPacket
		The DatagramPacket class represents a datagram packet. It is used to hold the data either to be sent or 
	received via a DatagramSocket.

	- Constructors
		- DatagramPacket(byte[] buf, int length)
			Constructs a DatagramPacket for receiving packets of length up to length bytes.
		- DatagramPacket(byte[] buf, int length, InetAddress address, int port)
			Constructs a DatagramPacket for sending packets with the specified byte array, length, destination 
			address, and port.

	Transport Mechanism in the Network

	- Sending Data:
		- A datagram packet is created using DatagramPacket.
		- A DatagramSocket is created to send the datagram.
		- The packet is sent using the send() method of the DatagramSocket class.

	- Receiving Data:
		- A DatagramSocket is created to receive datagrams.
		- A datagram packet is created to hold the incoming data.
		- The packet is received using the receive method of the DatagramSocket class.


import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class DatagramSender {
    public static void main(String[] args) {
        try {
            // Create a DatagramSocket
            DatagramSocket socket = new DatagramSocket();
            
            // Prepare data to be sent
            String message = "Hello, this is a test message!";
            byte[] buffer = message.getBytes();
            
            // Get the destination address
            InetAddress receiverAddress = InetAddress.getByName("localhost");
            int receiverPort = 9876;
            
            // Create a DatagramPacket to send
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, receiverAddress, receiverPort);
            
            // Send the packet
            socket.send(packet);
            System.out.println("Message sent: " + message);
            
            // Close the socket
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//-------------------
import java.net.DatagramPacket;
import java.net.DatagramSocket;

public class DatagramReceiver {
    public static void main(String[] args) {
        try {
            // Create a DatagramSocket to receive packets on port 9876
            DatagramSocket socket = new DatagramSocket(9876);
            
            // Prepare a buffer to hold the incoming data
            byte[] buffer = new byte[1024];
            
            // Create a DatagramPacket to receive the data
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
            
            // Receive the packet
            socket.receive(packet);
            
            // Extract the data from the packet
            String message = new String(packet.getData(), 0, packet.getLength());
            System.out.println("Message received: " + message);
            
            // Close the socket
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//----------------------------------------------------------------------------------------------------------------------
	
	// Java - URL Processing

	URI (Uniform Resource Identifier):
	- Think of URI as the umbrella term. It's a general way to identify a resource, which could be a web page, an image, 
	  a video, or even a physical object with a digital representation.
	- A URI can act like a location (URL) or a name (URN), or even both in some cases.
	- Purpose: To identify a resource either by location, name, or both.
	- Format: scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]

	URL (Uniform Resource Locator):
	- A URL is a specific type of URI that focuses on location. It tells you not only what the resource is, but also 
	  where it's found on a network and how to access it. 
	- This is the classic web address you see in your browser bar, like "https://www.example.com/index.html". 
	  The parts of the URL specify the protocol (http/https), domain name (example.com), and the specific file (index.html).
	- Purpose: To locate a resource on the internet.
	- Format: scheme://user:password@host:port/path?query#fragment
	- Example: https://www.example.com/index.html

	URN (Uniform Resource Name):
	- A URN is another type of URI that acts like a unique name tag. It identifies a resource by its specific identity, 	  	  	  
	  independent of location or how to access it.
	- Think of it like an ISBN number for a book. It tells you exactly which book it is, but doesn't tell you where to 
	  buy it.
	- URNs often follow a specific format like "urn:isbn:0451450523" where "isbn" is the namespace (category) and 
	  "0451450523" is the unique identifier for that specific book.
	- Purpose: To uniquely identify a resource by name in a global namespace.
	- Format: urn:<namespace>:<name>
	- Example: urn:isbn:0451450523


	// java.net.URL class

	In Java, the java.net.URL class represents a Uniform Resource Locator (URL), a reference to a resource on the internet. 
	This class provides methods to access various parts of a URL and to perform network operations such as opening a 
	connection to the resource specified by the URL.

	Key Features and Components
	- Scheme (Protocol): The URL's scheme specifies the protocol to be used (e.g., http, https, ftp).
	- Host: The domain name or IP address of the server where the resource is located.
	- Port: The port number on the host (optional, defaults to the protocol's default port).
	- Path: The file or resource location on the server.
	- Query: A query string containing parameters (optional).
	- Fragment: A reference to a part of the resource (optional).
	- Example URL
		URL url = new URL("https://www.example.com:8080/path/to/resource?query=example#section1");

		Scheme: https
		Host: www.example.com
		Port: 8080
		Path: /path/to/resource
		Query: query=example
		Fragment: section1

	Putting it all together, the URL https://www.example.com:8080/path/to/resource?query=example#section1 specifies a 
	secure connection (HTTPS) to the server www.example.com on port 8080. The requested resource is located 
	at /path/to/resource, and a query parameter query with the value example is passed. Additionally, within the resource, 
	the fragment section1 indicates a specific section or part.


	Methods in java.net.URL

	The java.net.URL class provides several useful methods for parsing and manipulating URLs:

	Constructors:
	- URL(String spec)
	- URL(String protocol, String host, int port, String file)
	- URL(String protocol, String host, String file)
	- URL(URL context, String spec)

	URL Parts:
	- String getProtocol(): Returns the protocol (scheme) of the URL.
	- String getHost(): Returns the host name or IP address.
	- int getPort(): Returns the port number.
	- String getPath(): Returns the path component.
	- String getQuery(): Returns the query string.
	- String getRef(): Returns the fragment identifier.
	- String getUserInfo(): Returns the user info (if present).

	Full URL:
	- String toString(): Returns the complete URL as a string.
	- String toExternalForm(): Same as toString() but may include additional encoding.

	Network Operations:
	- URLConnection openConnection(): Opens a connection to the resource referenced by the URL.
	- InputStream openStream(): Opens an input stream to read from the resource.


import java.net.URL;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;

public class URLExample {
    public static void main(String[] args) {
        try {
            // Create a URL object
            URL url = new URL("https://gemini.google.com/app?utm_source=sem&utm_medium=paid-media&utm_campaign=q4enIN_sem7&gclid=Cj0KCQiA35urBhDCARIsAOU7QwmroDyX-Me8RkzHilOXYwnCyAFr9Pr08yhp8l4oFTxR40PrtA0pd_IaAoyiEALw_wcB");

            // Print parts of the URL
            System.out.println("Protocol: " + url.getProtocol());
            System.out.println("Host: " + url.getHost());
            System.out.println("Port: " + url.getPort());
            System.out.println("Path: " + url.getPath());
            System.out.println("Query: " + url.getQuery());
            System.out.println("Fragment: " + url.getRef());

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

"fragment" refers to the process of breaking down large packets of data into smaller pieces to fit
 the constraints of the network medium. This process is known as IP fragmentation.
//----------------------------------------------------------------------------------------------------------------------

	// URL processing 

	In Java URL processing involves working with URL and URLConnection classes provided in the java.net package.

	Creating a URL Object
	- A URL (Uniform Resource Locator) object represents a pointer to a "resource" on the World Wide Web.
	- You can create a URL object using the URL class constructor.

	Opening a Connection
	- To read from or write to a URL, you open a connection using the openConnection() method of the URL class, 
	  which returns a URLConnection object.

	Reading from a URL
	- To read data from a URL, you use the getInputStream() method of the URLConnection object, which returns an 
	  input stream.

	Writing to a URL
	- If the URL supports writing, you can use the getOutputStream() method of the URLConnection object to obtain an 
	  output stream.

	Handling Exceptions
	- Always handle exceptions such as MalformedURLException and IOException.


 - URLConnection class
	The URLConnection class in Java is part of the java.net package and represents a communication link between an application 
	and a URL. It is used to read from and write to a resource referenced by a URL.

	Key Features of URLConnection
	- Establishing a Connection: It allows you to open a connection to a URL.
	- Reading and Writing Data: It provides methods to read from and write to the resource.
	- Setting Request Properties: You can set various request properties (e.g., headers) for the connection.
	- Handling Different Protocols: It can handle different protocols like HTTP, HTTPS, FTP, etc.

	Reading Data from a URL
	Here's a complete example that demonstrates how to read data from a URL using URLConnection:

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;

public class URLProcessingExample {

    public static void main(String[] args) {
        try {
            // Create a URL object
            URL url = new URL("https://archerinfotech.in");

            // Open a connection to the URL
            URLConnection urlConnection = url.openConnection();

            // Get the input stream from the URL connection
            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));

            // Read data from the URL
            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                System.out.println(inputLine);
            }

            // Close the input stream
            in.close();

        } catch (MalformedURLException e) {
            System.out.println("The URL is malformed: " + e.getMessage());
        } catch (IOException e) {
            System.out.println("An I/O error occurred: " + e.getMessage());
        }
    }
}

//--------------------
	Writing Data to a URL
	
	If the URL supports writing (e.g., HTTP POST requests), you can write data to the URL using the getOutputStream() method 
	of the URLConnection class. 

import java.net.URL;
import java.net.URLConnection;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.io.IOException;

public class URLConnectionWriteExample {
    public static void main(String[] args) {
        try {
            // Create a URL object
            URL url = new URL("http://www.example.com/post");

            // Open a connection to the URL
            URLConnection urlConnection = url.openConnection();

            // Enable output for the connection
            urlConnection.setDoOutput(true);

            // Write data to the URL
            OutputStream outputStream = urlConnection.getOutputStream();
            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream));
            writer.write("param1=value1&param2=value2");
            writer.flush();
            writer.close();

        } catch (IOException e) {
            System.out.println("An I/O error occurred: " + e.getMessage());
        }
    }
}

//----------------------------------------------------------------------------------------------------------------------------

	// HttpURLConnection 

	The HttpURLConnection class in Java is part of the java.net package and provides an abstraction for managing 
	HTTP connections. It allows Java applications to communicate with web servers using the HTTP and HTTPS protocols. 
	This class provides methods to configure and manage the connection, send requests, and read responses from a web server.

	Important Methods in HttpURLConnection
	- setRequestMethod(String method): Sets the request method (e.g., GET, POST).
	  By setting the request method to GET, you are informing the server that you want to retrieve data from the 
	  specified URL. The server processes the request and returns the data associated with the URL.
	- setRequestProperty(String key, String value): Adds a request header with the specified key and value.
	- getResponseCode(): Returns the HTTP response code.
	- getInputStream(): Returns an input stream to read the response.
	- getOutputStream(): Returns an output stream to write data to the server (useful for POST requests).
	- setConnectTimeout(int timeout): Sets the connection timeout.
	- setReadTimeout(int timeout): Sets the read timeout.

import java.net.HttpURLConnection;
import java.net.URL;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStream;

public class HttpURLConnectionExample {
    public static void main(String[] args) {
        try {
            // Create a URL object
            URL url = new URL("https://jsonplaceholder.typicode.com/posts");

            // Open a connection to the URL
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();

            // Set the request method
            connection.setRequestMethod("GET");

            // Set request headers (optional)
            connection.setRequestProperty("User-Agent", "Mozilla/5.0");
	
            // Get the response code
            int responseCode = connection.getResponseCode();
            System.out.println("Response Code: " + responseCode);

            // Read the response
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String inputLine;
            StringBuffer response = new StringBuffer();

            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine);
            }
            in.close();

            // Print the response
            System.out.println("Response: " + response.toString());

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

//-----------------------------------------------------------------------------------------------------------------

	// Making an HTTP POST Request: HTTP POST is used to send data to a server to create/update a resource.

import java.net.HttpURLConnection;
import java.net.URL;
import java.io.OutputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;

public class HttpPostExample {
    public static void main(String[] args) {
        try {
            // Create a URL object
            URL url = new URL("https://jsonplaceholder.typicode.com/posts");

            // Open a connection to the URL
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();

            // Set the request method to POST
            connection.setRequestMethod("POST");

            // Set request headers
            connection.setRequestProperty("User-Agent", "Mozilla/5.0");
            connection.setRequestProperty("Content-Type", "application/json; utf-8");
            connection.setRequestProperty("Accept", "application/json");

            // Enable input and output streams
            connection.setDoOutput(true);

            // Create the JSON payload
            String jsonInputString = "{\"title\": \"foo\", \"body\": \"bar\", \"userId\": 1}";

            // Write the JSON data to the output stream
            try (OutputStream os = connection.getOutputStream()) {
                byte[] input = jsonInputString.getBytes("utf-8");
                os.write(input, 0, input.length);
            }

            // Get the response code
            int responseCode = connection.getResponseCode();
            System.out.println("Response Code: " + responseCode);

            // Read the response
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream(), "utf-8"));
            String inputLine;
            StringBuilder response = new StringBuilder();

            while ((inputLine = in.readLine()) != null) {
                response.append(inputLine.trim());
            }
            in.close();

            // Print the response
            System.out.println("Response: " + response.toString());

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}



 	list of commonly used HTTP status codes along with their meanings:

	- 200	OK - The request has succeeded
	- 201	Created - The request has been fulfilled and a new resource created
	- 204	No Content - The server successfully processed the request and is not returning any content
	- 301	Moved Permanently - The requested resource has been permanently moved to a new URL
	- 302	Found - The requested resource resides temporarily under a different URL
	- 400	Bad Request - The server cannot process the request due to client error (e.g., malformed request syntax)
	- 401	Unauthorized - The request requires user authentication
	- 403	Forbidden - The server understood the request but refuses to authorize it
	- 404	Not Found - The requested resource could not be found on the server
	- 405	Method Not Allowed - The method specified in the request is not allowed for the resource
	- 500	Internal Server Error - The server encountered an unexpected condition that prevented it from fulfilling the request
	- 502	Bad Gateway - The server received an invalid response from an inbound server
	- 503	Service Unavailable - The server is currently unable to handle the request due to a temporary overload 
		or maintenance of the server


//==================================================================================================================================
//==================================================================================================================================

	Remote Method Invocation (RMI) in Java:

	Introduction

	Remote Method Invocation (RMI) is a Java API that allows an object residing in one Java Virtual Machine (JVM)
	to invoke methods on an object located in another JVM, potentially on a different physical machine. 
	It enables distributed computing and is a key part of Java's network programming capabilities.

	Key Features of RMI
	- Allows method calls between remote Java objects.
	- Uses serialization to transfer data across networks.
	- Provides a secure and efficient way to build distributed applications.
	- Supports remote interfaces and object communication.
	- Architecture of RMI

	RMI follows a three-tier architecture:
	- Client: The application that invokes remote methods.
	- Server: The remote object that provides implementation.
	- RMI Registry: A lookup service that helps clients find remote objects.

	Steps to Implement RMI
	1. Create a Remote Interface
	The remote interface defines methods that can be invoked remotely. It must extend java.rmi.Remote and 
	each method should throw RemoteException.

import java.rmi.Remote;
import java.rmi.RemoteException;

public interface Calculator extends Remote {
    int add(int a, int b) throws RemoteException;
}


	2 Implement the Remote Interface: The server-side implementation of the remote interface.

import java.rmi.server.UnicastRemoteObject;
import java.rmi.RemoteException;

public class CalculatorImpl extends UnicastRemoteObject implements Calculator {
    protected CalculatorImpl() throws RemoteException {
        super();
    }

    public int add(int a, int b) throws RemoteException {
        return a + b;
    }
}

	3. Create and Register the RMI Server
		The server binds the remote object to the RMI registry.


import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class RMIServer {
    public static void main(String[] args) {
        try {
            Calculator calculator = new CalculatorImpl();
            Registry registry = LocateRegistry.createRegistry(1099);
            registry.rebind("CalculatorService", calculator);
            System.out.println("Server is running...");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


	4. Create the RMI Client: The client looks up the remote object and invokes methods.

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class RMIClient {
    public static void main(String[] args) {
        try {
            Registry registry = LocateRegistry.getRegistry("localhost", 1099);
            Calculator calculator = (Calculator) registry.lookup("CalculatorService");
            int result = calculator.add(5, 3);
            System.out.println("Result: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


	Advantages of RMI
	- Simple and direct communication between Java objects.
	- Built-in security and garbage collection.
	- Allows for object-oriented distributed applications.

	Disadvantages of RMI
	- Works only for Java-to-Java communication.
	- Requires Java RMI registry setup.
	- Can have performance overhead due to serialization.


//=======================================================================================================================
//=======================================================================================================================

	// Desigining Practical Application

	- Standalone Application
		- CLI(Console/commandline base Applications) --|
		- GUI Application -----------------------------|
							       | --- Data -> variables - objects - files ->
	- Web Application				       |				           
		- Server (Web Container, servlets, JSP,....) --|		-> Data_Base -> DBMS - RDBMS
													 |									
												         V
											Communication language
												   |
											   -----------------
											   |		   |
										          SQL             NoSQL	

	
	// Developing Standalone Application - CLI-File
	

// Model Class (Employee.java)
import java.io.*;
import java.util.*;

class Employee implements Serializable {
    private int id;
    private String name;
    private double salary;
    
    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    
    public int getId() { return id; }
    public String getName() { return name; }
    public double getSalary() { return salary; }
    
    public void setName(String name) { this.name = name; }
    public void setSalary(double salary) { this.salary = salary; }
    
    @Override
    public String toString() {
        return id + ", " + name + ", " + salary;
    }
}

//---------------
// Model Class (EmployeeDAO.java)
import java.io.*;
import java.util.*;
class EmployeeDAO {
    private static final String FILE_NAME = "employees.txt";
    
    public static List<Employee> getAllEmployees() {
        List<Employee> employees = new ArrayList<>();
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) {
            employees = (List<Employee>) ois.readObject();
        } catch (Exception ignored) {}
        return employees;
    }
    
    public static void saveEmployees(List<Employee> employees) {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_NAME))) {
            oos.writeObject(employees);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public static void addEmployee(Employee emp) {
        List<Employee> employees = getAllEmployees();
        employees.add(emp);
        saveEmployees(employees);
    }
    
    public static void updateEmployee(int id, String newName, double newSalary) {
        List<Employee> employees = getAllEmployees();
        for (Employee emp : employees) {
            if (emp.getId() == id) {
                emp.setName(newName);
                emp.setSalary(newSalary);
                break;
            }
        }
        saveEmployees(employees);
    }
    
    public static void deleteEmployee(int id) {
        List<Employee> employees = getAllEmployees();
        employees.removeIf(emp -> emp.getId() == id);
        saveEmployees(employees);
    }
}
//---------------
// View and Controller (EmployeeController.java)
import java.io.*;
import java.util.*;
class EmployeeController {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (true) {
            System.out.println("1. Add Employee\n2. View Employees\n3. Update Employee\n4. Delete Employee\n5. Exit");
            System.out.print("Choose an option: ");
            int choice = sc.nextInt();
            
            switch (choice) {
                case 1 -> {
                    System.out.print("Enter ID: ");
                    int id = sc.nextInt();
                    sc.nextLine();
                    System.out.print("Enter Name: ");
                    String name = sc.nextLine();
                    System.out.print("Enter Salary: ");
                    double salary = sc.nextDouble();
                    EmployeeDAO.addEmployee(new Employee(id, name, salary));
                }
                case 2 -> EmployeeDAO.getAllEmployees().forEach(System.out::println);
                case 3 -> {
                    System.out.print("Enter ID to Update: ");
                    int id = sc.nextInt();
                    sc.nextLine();
                    System.out.print("Enter New Name: ");
                    String name = sc.nextLine();
                    System.out.print("Enter New Salary: ");
                    double salary = sc.nextDouble();
                    EmployeeDAO.updateEmployee(id, name, salary);
                }
                case 4 -> {
                    System.out.print("Enter ID to Delete: ");
                    int id = sc.nextInt();
                    EmployeeDAO.deleteEmployee(id);
                }
                case 5 -> {
                    System.out.println("Exiting...");
                    sc.close();
                    return;
                }
                default -> System.out.println("Invalid Choice!");
            }
        }
    }
}


//---------------------------------------------------------------------------------------------

	//// Developing Standalone Application - GUI-File

import java.io.*;
import java.util.*;

// Model Class (Employee.java)
class Employee implements Serializable {
    private int id;
    private String name;
    private double salary;
    
    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    
    public int getId() { return id; }
    public String getName() { return name; }
    public double getSalary() { return salary; }
    
    public void setName(String name) { this.name = name; }
    public void setSalary(double salary) { this.salary = salary; }
    
    @Override
    public String toString() {
        return id + " - " + name + " - " + salary;
    }
}

//-------------------

// Data Access Object (EmployeeDAO.java)

import java.io.*;
import java.util.*;
class EmployeeDAO {
    private static final String FILE_NAME = "employees.txt";
    
    public static List<Employee> getAllEmployees() {
        List<Employee> employees = new ArrayList<>();
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_NAME))) {
            employees = (List<Employee>) ois.readObject();
        } catch (Exception ignored) {}
        return employees;
    }
    
    public static void saveEmployees(List<Employee> employees) {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_NAME))) {
            oos.writeObject(employees);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public static void addEmployee(Employee emp) {
        List<Employee> employees = getAllEmployees();
        employees.add(emp);
        saveEmployees(employees);
    }
    
    public static void updateEmployee(int id, String newName, double newSalary) {
        List<Employee> employees = getAllEmployees();
        boolean updated = false;
        for (Employee emp : employees) {
            if (emp.getId() == id) {
                emp.setName(newName);
                emp.setSalary(newSalary);
                updated = true;
                break;
            }
        }
        if (updated) {
            saveEmployees(employees);
        }
    }
    
    public static void deleteEmployee(int id) {
        List<Employee> employees = getAllEmployees();
        employees.removeIf(emp -> emp.getId() == id);
        saveEmployees(employees);
    }
}

//--------------------

// GUI Application (EmployeeManagementGUI.java)

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.*;

class EmployeeManagementGUI extends JFrame {
    private JTextField idField, nameField, salaryField;
    private DefaultListModel<String> listModel;
    private JList<String> employeeList;

    public EmployeeManagementGUI() {
        setTitle("Employee Management System");
        setSize(500, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());

        JPanel inputPanel = new JPanel(new GridLayout(4, 2));
        inputPanel.add(new JLabel("ID:"));
        idField = new JTextField();
        inputPanel.add(idField);
        
        inputPanel.add(new JLabel("Name:"));
        nameField = new JTextField();
        inputPanel.add(nameField);
        
        inputPanel.add(new JLabel("Salary:"));
        salaryField = new JTextField();
        inputPanel.add(salaryField);

        JButton addButton = new JButton("Add Employee");
        addButton.addActionListener(e -> addEmployee());
        inputPanel.add(addButton);

        JButton updateButton = new JButton("Update Employee");
        updateButton.addActionListener(e -> updateEmployee());
        inputPanel.add(updateButton);

        add(inputPanel, BorderLayout.NORTH);

        listModel = new DefaultListModel<>();
        employeeList = new JList<>(listModel);
        refreshList();
        add(new JScrollPane(employeeList), BorderLayout.CENTER);

        JPanel buttonPanel = new JPanel();
        JButton deleteButton = new JButton("Delete Employee");
        deleteButton.addActionListener(e -> deleteEmployee());
        buttonPanel.add(deleteButton);

        JButton refreshButton = new JButton("Refresh List");
        refreshButton.addActionListener(e -> refreshList());
        buttonPanel.add(refreshButton);

        add(buttonPanel, BorderLayout.SOUTH);
    }

    private void addEmployee() {
        int id = Integer.parseInt(idField.getText());
        String name = nameField.getText();
        double salary = Double.parseDouble(salaryField.getText());
        EmployeeDAO.addEmployee(new Employee(id, name, salary));
        refreshList();
    }

    private void updateEmployee() {
        if (!employeeList.isSelectionEmpty()) {
            String selected = employeeList.getSelectedValue();
            int id = Integer.parseInt(selected.split(" - ")[0]);
            String name = nameField.getText();
            double salary = Double.parseDouble(salaryField.getText());
            EmployeeDAO.updateEmployee(id, name, salary);
            refreshList();
        }
    }

    private void deleteEmployee() {
        if (!employeeList.isSelectionEmpty()) {
            String selected = employeeList.getSelectedValue();
            int id = Integer.parseInt(selected.split(" - ")[0]);
            EmployeeDAO.deleteEmployee(id);
            refreshList();
        }
    }

    private void refreshList() {
        listModel.clear();
        for (Employee emp : EmployeeDAO.getAllEmployees()) {
            listModel.addElement(emp.toString());
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> new EmployeeManagementGUI().setVisible(true));
    }
}

//--------------------------------------------------------------------------------------------------------

	// Here We are using the flat files to  store the data in a permanant maaner.

	Flat files are simple text or binary files that store data in a structured format, such as CSV, JSON, 
	or plain text. While they are easy to use and require minimal setup, they have several drawbacks:


	Drawbacks of Flat Files:

	- Lack of Scalability
		- Flat files are not optimized for handling large amounts of data efficiently.
		- Searching, updating, or querying data can be slow since there are no indexes.

	- Data Redundancy & Inconsistency
		- There is no mechanism to enforce data integrity, leading to duplicate and inconsistent data.

	- No Relationships Between Data
		- Unlike relational databases, flat files do not support relationships (e.g., foreign keys) 
		  between different records.

	- Limited Querying Capabilities
		- Retrieving specific data requires parsing the entire file, which is inefficient compared to 
		  databases that use indexing.

	- Concurrency Issues
		- Multiple users accessing or modifying a flat file at the same time can cause data corruption.

	- Security Concerns
		- Flat files lack built-in authentication and encryption mechanisms, making them vulnerable to 
		  unauthorized access.

	-Difficult Maintenance
		- As data grows, managing and modifying flat files becomes complex, requiring custom scripts for 
		  processing.


//--------------------------------------------------------

	Alternatives to Flat Files: Simply use the databases. If your application requires structured data with 
				    relationships, RDBMS is ideal. If you need scalability and flexibility, NoSQL 
				    or cloud-based solutions might be better.

		
	What is a Database?
	A database is an organized collection of data that is stored, managed, and retrieved electronically. 
	It allows users to store large amounts of structured or unstructured data efficiently and securely.

	Key Features of a Database
	- Data Organization – Stores data in a structured manner (tables, documents, key-value pairs, etc.).
	- Efficient Data Retrieval – Supports querying using languages like SQL.
	- Data Integrity & Consistency – Ensures accuracy and consistency using constraints (e.g., primary keys, foreign keys).
	- Data Security – Implements authentication and authorization mechanisms.
	- Concurrency Control – Allows multiple users to access and modify data simultaneously without conflicts.
	- Backup & Recovery – Provides mechanisms to recover lost data.


	There are many different database vendors, each offering different types of database management 
	systems (DBMS). These vendors can be categorized based on the type of database they provide, such as 
	relational, NoSQL, cloud-based, or in-memory databases. Here are some of the most well-known 
	database vendors:

	- Relational Database Vendors (RDBMS)
		- Oracle – Oracle Database
		- Microsoft – Microsoft SQL Server
		- IBM – IBM Db2
		- MySQL – Owned by Oracle
		- PostgreSQL – Open-source
		- MariaDB – Open-source, fork of MySQL
		- SAP – SAP HANA

	- NoSQL Database Vendors
		- MongoDB Inc. – MongoDB (Document Store)
		- Cassandra (Apache Foundation) – Wide Column Store
		- Redis Ltd. – Redis (Key-Value Store)
		- Couchbase – Couchbase Server (Document Store)
		- Neo4j Inc. – Neo4j (Graph Database)
		- Amazon Web Services (AWS) – DynamoDB (Key-Value Store)

	- Cloud Database Vendors
		- Amazon Web Services (AWS) – Amazon RDS, Amazon Aurora, Amazon Redshift
		- Microsoft Azure – Azure SQL Database, Cosmos DB
		- Google Cloud – Google Cloud Spanner, Google BigQuery
		- Oracle Cloud – Oracle Autonomous Database

	- In-Memory Database Vendors
		- Redis Ltd. – Redis
		- SAP – SAP HANA
		- VoltDB – VoltDB
		- TIBCO – ActiveSpaces

	Each of these vendors specializes in different aspects of database management, such as 
	scalability, performance, transaction support, or cloud-based solutions



	What is an API?
	API (Application Programming Interface) is a set of rules and protocols that allow different 
	software applications to communicate with each other. It defines how requests and responses 
	should be structured, enabling applications to interact with services, databases, or other 
	systems without needing to understand their internal workings.

	How Database Vendors Use APIs?
	Database vendors provide APIs to allow developers to interact with their databases programmatically. 
	These APIs help in performing CRUD (Create, Read, Update, Delete) operations, managing transactions, 
	and handling connections efficiently. They can be in the form of:

		- Native APIs (specific to a database vendor)
		- Standardized APIs (work across multiple database vendors)
		- RESTful/Web APIs (for cloud and web-based database interactions)


	Different Database-Related APIs

	1. SQL-Based Database APIs (Relational Databases): These APIs provide access to SQL-based 
	   databases like MySQL, PostgreSQL, Oracle, and SQL Server.

	   - JDBC (Java Database Connectivity) – API for Java applications to connect to relational databases.
	   - ODBC (Open Database Connectivity) – API for accessing databases in a language-independent way.
	   - ADO.NET (ActiveX Data Objects for .NET) – API for .NET applications to interact with databases.
	   - DBI (Database Interface for Perl) – API for database interaction in Perl.

	2. NoSQL Database APIs
	   These APIs allow applications to interact with NoSQL databases like MongoDB, Cassandra, and Redis.

	   - MongoDB Driver APIs – Libraries available in multiple languages (Java, Python, Node.js, etc.).
	   - Cassandra CQL (Cassandra Query Language) APIs – APIs to interact with Apache Cassandra.
	   - Redis Client APIs – Libraries for working with Redis in various languages (Jedis for Java, Node-Redis for Node.js, etc.).
	   - CouchDB REST API – RESTful API for interacting with CouchDB.

	3. Cloud Database APIs
	   Cloud-based databases provide REST APIs to interact with their services.
	
	   - Amazon DynamoDB API – API for accessing AWS DynamoDB.
	   - Google Firebase Realtime Database API – API for Firebase's NoSQL database.
	   - Azure Cosmos DB API – Multi-model database API for Azure Cosmos DB.
	   - Google Cloud Spanner API – API for working with Google’s distributed SQL database.

	4. Graph Database APIs
	   These APIs help in working with graph databases like Neo4j and Amazon Neptune.

	   - Neo4j Bolt Protocol API – API for connecting to Neo4j.
	   - Gremlin API – Used for Apache TinkerPop-based graph databases.
	   - Amazon Neptune API – Graph database API for AWS Neptune.

	5. Object-Relational Mapping (ORM) APIs
	   ORM APIs allow developers to work with databases using object-oriented programming.

	   - Hibernate (Java ORM API) – Used for Java applications to map objects to relational databases.
	   - Entity Framework (C# ORM API) – ORM for .NET applications.
	   - SQLAlchemy (Python ORM API) – ORM for Python applications.
	   - Django ORM (Python API) – ORM for Django framework.

	6. RESTful Database APIs
	These APIs provide database interaction using REST principles.

	   - PostgREST – REST API for PostgreSQL databases.
	   - Hasura GraphQL Engine – Auto-generates GraphQL APIs for databases.
	   - Oracle REST Data Services (ORDS) – REST API for Oracle databases.


 //---------------------------------------------------------------------------------------------------------

	// JDBC (Java Database Connectivity) and ORM (Object-Relational Mapping)

	JDBC and ORM are two different approaches to database interaction in Java applications.	

	1. JDBC (Java Database Connectivity)
	   JDBC is a Java API that allows applications to interact with relational databases using SQL 
	   queries. It provides a set of classes and interfaces for database connectivity, query execution, 
	   and result processing.

	2. ORM (Object-Relational Mapping)
	   ORM is a technique that maps Java objects to database tables, allowing developers to interact 
	   with the database using object-oriented principles instead of SQL queries.


//------------

	1. JDBC (Java Database Connectivity)

	JDBC is a Java API that allows applications to interact with relational databases using SQL 
	queries. It provides a set of classes and interfaces for database connectivity, query execution, 
	and result processing.

	Key Components of JDBC:
	 - DriverManager – Manages the database drivers.
	 - Connection – Establishes a connection with the database.
	 - Statement – Executes SQL queries.
	 - PreparedStatement – Executes precompiled parameterized queries.
	 - ResultSet – Stores the retrieved data from queries.

	JDBC Workflow:
	 - Load the JDBC driver. (Add Connector/j to class path)
	 - Establish a connection to the database.
	 - Create and execute SQL statements.
	 - Process the results.
	 - Close the connection.


	// Simple program to connect to database.

package databaseConnect;
import java.sql.*;
class DbConnectExample
{
	public static void main(String[] args) 
	{
		try
		{			
			// step 2: Load Drivers
			Class.forName("com.mysql.cj.jdbc.Driver");
			System.out.println("Drivers Loaded..!!");

			// step 3: Establish the Connection
			Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/demodb","root","Archer@12345");
			System.out.println("Connected");
		}
		catch(Exception e) {			
			System.out.println("Connection Issue: "+e);
		}
	}
}

//--------------------------------------------------------------------------------------------


	// Developing Standalone Application - CLI-MySQL Database

//Model Class (Employee.java)

package employee_app;
public class Employee {
 private int id;
 private String name;
 private double salary;
 
 public Employee(int id, String name, double salary) {
     this.id = id;
     this.name = name;
     this.salary = salary;
 }
 
 public int getId() { return id; }
 public String getName() { return name; }
 public double getSalary() { return salary; }
}

//------------------

// DBConnection.java

package employee_app;
import java.sql.*;
public class DBConnection {
    private static final String URL = "jdbc:mysql://localhost:3306/empdb";
    private static final String USER = "root";
    private static final String PASSWORD = "Archer@12345";
    
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }
}

//-----------------

	// EmployeeDAO.java

package employee_app;
import java.sql.*;
import java.util.*;
public class EmployeeDAO {
    public static void addEmployee(Employee emp) {
        String query = "INSERT INTO employees (id, name, salary) VALUES (?, ?, ?)";
        try (Connection conn = DBConnection.getConnection(); PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setInt(1, emp.getId());
            ps.setString(2, emp.getName());
            ps.setDouble(3, emp.getSalary());
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public static void updateEmployee(int id, String newName, double newSalary) {
        String query = "UPDATE employees SET name = ?, salary = ? WHERE id = ?";
        try (Connection conn = DBConnection.getConnection(); PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, newName);
            ps.setDouble(2, newSalary);
            ps.setInt(3, id);
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public static void deleteEmployee(int id) {
        String query = "DELETE FROM employees WHERE id = ?";
        try (Connection conn = DBConnection.getConnection(); PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setInt(1, id);
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public static List<Employee> getAllEmployees() {
        List<Employee> employees = new ArrayList<>();
        String query = "SELECT * FROM employees";
        try (Connection conn = DBConnection.getConnection(); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                employees.add(new Employee(rs.getInt("id"), rs.getString("name"), rs.getDouble("salary")));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return employees;
    }
}

//-------------------

	// EmployeeManagementConsole.java

package employee_app;

import java.util.List;
import java.util.Scanner;

public class EmployeeManagementConsole {
    private static final Scanner scanner = new Scanner(System.in);
    
    public static void main(String[] args) {
        while (true) {
            System.out.println("\nEmployee Management System");
            System.out.println("1. Add Employee");
            System.out.println("2. Update Employee");
            System.out.println("3. Delete Employee");
            System.out.println("4. View Employees");
            System.out.println("5. Exit");
            System.out.print("Enter choice: ");
            int choice = scanner.nextInt();
            
            switch (choice) {
                case 1 -> addEmployee();
                case 2 -> updateEmployee();
                case 3 -> deleteEmployee();
                case 4 -> viewEmployees();
                case 5 -> { System.out.println("Exiting..."); return; }
                default -> System.out.println("Invalid choice. Try again.");
            }
        }
    }
    
    private static void addEmployee() {
        System.out.print("Enter ID: ");
        int id = scanner.nextInt();
        scanner.nextLine();
        System.out.print("Enter Name: ");
        String name = scanner.nextLine();
        System.out.print("Enter Salary: ");
        double salary = scanner.nextDouble();
        EmployeeDAO.addEmployee(new Employee(id, name, salary));
        System.out.println("Employee added successfully!");
    }
    
    private static void updateEmployee() {
        System.out.print("Enter Employee ID to update: ");
        int id = scanner.nextInt();
        scanner.nextLine();
        System.out.print("Enter New Name: ");
        String name = scanner.nextLine();
        System.out.print("Enter New Salary: ");
        double salary = scanner.nextDouble();
        EmployeeDAO.updateEmployee(id, name, salary);
        System.out.println("Employee updated successfully!");
    }
    
    private static void deleteEmployee() {
        System.out.print("Enter Employee ID to delete: ");
        int id = scanner.nextInt();
        EmployeeDAO.deleteEmployee(id);
        System.out.println("Employee deleted successfully!");
    }
    
    private static void viewEmployees() {
        List<Employee> employees = EmployeeDAO.getAllEmployees();
        if (employees.isEmpty()) {
            System.out.println("No employees found.");
        } else {
            System.out.println("\nEmployee List:");
            for (Employee emp : employees) {
                System.out.println(emp.getId() + " - " + emp.getName() + " - " + emp.getSalary());
            }
        }
    }
}

//-----------------------------------------------------------------------------------------------------------------------

	// Developing Standalone Application - GUI-MySQL Database

// Database Connection Utility

	// DBConnection.java

import java.sql.*;
public class DBConnection {
    private static final String URL = "jdbc:mysql://localhost:3306/empdb";
    private static final String USER = "root";
    private static final String PASSWORD = "Archer@12345";
    
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(URL, USER, PASSWORD);
    }
}

//--------------------



// Model Class (Employee.java)
public class Employee {
    private int id;
    private String name;
    private double salary;
    
    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    
    public int getId() { return id; }
    public String getName() { return name; }
    public double getSalary() { return salary; }
}


//-----------------------

// Data Access Object (EmployeeDAO.java)

import java.sql.*;
import java.util.*;

public class EmployeeDAO {
    public static void addEmployee(Employee emp) {
        String query = "INSERT INTO employees (id, name, salary) VALUES (?, ?, ?)";
        try (Connection conn = DBConnection.getConnection(); PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setInt(1, emp.getId());
            ps.setString(2, emp.getName());
            ps.setDouble(3, emp.getSalary());
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public static void updateEmployee(int id, String newName, double newSalary) {
        String query = "UPDATE employees SET name = ?, salary = ? WHERE id = ?";
        try (Connection conn = DBConnection.getConnection(); PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setString(1, newName);
            ps.setDouble(2, newSalary);
            ps.setInt(3, id);
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public static void deleteEmployee(int id) {
        String query = "DELETE FROM employees WHERE id = ?";
        try (Connection conn = DBConnection.getConnection(); PreparedStatement ps = conn.prepareStatement(query)) {
            ps.setInt(1, id);
            ps.executeUpdate();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    
    public static List<Employee> getAllEmployees() {
        List<Employee> employees = new ArrayList<>();
        String query = "SELECT * FROM employees";
        try (Connection conn = DBConnection.getConnection(); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                employees.add(new Employee(rs.getInt("id"), rs.getString("name"), rs.getDouble("salary")));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return employees;
    }
}

//---------------------------

// GUI Application (EmployeeManagementGUI.java)

import java.awt.*;
import javax.swing.*;
import javax.swing.table.DefaultTableModel;

public class EmployeeManagementGUI extends JFrame {
    private JTextField txtId, txtName, txtSalary;
    private JTable table;
    private DefaultTableModel model;
    
    public EmployeeManagementGUI() {
        setTitle("Employee Management System");
        setSize(600, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());
        
        JPanel inputPanel = new JPanel(new GridLayout(4, 2));
        inputPanel.add(new JLabel("ID:"));
        txtId = new JTextField();
        inputPanel.add(txtId);
        
        inputPanel.add(new JLabel("Name:"));
        txtName = new JTextField();
        inputPanel.add(txtName);
        
        inputPanel.add(new JLabel("Salary:"));
        txtSalary = new JTextField();
        inputPanel.add(txtSalary);
        
        JButton btnAdd = new JButton("Add");
        btnAdd.addActionListener(e -> addEmployee());
        inputPanel.add(btnAdd);
        
        JButton btnUpdate = new JButton("Update");
        btnUpdate.addActionListener(e -> updateEmployee());
        inputPanel.add(btnUpdate);
        
        JButton btnDelete = new JButton("Delete");
        btnDelete.addActionListener(e -> deleteEmployee());
        inputPanel.add(btnDelete);
        
        add(inputPanel, BorderLayout.NORTH);
        
        model = new DefaultTableModel(new String[]{"ID", "Name", "Salary"}, 0);
        table = new JTable(model);
        add(new JScrollPane(table), BorderLayout.CENTER);
        
        refreshTable();
        setVisible(true);
    }
    
    private void addEmployee() {
        int id = Integer.parseInt(txtId.getText());
        String name = txtName.getText();
        double salary = Double.parseDouble(txtSalary.getText());
        EmployeeDAO.addEmployee(new Employee(id, name, salary));
        refreshTable();
    }
    
    private void updateEmployee() {
        int id = Integer.parseInt(txtId.getText());
        String name = txtName.getText();
        double salary = Double.parseDouble(txtSalary.getText());
        EmployeeDAO.updateEmployee(id, name, salary);
        refreshTable();
    }
    
    private void deleteEmployee() {
        int id = Integer.parseInt(txtId.getText());
        EmployeeDAO.deleteEmployee(id);
        refreshTable();
    }
    
    private void refreshTable() {
        model.setRowCount(0);
        for (Employee emp : EmployeeDAO.getAllEmployees()) {
            model.addRow(new Object[]{emp.getId(), emp.getName(), emp.getSalary()});
        }
    }
    
    public static void main(String[] args) {
        new EmployeeManagementGUI();
    }
}


//============================================================================================================================

	// Knowing the classes, interfaces and SQL Queries used in above program


	JDBC (Java Database Connectivity) provides a set of important classes and interfaces to interact with databases. Below are the key ones:

	Important Interfaces in JDBC
	- Driver – Defines methods that a JDBC driver must implement to interact with databases.
	- Connection – Represents a connection to a database and provides methods to create statements and manage transactions.
	- Statement – Used to execute static SQL queries.
	- PreparedStatement – Used for precompiled parameterized SQL queries.
	- CallableStatement – Used to execute stored procedures in the database.
	- ResultSet – Represents the result set of a query and provides methods to read data.

	Important Classes in JDBC
	- DriverManager – Manages a list of database drivers and establishes a connection to the database.
	- Types – Defines constants for SQL data types.
	- Blob – Represents a Binary Large Object (BLOB) for handling binary data like images, videos, etc.
	- Clob – Represents a Character Large Object (CLOB) for handling large text data.
	- SQLException – Handles SQL exceptions.


	Basic SQL Queries:
	list of important basic MySQL queries that every developer should know:

	1. Database Operations:
	- CREATE DATABASE mydatabase;  -- Create a new database
	- SHOW DATABASES;  -- List all databases
	- USE mydatabase;  -- Select a database to work with
	- DROP DATABASE mydatabase;  -- Delete a database


	2. Table Operations:
	- CREATE TABLE users (
    		id INT PRIMARY KEY AUTO_INCREMENT,
    		name VARCHAR(100) NOT NULL,
    		email VARCHAR(100) UNIQUE NOT NULL,
    		age INT,
    		created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	  );  -- Create a new table

	- SHOW TABLES;  -- List all tables in the database
	- DESC users;  -- Describe table structure
	- DROP TABLE users;  -- Delete a table


	3. Data Manipulation (CRUD Operations)
	  = INSERT Data:
	 	- INSERT INTO users (name, email, age) VALUES ('John Doe', 'john@example.com', 30);

	  = SELECT Data
	 	 - SELECT * FROM users;  -- Select all records
		 - SELECT name, email FROM users WHERE age > 25;  -- Select specific columns with a condition
		 - SELECT * FROM users ORDER BY name ASC;  -- Order results alphabetically
		 - SELECT * FROM users LIMIT 5;  -- Get first 5 records
		 - SELECT COUNT(*) FROM users;  -- Count the number of rows

	 = UPDATE Data	
		 - UPDATE users SET age = 35 WHERE name = 'John Doe';

	 = DELETE Data
		- DELETE FROM users WHERE id = 1;
		- TRUNCATE TABLE users;  -- Delete all records (faster than DELETE)

//------------

	2. ORM (Object-Relational Mapping)
	   Object-Relational Mapping (ORM) is a technique that allows developers to map Java objects to 
	   database tables. It helps in interacting with a database using Java objects instead of writing 
	   SQL queries manually. ORM frameworks handle database operations like CRUD (Create, Read, Update, 
	   Delete), relationships, transactions, and caching automatically.

	Why Use ORM?
	- Eliminates SQL writing – Developers work with Java objects instead of raw SQL queries.
	- Automatic Mapping – Tables are mapped to Java classes and columns to class attributes.
	- Database Independence – Makes it easy to switch between different databases (MySQL, PostgreSQL, Oracle, etc.).
	- Code Maintainability – Easier to manage and scale applications.
	- Improved Performance – Many ORM frameworks provide caching and lazy loading for better efficiency.


	What is JPA in Java?
	JPA (Java Persistence API) is a specification in Java that provides a standard way to manage 
	relational database interactions using Java objects. It is not a framework but a set of guidelines 
	that frameworks like Hibernate, EclipseLink, and OpenJPA implement.

 // Jakarta (Jakarta EE - Formerly Java EE)
 // Understanding javax.persistence and jakarta.persistence:
 // Built-Tools


	- Create the project (file -> new -> maven project -> next -> quickstart (internal))

	- Database:

	mysql> use empdb;
	Database changed
	mysql> show tables;
	+-----------------+
	| Tables_in_empdb |
	+-----------------+
	| employees       |
	+-----------------+
	1 row in set (0.00 sec)

	mysql> desc employees;
	+--------+---------------+------+-----+---------+----------------+
	| Field  | Type          | Null | Key | Default | Extra          |
	+--------+---------------+------+-----+---------+----------------+
	| id     | int           | NO   | PRI | NULL    | auto_increment |
	| name   | varchar(100)  | NO   |     | NULL    |                |
	| salary | decimal(10,2) | NO   |     | NULL    |                |
	+--------+---------------+------+-----+---------+----------------+
	3 rows in set (0.01 sec)

//-------------------

	- pom.xml(Project Object Model) - pom.xml is a Maven configuration file that: 
		- Manages project dependencies (like Hibernate, MySQL, JPA).
		- Defines build settings (compilation, testing, packaging).
		- Manages plugins for automated tasks.

<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>

	<groupId>com.archer</groupId>
	<artifactId>ORMDemo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<packaging>jar</packaging>

	<name>ORMDemo</name>
	<url>http://maven.apache.org</url>

	<properties>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
	</properties>

	<dependencies>
	
		<!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j -->
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<version>8.3.0</version>
		</dependency>

		 <!-- JPA API -->
        <dependency>
            <groupId>jakarta.persistence</groupId>
            <artifactId>jakarta.persistence-api</artifactId>
            <version>3.1.0</version>
        </dependency>

        <!-- Hibernate Core (ORM Implementation) -->
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-core</artifactId>
            <version>6.2.0.Final</version>
        </dependency>
        
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>3.8.1</version>
			<scope>test</scope>
		</dependency>

	</dependencies>
</project>




	- persistence.xml (src\main\resources): This persistence.xml file is a JPA (Java Persistence API) 
	  configuration file used to define database connection settings and Hibernate properties 
	  for ORM (Object-Relational Mapping).

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<persistence version="3.0" xmlns="https://jakarta.ee/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="https://jakarta.ee/xml/ns/persistence 
             https://jakarta.ee/xml/ns/persistence/persistence_3_0.xsd">
 
    <persistence-unit name="employee_pu">
        <properties>
            <property name="jakarta.persistence.jdbc.driver" value="com.mysql.cj.jdbc.Driver"/>
            <property name="jakarta.persistence.jdbc.url" value="jdbc:mysql://localhost:3306/empdb"/>
            <property name="jakarta.persistence.jdbc.user" value="root"/>
            <property name="jakarta.persistence.jdbc.password" value="Archer@12345"/>
            
            <property name="hibernate.hbm2ddl.auto" value="update"/>
            <property name="hibernate.dialect" value="org.hibernate.dialect.MySQL8Dialect"/>
            <property name="hibernate.show_sql" value="true"/>
        </properties>
    </persistence-unit>
</persistence>


	Terms:
	- version="3.0" → Specifies that we are using JPA 3.0 (latest version).
	- A persistence unit is like a configuration group that contains settings for database access.
	  This name (employee_pu) is used in Java to access the entity manager

	- <property name="hibernate.hbm2ddl.auto" value="update"/>
		Controls how Hibernate handles table creation/updating.
		Possible values:
			create → Drops and recreates tables every time (dangerous for production).
			update → Updates tables if needed (safest for development).
			validate → Just checks schema, but does not create or modify tables.
			none → Does nothing (useful for fully manual schema management).

	- <property name="hibernate.dialect" value="org.hibernate.dialect.MySQL8Dialect"/>
		- Defines which SQL dialect Hibernate should use.
		- MySQL8Dialect is used for MySQL 8+ versions.
		- If using an older version of MySQL, use org.hibernate.dialect.MySQLDialect.

	- <property name="hibernate.show_sql" value="true"/>
		- If true, Hibernate prints all SQL queries in the console/logs.
		- Useful for debugging and understanding how Hibernate interacts with the database.

//------------------------

	- Annotation:

	@Entity - Indicates that this class is an entity (i.e., it will be mapped to a database table).
		  Hibernate/JPA uses this annotation to recognize it as a persistent class.Without this 
		  annotation, Hibernate won't manage this class in the database.

	@Table(name = "employees"): Maps this entity to the database table employees. If not specified, 
		  the table name defaults to the class name (Employee).

	@Id
	private int id;
		Marks id as the primary key of the table. Every entity must have a primary key for 
		Hibernate to identify records uniquely.

	@GeneratedValue(strategy = GenerationType.IDENTITY)
		Specifies how the primary key (id) is auto-generated.
		GenerationType.IDENTITY means Uses database auto-increment (like MySQL AUTO_INCREMENT).

code (MVC)

package com.archer.ORMDemo;

import jakarta.persistence.*;
import java.util.List;
import java.util.Scanner;

// Entity Class
@Entity
@Table(name = "employees")
class Employee {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private int id;
	private String name;
	private double salary;

	public Employee() {
	}

	public Employee(String name, double salary) {
		this.setName(name);
		this.setSalary(salary);
	}

	public int getId() {
		return id;
	}

	public String getName() {
		return name;
	}

	public double getSalary() {
		return salary;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setSalary(double salary) {
		this.salary = salary;
	}
}

//DAO Class
class EmployeeDAO {
	private static final EntityManagerFactory emf = Persistence.createEntityManagerFactory("employee_pu");

	public static void addEmployee(Employee emp) {
		EntityManager em = emf.createEntityManager();
		EntityTransaction tx = em.getTransaction();
		tx.begin();
		em.persist(emp);
		tx.commit();
		em.close();
	}

	public static void updateEmployee(int id, String newName, double newSalary) {
		EntityManager em = emf.createEntityManager();
		EntityTransaction tx = em.getTransaction();
		tx.begin();
		Employee emp = em.find(Employee.class, id);
		if (emp != null) {
			emp.setName(newName);
			emp.setSalary(newSalary);
		}
		tx.commit();
		em.close();
	}

	public static void deleteEmployee(int id) {
		EntityManager em = emf.createEntityManager();
		EntityTransaction tx = em.getTransaction();
		tx.begin();
		Employee emp = em.find(Employee.class, id);
		if (emp != null) {
			em.remove(emp);
		}
		tx.commit();
		em.close();
	}

	public static List<Employee> getAllEmployees() {
		EntityManager em = emf.createEntityManager();
		List<Employee> employees = em.createQuery("SELECT e FROM Employee e", Employee.class).getResultList();
		em.close();
		return employees;
	}
}

//Console Application
public class EmployeeManagementConsole {
	private static final Scanner scanner = new Scanner(System.in);

	public static void main(String[] args) {
		while (true) {
			System.out.println("\nEmployee Management System");
			System.out.println("1. Add Employee");
			System.out.println("2. Update Employee");
			System.out.println("3. Delete Employee");
			System.out.println("4. View Employees");
			System.out.println("5. Exit");
			System.out.print("Enter choice: ");
			int choice = scanner.nextInt();

			switch (choice) {
			case 1 : addEmployee(); break;
			case 2 : updateEmployee();  break;
			case 3 : deleteEmployee(); break;
			case 4 : viewEmployees(); break;
			case 5 : {
				System.out.println("Exiting...");
				return;
			}
			default : System.out.println("Invalid choice. Try again.");
			}
		}
	}

	private static void addEmployee() {
		scanner.nextLine();
		System.out.print("Enter Name: ");
		String name = scanner.nextLine();
		System.out.print("Enter Salary: ");
		double salary = scanner.nextDouble();
		EmployeeDAO.addEmployee(new Employee(name, salary));
		System.out.println("Employee added successfully!");
	}

	private static void updateEmployee() {
		System.out.print("Enter Employee ID to update: ");
		int id = scanner.nextInt();
		scanner.nextLine();
		System.out.print("Enter New Name: ");
		String name = scanner.nextLine();
		System.out.print("Enter New Salary: ");
		double salary = scanner.nextDouble();
		EmployeeDAO.updateEmployee(id, name, salary);
		System.out.println("Employee updated successfully!");
	}

	private static void deleteEmployee() {
		System.out.print("Enter Employee ID to delete: ");
		int id = scanner.nextInt();
		EmployeeDAO.deleteEmployee(id);
		System.out.println("Employee deleted successfully!");
	}

	private static void viewEmployees() {
		List<Employee> employees = EmployeeDAO.getAllEmployees();
		if (employees.isEmpty()) {
			System.out.println("No employees found.");
		} else {
			System.out.println("\nEmployee List:");
			for (Employee emp : employees) {
				System.out.println(emp.getId() + " - " + emp.getName() + " - " + emp.getSalary());
			}
		}
	}
}

//-------------------------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------------------------

	- Development of Web Application in java